var __defPropseId(),
        r = a$a(),
        { id: i = `headlessui-description-${n}`, ...s } = e,
        a = f$7(),
        o = y$4(t);
    n$5(() => a.register(i), [i, a.register]);
    let l = r || !1,
        c = reactExports.useMemo(
            () => ({ ...a.slot, disabled: l }),
            [a.slot, l]
        ),
        u = { ref: o, ...a.props, id: i };
    return L$1()({
        ourProps: u,
        theirProps: s,
        slot: c,
        defaultTag: S$2,
        name: a.name || "Description",
    });
}
let _$1 = K(C$2),
    H$1 = Object.assign(_$1, {});
var o$1 =
        ((r2 = o$1 || {}),
        (r2.Space = " "),
        (r2.Enter = "Enter"),
        (r2.Escape = "Escape"),
        (r2.Backspace = "Backspace"),
        (r2.Delete = "Delete"),
        (r2.ArrowLeft = "ArrowLeft"),
        (r2.ArrowUp = "ArrowUp"),
        (r2.ArrowRight = "ArrowRight"),
        (r2.ArrowDown = "ArrowDown"),
        (r2.Home = "Home"),
        (r2.End = "End"),
        (r2.PageUp = "PageUp"),
        (r2.PageDown = "PageDown"),
        (r2.Tab = "Tab"),
        r2),
    r2;
let e$3 = reactExports.createContext(() => {});
function C$1({ value: e, children: t }) {
    return React$1.createElement(e$3.Provider, { value: e }, t);
}
let a$7 = class extends Map {
    constructor(e) {
        super(), (this.factory = e);
    }
    get(e) {
        let t = super.get(e);
        return void 0 === t && ((t = this.factory(e)), this.set(e, t)), t;
    }
};
function a$6(e, t) {
    let n = e(),
        r = new Set();
    return {
        getSnapshot: () => n,
        subscribe: (e) => (r.add(e), () => r.delete(e)),
        dispatch(e, ...i) {
            let s = t[e].call(n, ...i);
            s && ((n = s), r.forEach((e) => e()));
        },
    };
}
function o(e) {
    return reactExports.useSyncExternalStore(
        e.subscribe,
        e.getSnapshot,
        e.getSnapshot
    );
}
let p$3 = new a$7(() =>
    a$6(() => [], {
        ADD(e) {
            return this.includes(e) ? this : [...this, e];
        },
        REMOVE(e) {
            let t = this.indexOf(e);
            if (-1 === t) return this;
            let n = this.slice();
            return n.splice(t, 1), n;
        },
    })
);
function x$3(e, t) {
    let n = p$3.get(t),
        r = reactExports.useId(),
        i = o(n);
    if (
        (n$5(() => {
            if (e) return n.dispatch("ADD", r), () => n.dispatch("REMOVE", r);
        }, [n, e]),
        !e)
    )
        return !1;
    let s = i.indexOf(r),
        a = i.length;
    return -1 === s && ((s = a), (a += 1)), s === a - 1;
}
let f$6 = new Map(),
    u$3 = new Map();
function h$3(e) {
    var t;
    let n = null != (t = u$3.get(e)) ? t : 0;
    return (
        u$3.set(e, n + 1),
        0 !== n ||
            (f$6.set(e, {
                "aria-hidden": e.getAttribute("aria-hidden"),
                inert: e.inert,
            }),
            e.setAttribute("aria-hidden", "true"),
            (e.inert = !0)),
        () => m$5(e)
    );
}
function m$5(e) {
    var t;
    let n = null != (t = u$3.get(e)) ? t : 1;
    if ((1 === n ? u$3.delete(e) : u$3.set(e, n - 1), 1 !== n)) return;
    let r = f$6.get(e);
    r &&
        (null === r["aria-hidden"]
            ? e.removeAttribute("aria-hidden")
            : e.setAttribute("aria-hidden", r["aria-hidden"]),
        (e.inert = r.inert),
        f$6.delete(e));
}
function y$3(e, { allowed: t, disallowed: n } = {}) {
    let r = x$3(e, "inert-others");
    n$5(() => {
        var e, i;
        if (!r) return;
        let s = o$3();
        for (let t of null != (e = null == n ? void 0 : n()) ? e : [])
            t && s.add(h$3(t));
        let a = null != (i = null == t ? void 0 : t()) ? i : [];
        for (let t of a) {
            if (!t) continue;
            let e = u$6(t);
            if (!e) continue;
            let n = t.parentElement;
            for (; n && n !== e.body; ) {
                for (let e of n.children)
                    a.some((t) => e.contains(t)) || s.add(h$3(e));
                n = n.parentElement;
            }
        }
        return s.dispose;
    }, [r, t, n]);
}
function m$4(e, t, n) {
    let r = s$4((e) => {
        let t = e.getBoundingClientRect();
        0 === t.x && 0 === t.y && 0 === t.width && 0 === t.height && n();
    });
    reactExports.useEffect(() => {
        if (!e) return;
        let n = null === t ? null : t instanceof HTMLElement ? t : t.current;
        if (!n) return;
        let i = o$3();
        if ("undefined" != typeof ResizeObserver) {
            let e = new ResizeObserver(() => r.current(n));
            e.observe(n), i.add(() => e.disconnect());
        }
        if ("undefined" != typeof IntersectionObserver) {
            let e = new IntersectionObserver(() => r.current(n));
            e.observe(n), i.add(() => e.disconnect());
        }
        return () => i.dispose();
    }, [t, r, e]);
}
let f$5 = [
        "[contentEditable=true]",
        "[tabindex]",
        "a[href]",
        "area[href]",
        "button:not([disabled])",
        "iframe",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])",
    ]
        .map((e) => `${e}:not([tabindex='-1'])`)
        .join(","),
    p$2 = ["[data-autofocus]"]
        .map((e) => `${e}:not([tabindex='-1'])`)
        .join(",");
var F =
        ((n2 = F || {}),
        (n2[(n2.First = 1)] = "First"),
        (n2[(n2.Previous = 2)] = "Previous"),
        (n2[(n2.Next = 4)] = "Next"),
        (n2[(n2.Last = 8)] = "Last"),
        (n2[(n2.WrapAround = 16)] = "WrapAround"),
        (n2[(n2.NoScroll = 32)] = "NoScroll"),
        (n2[(n2.AutoFocus = 64)] = "AutoFocus"),
        n2),
    T$1 =
        ((o3 = T$1 || {}),
        (o3[(o3.Error = 0)] = "Error"),
        (o3[(o3.Overflow = 1)] = "Overflow"),
        (o3[(o3.Success = 2)] = "Success"),
        (o3[(o3.Underflow = 3)] = "Underflow"),
        o3),
    y$2 =
        ((t2 = y$2 || {}),
        (t2[(t2.Previous = -1)] = "Previous"),
        (t2[(t2.Next = 1)] = "Next"),
        t2),
    t2,
    o3,
    n2;
function b$4(e = document.body) {
    return null == e
        ? []
        : Array.from(e.querySelectorAll(f$5)).sort((e, t) =>
              Math.sign(
                  (e.tabIndex || Number.MAX_SAFE_INTEGER) -
                      (t.tabIndex || Number.MAX_SAFE_INTEGER)
              )
          );
}
function S$1(e = document.body) {
    return null == e
        ? []
        : Array.from(e.querySelectorAll(p$2)).sort((e, t) =>
              Math.sign(
                  (e.tabIndex || Number.MAX_SAFE_INTEGER) -
                      (t.tabIndex || Number.MAX_SAFE_INTEGER)
              )
          );
}
var h$2 = ((e) => (
    (e[(e.Strict = 0)] = "Strict"), (e[(e.Loose = 1)] = "Loose"), e
))(h$2 || {});
function A$1(e, t = 0) {
    var n;
    return (
        e !== (null == (n = u$6(e)) ? void 0 : n.body) &&
        u$5(t, {
            0: () => e.matches(f$5),
            1() {
                let t = e;
                for (; null !== t; ) {
                    if (t.matches(f$5)) return !0;
                    t = t.parentElement;
                }
                return !1;
            },
        })
    );
}
var H = ((e) => (
    (e[(e.Keyboard = 0)] = "Keyboard"), (e[(e.Mouse = 1)] = "Mouse"), e
))(H || {});
function I$2(e) {
    null == e || e.focus({ preventScroll: !0 });
}
"undefined" != typeof window &&
    "undefined" != typeof document &&
    (document.addEventListener(
        "keydown",
        (e) => {
            e.metaKey ||
                e.altKey ||
                e.ctrlKey ||
                (document.documentElement.dataset.headlessuiFocusVisible = "");
        },
        !0
    ),
    document.addEventListener(
        "click",
        (e) => {
            1 === e.detail
                ? delete document.documentElement.dataset.headlessuiFocusVisible
                : 0 === e.detail &&
                  (document.documentElement.dataset.headlessuiFocusVisible =
                      "");
        },
        !0
    ));
let w$3 = ["textarea", "input"].join(",");
function O$2(e) {
    var t, n;
    return (
        null !=
            (n =
                null == (t = null == e ? void 0 : e.matches)
                    ? void 0
                    : t.call(e, w$3)) && n
    );
}
function _(e, t = (e) => e) {
    return e.slice().sort((e, n) => {
        let r = t(e),
            i = t(n);
        if (null === r || null === i) return 0;
        let s = r.compareDocumentPosition(i);
        return s & Node.DOCUMENT_POSITION_FOLLOWING
            ? -1
            : s & Node.DOCUMENT_POSITION_PRECEDING
            ? 1
            : 0;
    });
}
function P(
    e,
    t,
    { sorted: n = !0, relativeTo: r = null, skipElements: i = [] } = {}
) {
    let s = Array.isArray(e)
            ? e.length > 0
                ? e[0].ownerDocument
                : document
            : e.ownerDocument,
        a = Array.isArray(e) ? (n ? _(e) : e) : 64 & t ? S$1(e) : b$4(e);
    i.length > 0 &&
        a.length > 1 &&
        (a = a.filter(
            (e) =>
                !i.some((t) =>
                    null != t && "current" in t
                        ? (null == t ? void 0 : t.current) === e
                        : t === e
                )
        )),
        (r = null != r ? r : s.activeElement);
    let o,
        l = (() => {
            if (5 & t) return 1;
            if (10 & t) return -1;
            throw new Error(
                "Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
            );
        })(),
        c = (() => {
            if (1 & t) return 0;
            if (2 & t) return Math.max(0, a.indexOf(r)) - 1;
            if (4 & t) return Math.max(0, a.indexOf(r)) + 1;
            if (8 & t) return a.length - 1;
            throw new Error(
                "Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last"
            );
        })(),
        u = 32 & t ? { preventScroll: !0 } : {},
        d = 0,
        p = a.length;
    do {
        if (d >= p || d + p <= 0) return 0;
        let e = c + d;
        if (16 & t) e = (e + p) % p;
        else {
            if (e < 0) return 3;
            if (e >= p) return 1;
        }
        (o = a[e]), null == o || o.focus(u), (d += l);
    } while (o !== s.activeElement);
    return 6 & t && O$2(o) && o.select(), 2;
}
function t$3() {
    return (
        /iPhone/gi.test(window.navigator.platform) ||
        (/Mac/gi.test(window.navigator.platform) &&
            window.navigator.maxTouchPoints > 0)
    );
}
function i$2() {
    return /Android/gi.test(window.navigator.userAgent);
}
function n$4() {
    return t$3() || i$2();
}
function i$1(e, t, n, r) {
    let i = s$4(n);
    reactExports.useEffect(() => {
        if (e)
            return (
                document.addEventListener(t, n, r),
                () => document.removeEventListener(t, n, r)
            );
        function n(e) {
            i.current(e);
        }
    }, [e, t, r]);
}
function s$2(e, t, n, r) {
    let i = s$4(n);
    reactExports.useEffect(() => {
        if (e)
            return (
                window.addEventListener(t, n, r),
                () => window.removeEventListener(t, n, r)
            );
        function n(e) {
            i.current(e);
        }
    }, [e, t, r]);
}
const E$1 = 30;
function R$2(e, t, n) {
    let r = x$3(e, "outside-click"),
        i = s$4(n),
        s = reactExports.useCallback(
            function (e, n) {
                if (e.defaultPrevented) return;
                let r = n(e);
                if (
                    null === r ||
                    !r.getRootNode().contains(r) ||
                    !r.isConnected
                )
                    return;
                let s = (function e(t) {
                    return "function" == typeof t
                        ? e(t())
                        : Array.isArray(t) || t instanceof Set
                        ? t
                        : [t];
                })(t);
                for (let t of s)
                    if (
                        null !== t &&
                        (t.contains(r) ||
                            (e.composed && e.composedPath().includes(t)))
                    )
                        return;
                return (
                    !A$1(r, h$2.Loose) &&
                        -1 !== r.tabIndex &&
                        e.preventDefault(),
                    i.current(e, r)
                );
            },
            [i, t]
        ),
        a = reactExports.useRef(null);
    i$1(
        r,
        "pointerdown",
        (e) => {
            var t, n;
            a.current =
                (null == (n = null == (t = e.composedPath) ? void 0 : t.call(e))
                    ? void 0
                    : n[0]) || e.target;
        },
        !0
    ),
        i$1(
            r,
            "mousedown",
            (e) => {
                var t, n;
                a.current =
                    (null ==
                    (n = null == (t = e.composedPath) ? void 0 : t.call(e))
                        ? void 0
                        : n[0]) || e.target;
            },
            !0
        ),
        i$1(
            r,
            "click",
            (e) => {
                n$4() ||
                    (a.current && (s(e, () => a.current), (a.current = null)));
            },
            !0
        );
    let o = reactExports.useRef({ x: 0, y: 0 });
    i$1(
        r,
        "touchstart",
        (e) => {
            (o.current.x = e.touches[0].clientX),
                (o.current.y = e.touches[0].clientY);
        },
        !0
    ),
        i$1(
            r,
            "touchend",
            (e) => {
                let t = e.changedTouches[0].clientX,
                    n = e.changedTouches[0].clientY;
                if (
                    !(
                        Math.abs(t - o.current.x) >= E$1 ||
                        Math.abs(n - o.current.y) >= E$1
                    )
                )
                    return s(e, () =>
                        e.target instanceof HTMLElement ? e.target : null
                    );
            },
            !0
        ),
        s$2(
            r,
            "blur",
            (e) =>
                s(e, () =>
                    window.document.activeElement instanceof HTMLIFrameElement
                        ? window.document.activeElement
                        : null
                ),
            !0
        );
}
function n$3(...e) {
    return reactExports.useMemo(() => u$6(...e), [...e]);
}
function E(e, t, n, r) {
    let i = s$4(n);
    reactExports.useEffect(() => {
        function n(e) {
            i.current(e);
        }
        return (
            (e = null != e ? e : window).addEventListener(t, n, r),
            () => e.removeEventListener(t, n, r)
        );
    }, [e, t, r]);
}
function d$3() {
    let e;
    return {
        before({ doc: t }) {
            var n;
            let r = t.documentElement,
                i = null != (n = t.defaultView) ? n : window;
            e = Math.max(0, i.innerWidth - r.clientWidth);
        },
        after({ doc: t, d: n }) {
            let r = t.documentElement,
                i = Math.max(0, r.clientWidth - r.offsetWidth),
                s = Math.max(0, e - i);
            n.style(r, "paddingRight", `${s}px`);
        },
    };
}
function d$2() {
    return t$3()
        ? {
              before({ doc: e, d: t, meta: n }) {
                  function r(e) {
                      return n.containers
                          .flatMap((e) => e())
                          .some((t) => t.contains(e));
                  }
                  t.microTask(() => {
                      var n;
                      if (
                          "auto" !==
                          window.getComputedStyle(e.documentElement)
                              .scrollBehavior
                      ) {
                          let n = o$3();
                          n.style(e.documentElement, "scrollBehavior", "auto"),
                              t.add(() => t.microTask(() => n.dispose()));
                      }
                      let i =
                              null != (n = window.scrollY)
                                  ? n
                                  : window.pageYOffset,
                          s = null;
                      t.addEventListener(
                          e,
                          "click",
                          (t) => {
                              if (t.target instanceof HTMLElement)
                                  try {
                                      let n = t.target.closest("a");
                                      if (!n) return;
                                      let { hash: i } = new URL(n.href),
                                          a = e.querySelector(i);
                                      a && !r(a) && (s = a);
                                  } catch {}
                          },
                          !0
                      ),
                          t.addEventListener(e, "touchstart", (e) => {
                              if (e.target instanceof HTMLElement)
                                  if (r(e.target)) {
                                      let n = e.target;
                                      for (
                                          ;
                                          n.parentElement && r(n.parentElement);

                                      )
                                          n = n.parentElement;
                                      t.style(
                                          n,
                                          "overscrollBehavior",
                                          "contain"
                                      );
                                  } else
                                      t.style(e.target, "touchAction", "none");
                          }),
                          t.addEventListener(
                              e,
                              "touchmove",
                              (e) => {
                                  if (e.target instanceof HTMLElement) {
                                      if ("INPUT" === e.target.tagName) return;
                                      if (r(e.target)) {
                                          let t = e.target;
                                          for (
                                              ;
                                              t.parentElement &&
                                              "" !==
                                                  t.dataset.headlessuiPortal &&
                                              !(
                                                  t.scrollHeight >
                                                      t.clientHeight ||
                                                  t.scrollWidth > t.clientWidth
                                              );

                                          )
                                              t = t.parentElement;
                                          "" === t.dataset.headlessuiPortal &&
                                              e.preventDefault();
                                      } else e.preventDefault();
                                  }
                              },
                              { passive: !1 }
                          ),
                          t.add(() => {
                              var e;
                              let t =
                                  null != (e = window.scrollY)
                                      ? e
                                      : window.pageYOffset;
                              i !== t && window.scrollTo(0, i),
                                  s &&
                                      s.isConnected &&
                                      (s.scrollIntoView({ block: "nearest" }),
                                      (s = null));
                          });
                  });
              },
          }
        : {};
}
function r$2() {
    return {
        before({ doc: e, d: t }) {
            t.style(e.documentElement, "overflow", "hidden");
        },
    };
}
function m$3(e) {
    let t = {};
    for (let n of e) Object.assign(t, n(t));
    return t;
}
let a$5 = a$6(() => new Map(), {
    PUSH(e, t) {
        var n;
        let r =
            null != (n = this.get(e))
                ? n
                : { doc: e, count: 0, d: o$3(), meta: new Set() };
        return r.count++, r.meta.add(t), this.set(e, r), this;
    },
    POP(e, t) {
        let n = this.get(e);
        return n && (n.count--, n.meta.delete(t)), this;
    },
    SCROLL_PREVENT({ doc: e, d: t, meta: n }) {
        let r = { doc: e, d: t, meta: m$3(n) },
            i = [d$2(), d$3(), r$2()];
        i.forEach(({ before: e }) => (null == e ? void 0 : e(r))),
            i.forEach(({ after: e }) => (null == e ? void 0 : e(r)));
    },
    SCROLL_ALLOW({ d: e }) {
        e.dispose();
    },
    TEARDOWN({ doc: e }) {
        this.delete(e);
    },
});
function a$4(e, t, n = () => ({ containers: [] })) {
    let r = o(a$5),
        i = t ? r.get(t) : void 0,
        s = !!i && i.count > 0;
    return (
        n$5(() => {
            if (t && e)
                return (
                    a$5.dispatch("PUSH", t, n), () => a$5.dispatch("POP", t, n)
                );
        }, [e, t]),
        s
    );
}
function f$4(e, t, n = () => [document.body]) {
    a$4(x$3(e, "scroll-lock"), t, (e) => {
        var t;
        return { containers: [...(null != (t = e.containers) ? t : []), n] };
    });
}
function c$4(e = 0) {
    let [t, n] = reactExports.useState(e),
        r = reactExports.useCallback((e) => n(e), [t]),
        i = reactExports.useCallback((e) => n((t) => t | e), [t]),
        s = reactExports.useCallback((e) => (t & e) === e, [t]),
        a = reactExports.useCallback((e) => n((t) => t & ~e), [n]),
        o = reactExports.useCallback((e) => n((t) => t ^ e), [n]);
    return {
        flags: t,
        setFlag: r,
        addFlag: i,
        hasFlag: s,
        removeFlag: a,
        toggleFlag: o,
    };
}
a$5.subscribe(() => {
    let e = a$5.getSnapshot(),
        t = new Map();
    for (let [n] of e) t.set(n, n.documentElement.style.overflow);
    for (let n of e.values()) {
        let e = "hidden" === t.get(n.doc),
            r = 0 !== n.count;
        ((r && !e) || (!r && e)) &&
            a$5.dispatch(n.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", n),
            0 === n.count && a$5.dispatch("TEARDOWN", n);
    }
});
var define_process_env_default = {},
    T,
    b$3;
"undefined" != typeof process &&
    "undefined" != typeof globalThis &&
    "undefined" != typeof Element &&
    "test" ===
        (null == (T = null == process ? void 0 : define_process_env_default)
            ? void 0
            : T.NODE_ENV) &&
    void 0 ===
        (null == (b$3 = null == Element ? void 0 : Element.prototype)
            ? void 0
            : b$3.getAnimations) &&
    (Element.prototype.getAnimations = function () {
        return (
            console.warn(
                [
                    "Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.",
                    "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.",
                    "",
                    "Example usage:",
                    "```js",
                    "import { mockAnimationsApi } from 'jsdom-testing-mocks'",
                    "mockAnimationsApi()",
                    "```",
                ].join("\n")
            ),
            []
        );
    });
var L = ((e) => (
    (e[(e.None = 0)] = "None"),
    (e[(e.Closed = 1)] = "Closed"),
    (e[(e.Enter = 2)] = "Enter"),
    (e[(e.Leave = 4)] = "Leave"),
    e
))(L || {});
function R$1(e) {
    let t = {};
    for (let n in e) !0 === e[n] && (t[`data-${n}`] = "");
    return t;
}
function x$2(e, t, n, r) {
    let [i, s] = reactExports.useState(n),
        { hasFlag: a, addFlag: o, removeFlag: l } = c$4(e && i ? 3 : 0),
        c = reactExports.useRef(!1),
        u = reactExports.useRef(!1),
        d = p$4();
    return (
        n$5(() => {
            var i;
            if (e)
                return (
                    n && s(!0),
                    t
                        ? (null == (i = null == r ? void 0 : r.start) ||
                              i.call(r, n),
                          C(t, {
                              inFlight: c,
                              prepare() {
                                  u.current
                                      ? (u.current = !1)
                                      : (u.current = c.current),
                                      (c.current = !0),
                                      !u.current &&
                                          (n ? (o(3), l(4)) : (o(4), l(2)));
                              },
                              run() {
                                  u.current
                                      ? n
                                          ? (l(3), o(4))
                                          : (l(4), o(3))
                                      : n
                                      ? l(1)
                                      : o(1);
                              },
                              done() {
                                  var e;
                                  (u.current &&
                                      "function" == typeof t.getAnimations &&
                                      t.getAnimations().length > 0) ||
                                      ((c.current = !1),
                                      l(7),
                                      n || s(!1),
                                      null ==
                                          (e = null == r ? void 0 : r.end) ||
                                          e.call(r, n));
                              },
                          }))
                        : void (n && o(3))
                );
        }, [e, n, t, d]),
        e
            ? [
                  i,
                  {
                      closed: a(1),
                      enter: a(2),
                      leave: a(4),
                      transition: a(2) || a(4),
                  },
              ]
            : [
                  n,
                  {
                      closed: void 0,
                      enter: void 0,
                      leave: void 0,
                      transition: void 0,
                  },
              ]
    );
}
function C(e, { prepare: t, run: n, done: r, inFlight: i }) {
    let s = o$3();
    return (
        j$1(e, { prepare: t, inFlight: i }),
        s.nextFrame(() => {
            n(),
                s.requestAnimationFrame(() => {
                    s.add(M$2(e, r));
                });
        }),
        s.dispose
    );
}
function M$2(e, t) {
    var n, r;
    let i = o$3();
    if (!e) return i.dispose;
    let s = !1;
    i.add(() => {
        s = !0;
    });
    let a =
        null !=
        (r =
            null == (n = e.getAnimations)
                ? void 0
                : n.call(e).filter((e) => e instanceof CSSTransition))
            ? r
            : [];
    return 0 === a.length
        ? (t(), i.dispose)
        : (Promise.allSettled(a.map((e) => e.finished)).then(() => {
              s || t();
          }),
          i.dispose);
}
function j$1(e, { inFlight: t, prepare: n }) {
    if (null != t && t.current) return void n();
    let r = e.style.transition;
    (e.style.transition = "none"),
        n(),
        e.offsetHeight,
        (e.style.transition = r);
}
function m$2(e, t) {
    let n = reactExports.useRef([]),
        r = o$2(e);
    reactExports.useEffect(() => {
        let e = [...n.current];
        for (let [i, s] of t.entries())
            if (n.current[i] !== s) {
                let i = r(t, e);
                return (n.current = t), i;
            }
    }, [r, ...t]);
}
let n$2 = reactExports.createContext(null);
n$2.displayName = "OpenClosedContext";
var i = ((e) => (
    (e[(e.Open = 1)] = "Open"),
    (e[(e.Closed = 2)] = "Closed"),
    (e[(e.Closing = 4)] = "Closing"),
    (e[(e.Opening = 8)] = "Opening"),
    e
))(i || {});
function u$2() {
    return reactExports.useContext(n$2);
}
function c$3({ value: e, children: t }) {
    return React$1.createElement(n$2.Provider, { value: e }, t);
}
function s$1({ children: e }) {
    return React$1.createElement(n$2.Provider, { value: null }, e);
}
function t$2(e) {
    function t() {
        "loading" !== document.readyState &&
            (e(), document.removeEventListener("DOMContentLoaded", t));
    }
    "undefined" != typeof window &&
        "undefined" != typeof document &&
        (document.addEventListener("DOMContentLoaded", t), t());
}
let r$1 = [];
function c$2(e) {
    let t = o$2(e),
        n = reactExports.useRef(!1);
    reactExports.useEffect(
        () => (
            (n.current = !1),
            () => {
                (n.current = !0),
                    t$5(() => {
                        n.current && t();
                    });
            }
        ),
        [t]
    );
}
function s() {
    let e = "undefined" == typeof document;
    return (
        "useSyncExternalStore" in React$2 &&
        React$2.useSyncExternalStore(
            () => () => {},
            () => !1,
            () => !e
        )
    );
}
function l$3() {
    let e = s(),
        [t, n] = reactExports.useState(s$5.isHandoffComplete);
    return (
        t && !1 === s$5.isHandoffComplete && n(!1),
        reactExports.useEffect(() => {
            !0 !== t && n(!0);
        }, [t]),
        reactExports.useEffect(() => s$5.handoff(), []),
        !e && t
    );
}
t$2(() => {
    function e(e) {
        if (
            !(e.target instanceof HTMLElement) ||
            e.target === document.body ||
            r$1[0] === e.target
        )
            return;
        let t = e.target;
        (t = t.closest(f$5)),
            r$1.unshift(null != t ? t : e.target),
            (r$1 = r$1.filter((e) => null != e && e.isConnected)),
            r$1.splice(10);
    }
    window.addEventListener("click", e, { capture: !0 }),
        window.addEventListener("mousedown", e, { capture: !0 }),
        window.addEventListener("focus", e, { capture: !0 }),
        document.body.addEventListener("click", e, { capture: !0 }),
        document.body.addEventListener("mousedown", e, { capture: !0 }),
        document.body.addEventListener("focus", e, { capture: !0 });
});
let e$2 = reactExports.createContext(!1);
function a$3() {
    return reactExports.useContext(e$2);
}
function l$2(e) {
    return React$1.createElement(e$2.Provider, { value: e.force }, e.children);
}
function N(e) {
    let t = a$3(),
        n = reactExports.useContext(v$2),
        r = n$3(e),
        [i, s] = reactExports.useState(() => {
            var e;
            if (!t && null !== n) return null != (e = n.current) ? e : null;
            if (s$5.isServer) return null;
            let i =
                null == r ? void 0 : r.getElementById("headlessui-portal-root");
            if (i) return i;
            if (null === r) return null;
            let s = r.createElement("div");
            return (
                s.setAttribute("id", "headlessui-portal-root"),
                r.body.appendChild(s)
            );
        });
    return (
        reactExports.useEffect(() => {
            null !== i &&
                ((null != r && r.body.contains(i)) ||
                    null == r ||
                    r.body.appendChild(i));
        }, [i, r]),
        reactExports.useEffect(() => {
            t || (null !== n && s(n.current));
        }, [n, s, t]),
        i
    );
}
let M$1 = reactExports.Fragment,
    S = K(function (e, t) {
        let n = e,
            r = reactExports.useRef(null),
            i = y$4(
                T$2((e) => {
                    r.current = e;
                }),
                t
            ),
            s = n$3(r),
            a = N(r),
            [o] = reactExports.useState(() => {
                var e;
                return s$5.isServer
                    ? null
                    : null != (e = null == s ? void 0 : s.createElement("div"))
                    ? e
                    : null;
            }),
            l = reactExports.useContext(y$1),
            c = l$3();
        n$5(() => {
            !a ||
                !o ||
                a.contains(o) ||
                (o.setAttribute("data-headlessui-portal", ""),
                a.appendChild(o));
        }, [a, o]),
            n$5(() => {
                if (o && l) return l.register(o);
            }, [l, o]),
            c$2(() => {
                var e;
                !a ||
                    !o ||
                    (o instanceof Node && a.contains(o) && a.removeChild(o),
                    a.childNodes.length <= 0 &&
                        (null == (e = a.parentElement) || e.removeChild(a)));
            });
        let u = L$1();
        return c && a && o
            ? reactDomExports.createPortal(
                  u({
                      ourProps: { ref: i },
                      theirProps: n,
                      slot: {},
                      defaultTag: M$1,
                      name: "Portal",
                  }),
                  o
              )
            : null;
    });
function j(e, t) {
    let n = y$4(t),
        { enabled: r = !0, ...i } = e,
        s = L$1();
    return r
        ? React$1.createElement(S, { ...i, ref: n })
        : s({
              ourProps: { ref: n },
              theirProps: i,
              slot: {},
              defaultTag: M$1,
              name: "Portal",
          });
}
let W = reactExports.Fragment,
    v$2 = reactExports.createContext(null);
function I$1(e, t) {
    let { target: n, ...r } = e,
        i = { ref: y$4(t) },
        s = L$1();
    return React$1.createElement(
        v$2.Provider,
        { value: n },
        s({ ourProps: i, theirProps: r, defaultTag: W, name: "Popover.Group" })
    );
}
let y$1 = reactExports.createContext(null);
function te$1() {
    let e = reactExports.useContext(y$1),
        t = reactExports.useRef([]),
        n = o$2((n) => (t.current.push(n), e && e.register(n), () => r(n))),
        r = o$2((n) => {
            let r = t.current.indexOf(n);
            -1 !== r && t.current.splice(r, 1), e && e.unregister(n);
        }),
        i = reactExports.useMemo(
            () => ({ register: n, unregister: r, portals: t }),
            [n, r, t]
        );
    return [
        t,
        reactExports.useMemo(
            () =>
                function ({ children: e }) {
                    return React$1.createElement(y$1.Provider, { value: i }, e);
                },
            [i]
        ),
    ];
}
let J = K(j),
    X$1 = K(I$1),
    re$1 = Object.assign(J, { Group: X$1 });
function a$2(
    e,
    t = "undefined" != typeof document ? document.defaultView : null,
    n
) {
    let r = x$3(e, "escape");
    E(t, "keydown", (e) => {
        r && (e.defaultPrevented || (e.key === o$1.Escape && n(e)));
    });
}
function f$3() {
    var e;
    let [t] = reactExports.useState(() =>
            "undefined" != typeof window &&
            "function" == typeof window.matchMedia
                ? window.matchMedia("(pointer: coarse)")
                : null
        ),
        [n, r] = reactExports.useState(
            null != (e = null == t ? void 0 : t.matches) && e
        );
    return (
        n$5(() => {
            if (t)
                return (
                    t.addEventListener("change", e),
                    () => t.removeEventListener("change", e)
                );
            function e(e) {
                r(e.matches);
            }
        }, [t]),
        n
    );
}
function R({ defaultContainers: e = [], portals: t, mainTreeNode: n } = {}) {
    let r = n$3(n),
        i = o$2(() => {
            var i, s;
            let a = [];
            for (let t of e)
                null !== t &&
                    (t instanceof HTMLElement
                        ? a.push(t)
                        : "current" in t &&
                          t.current instanceof HTMLElement &&
                          a.push(t.current));
            if (null != t && t.current) for (let e of t.current) a.push(e);
            for (let e of null !=
            (i = null == r ? void 0 : r.querySelectorAll("html > *, body > *"))
                ? i
                : [])
                e !== document.body &&
                    e !== document.head &&
                    e instanceof HTMLElement &&
                    "headlessui-portal-root" !== e.id &&
                    ((n &&
                        (e.contains(n) ||
                            e.contains(
                                null ==
                                    (s = null == n ? void 0 : n.getRootNode())
                                    ? void 0
                                    : s.host
                            ))) ||
                        a.some((t) => e.contains(t)) ||
                        a.push(e));
            return a;
        });
    return {
        resolveContainers: i,
        contains: o$2((e) => i().some((t) => t.contains(e))),
    };
}
let a$1 = reactExports.createContext(null);
function O$1({ children: e, node: t }) {
    let [n, r] = reactExports.useState(null),
        i = b$2(null != t ? t : n);
    return React$1.createElement(
        a$1.Provider,
        { value: i },
        e,
        null === i &&
            React$1.createElement(f$8, {
                features: s$3.Hidden,
                ref: (e) => {
                    var t, n;
                    if (e)
                        for (let i of null !=
                        (n =
                            null == (t = u$6(e))
                                ? void 0
                                : t.querySelectorAll("html > *, body > *"))
                            ? n
                            : [])
                            if (
                                i !== document.body &&
                                i !== document.head &&
                                i instanceof HTMLElement &&
                                null != i &&
                                i.contains(e)
                            ) {
                                r(i);
                                break;
                            }
                },
            })
    );
}
function b$2(e = null) {
    var t;
    return null != (t = reactExports.useContext(a$1)) ? t : e;
}
function f$2() {
    let e = reactExports.useRef(!1);
    return (
        n$5(
            () => (
                (e.current = !0),
                () => {
                    e.current = !1;
                }
            ),
            []
        ),
        e
    );
}
var a = ((e) => (
    (e[(e.Forwards = 0)] = "Forwards"), (e[(e.Backwards = 1)] = "Backwards"), e
))(a || {});
function u$1() {
    let e = reactExports.useRef(0);
    return (
        s$2(
            !0,
            "keydown",
            (t) => {
                "Tab" === t.key && (e.current = t.shiftKey ? 1 : 0);
            },
            !0
        ),
        e
    );
}
function U$1(e) {
    if (!e) return new Set();
    if ("function" == typeof e) return new Set(e());
    let t = new Set();
    for (let n of e.current)
        n.current instanceof HTMLElement && t.add(n.current);
    return t;
}
let Z = "div";
var x$1 = ((e) => (
    (e[(e.None = 0)] = "None"),
    (e[(e.InitialFocus = 1)] = "InitialFocus"),
    (e[(e.TabLock = 2)] = "TabLock"),
    (e[(e.FocusLock = 4)] = "FocusLock"),
    (e[(e.RestoreFocus = 8)] = "RestoreFocus"),
    (e[(e.AutoFocus = 16)] = "AutoFocus"),
    e
))(x$1 || {});
function $(e, t) {
    let n = reactExports.useRef(null),
        r = y$4(n, t),
        {
            initialFocus: i,
            initialFocusFallback: s,
            containers: o,
            features: l = 15,
            ...c
        } = e;
    l$3() || (l = 0);
    let u = n$3(n);
    ee(l, { ownerDocument: u });
    let d = te(l, {
        ownerDocument: u,
        container: n,
        initialFocus: i,
        initialFocusFallback: s,
    });
    re(l, {
        ownerDocument: u,
        container: n,
        containers: o,
        previousActiveElement: d,
    });
    let p = u$1(),
        h = o$2((e) => {
            let t = n.current;
            t &&
                u$5(p.current, {
                    [a.Forwards]: () => {
                        P(t, F.First, { skipElements: [e.relatedTarget, s] });
                    },
                    [a.Backwards]: () => {
                        P(t, F.Last, { skipElements: [e.relatedTarget, s] });
                    },
                });
        }),
        f = x$3(!!(2 & l), "focus-trap#tab-lock"),
        m = p$4(),
        g = reactExports.useRef(!1),
        x = {
            ref: r,
            onKeyDown(e) {
                "Tab" == e.key &&
                    ((g.current = !0),
                    m.requestAnimationFrame(() => {
                        g.current = !1;
                    }));
            },
            onBlur(e) {
                if (!(4 & l)) return;
                let t = U$1(o);
                n.current instanceof HTMLElement && t.add(n.current);
                let r = e.relatedTarget;
                r instanceof HTMLElement &&
                    "true" !== r.dataset.headlessuiFocusGuard &&
                    (I(t, r) ||
                        (g.current
                            ? P(
                                  n.current,
                                  u$5(p.current, {
                                      [a.Forwards]: () => F.Next,
                                      [a.Backwards]: () => F.Previous,
                                  }) | F.WrapAround,
                                  { relativeTo: e.target }
                              )
                            : e.target instanceof HTMLElement &&
                              I$2(e.target)));
            },
        },
        v = L$1();
    return React$1.createElement(
        React$1.Fragment,
        null,
        f &&
            React$1.createElement(f$8, {
                as: "button",
                type: "button",
                "data-headlessui-focus-guard": !0,
                onFocus: h,
                features: s$3.Focusable,
            }),
        v({ ourProps: x, theirProps: c, defaultTag: Z, name: "FocusTrap" }),
        f &&
            React$1.createElement(f$8, {
                as: "button",
                type: "button",
                "data-headlessui-focus-guard": !0,
                onFocus: h,
                features: s$3.Focusable,
            })
    );
}
let D = K($),
    ye = Object.assign(D, { features: x$1 });
function w$2(e = !0) {
    let t = reactExports.useRef(r$1.slice());
    return (
        m$2(
            ([e], [n]) => {
                !0 === n &&
                    !1 === e &&
                    t$5(() => {
                        t.current.splice(0);
                    }),
                    !1 === n && !0 === e && (t.current = r$1.slice());
            },
            [e, r$1, t]
        ),
        o$2(() => {
            var e;
            return null !=
                (e = t.current.find((e) => null != e && e.isConnected))
                ? e
                : null;
        })
    );
}
function ee(e, { ownerDocument: t }) {
    let n = !!(8 & e),
        r = w$2(n);
    m$2(() => {
        n ||
            ((null == t ? void 0 : t.activeElement) ===
                (null == t ? void 0 : t.body) &&
                I$2(r()));
    }, [n]),
        c$2(() => {
            n && I$2(r());
        });
}
function te(
    e,
    { ownerDocument: t, container: n, initialFocus: r, initialFocusFallback: i }
) {
    let s = reactExports.useRef(null),
        a = x$3(!!(1 & e), "focus-trap#initial-focus"),
        o = f$2();
    return (
        m$2(() => {
            if (0 === e) return;
            if (!a) return void (null != i && i.current && I$2(i.current));
            let l = n.current;
            l &&
                t$5(() => {
                    if (!o.current) return;
                    let n = null == t ? void 0 : t.activeElement;
                    if (null != r && r.current) {
                        if ((null == r ? void 0 : r.current) === n)
                            return void (s.current = n);
                    } else if (l.contains(n)) return void (s.current = n);
                    if (null != r && r.current) I$2(r.current);
                    else {
                        if (16 & e) {
                            if (P(l, F.First | F.AutoFocus) !== T$1.Error)
                                return;
                        } else if (P(l, F.First) !== T$1.Error) return;
                        if (
                            null != i &&
                            i.current &&
                            (I$2(i.current),
                            (null == t ? void 0 : t.activeElement) ===
                                i.current)
                        )
                            return;
                        console.warn(
                            "There are no focusable elements inside the <FocusTrap />"
                        );
                    }
                    s.current = null == t ? void 0 : t.activeElement;
                });
        }, [i, a, e]),
        s
    );
}
function re(
    e,
    { ownerDocument: t, container: n, containers: r, previousActiveElement: i }
) {
    let s = f$2(),
        a = !!(4 & e);
    E(
        null == t ? void 0 : t.defaultView,
        "focus",
        (e) => {
            if (!a || !s.current) return;
            let t = U$1(r);
            n.current instanceof HTMLElement && t.add(n.current);
            let o = i.current;
            if (!o) return;
            let l = e.target;
            l && l instanceof HTMLElement
                ? I(t, l)
                    ? ((i.current = l), I$2(l))
                    : (e.preventDefault(), e.stopPropagation(), I$2(o))
                : I$2(i.current);
        },
        !0
    );
}
function I(e, t) {
    for (let n of e) if (n.contains(t)) return !0;
    return !1;
}
function ue(e) {
    var t;
    return (
        !!(
            e.enter ||
            e.enterFrom ||
            e.enterTo ||
            e.leave ||
            e.leaveFrom ||
            e.leaveTo
        ) ||
        (null != (t = e.as) ? t : de) !== reactExports.Fragment ||
        1 === React$1.Children.count(e.children)
    );
}
let w$1 = reactExports.createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((e) => ((e.Visible = "visible"), (e.Hidden = "hidden"), e))(_e || {});
function De() {
    let e = reactExports.useContext(w$1);
    if (null === e)
        throw new Error(
            "A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."
        );
    return e;
}
function He$1() {
    let e = reactExports.useContext(M);
    if (null === e)
        throw new Error(
            "A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />."
        );
    return e;
}
let M = reactExports.createContext(null);
function U(e) {
    return "children" in e
        ? U(e.children)
        : e.current
              .filter(({ el: e }) => null !== e.current)
              .filter(({ state: e }) => "visible" === e).length > 0;
}
function Te(e, t) {
    let n = s$4(e),
        r = reactExports.useRef([]),
        i = f$2(),
        s = p$4(),
        a = o$2((e, t = A$2.Hidden) => {
            let a = r.current.findIndex(({ el: t }) => t === e);
            -1 !== a &&
                (u$5(t, {
                    [A$2.Unmount]() {
                        r.current.splice(a, 1);
                    },
                    [A$2.Hidden]() {
                        r.current[a].state = "hidden";
                    },
                }),
                s.microTask(() => {
                    var e;
                    !U(r) &&
                        i.current &&
                        (null == (e = n.current) || e.call(n));
                }));
        }),
        o = o$2((e) => {
            let t = r.current.find(({ el: t }) => t === e);
            return (
                t
                    ? "visible" !== t.state && (t.state = "visible")
                    : r.current.push({ el: e, state: "visible" }),
                () => a(e, A$2.Unmount)
            );
        }),
        l = reactExports.useRef([]),
        c = reactExports.useRef(Promise.resolve()),
        u = reactExports.useRef({ enter: [], leave: [] }),
        d = o$2((e, n, r) => {
            l.current.splice(0),
                t &&
                    (t.chains.current[n] = t.chains.current[n].filter(
                        ([t]) => t !== e
                    )),
                null == t ||
                    t.chains.current[n].push([
                        e,
                        new Promise((e) => {
                            l.current.push(e);
                        }),
                    ]),
                null == t ||
                    t.chains.current[n].push([
                        e,
                        new Promise((e) => {
                            Promise.all(u.current[n].map(([e, t]) => t)).then(
                                () => e()
                            );
                        }),
                    ]),
                "enter" === n
                    ? (c.current = c.current
                          .then(() => (null == t ? void 0 : t.wait.current))
                          .then(() => r(n)))
                    : r(n);
        }),
        p = o$2((e, t, n) => {
            Promise.all(u.current[t].splice(0).map(([e, t]) => t))
                .then(() => {
                    var e;
                    null == (e = l.current.shift()) || e();
                })
                .then(() => n(t));
        });
    return reactExports.useMemo(
        () => ({
            children: r,
            register: o,
            unregister: a,
            onStart: d,
            onStop: p,
            wait: c,
            chains: u,
        }),
        [o, a, r, d, p, u, c]
    );
}
M.displayName = "NestingContext";
let de = reactExports.Fragment,
    fe = O$3.RenderStrategy;
function Ae(e, t) {
    var n, r;
    let {
            transition: s = !0,
            beforeEnter: a,
            afterEnter: o,
            beforeLeave: l,
            afterLeave: c,
            enter: u,
            enterFrom: d,
            enterTo: p,
            entered: h,
            leave: f,
            leaveFrom: m,
            leaveTo: g,
            ...x
        } = e,
        [v, b] = reactExports.useState(null),
        y = reactExports.useRef(null),
        _ = ue(e),
        E = y$4(...(_ ? [y, t, b] : null === t ? [] : [t])),
        S = null == (n = x.unmount) || n ? A$2.Unmount : A$2.Hidden,
        { show: w, appear: A, initial: R } = De(),
        [C, j] = reactExports.useState(w ? "visible" : "hidden"),
        k = He$1(),
        { register: P, unregister: T } = k;
    n$5(() => P(y), [P, y]),
        n$5(() => {
            if (S === A$2.Hidden && y.current)
                return w && "visible" !== C
                    ? void j("visible")
                    : u$5(C, { hidden: () => T(y), visible: () => P(y) });
        }, [C, y, P, T, w, S]);
    let $ = l$3();
    n$5(() => {
        if (_ && $ && "visible" === C && null === y.current)
            throw new Error(
                "Did you forget to passthrough the `ref` to the actual DOM node?"
            );
    }, [y, C, $, _]);
    let O = R && !A,
        I = A && w && R,
        D = reactExports.useRef(!1),
        N = Te(() => {
            D.current || (j("hidden"), T(y));
        }, k),
        F = o$2((e) => {
            D.current = !0;
            let t = e ? "enter" : "leave";
            N.onStart(y, t, (e) => {
                "enter" === e
                    ? null == a || a()
                    : "leave" === e && (null == l || l());
            });
        }),
        L = o$2((e) => {
            let t = e ? "enter" : "leave";
            (D.current = !1),
                N.onStop(y, t, (e) => {
                    "enter" === e
                        ? null == o || o()
                        : "leave" === e && (null == c || c());
                }),
                "leave" === t && !U(N) && (j("hidden"), T(y));
        });
    reactExports.useEffect(() => {
        (_ && s) || (F(w), L(w));
    }, [w, _, s]);
    let B = (() => !(!s || !_ || !$ || O))(),
        [, z] = x$2(B, v, w, { start: F, end: L }),
        W = m$6({
            ref: E,
            className:
                (null ==
                (r = t$4(
                    x.className,
                    I && u,
                    I && d,
                    z.enter && u,
                    z.enter && z.closed && d,
                    z.enter && !z.closed && p,
                    z.leave && f,
                    z.leave && !z.closed && m,
                    z.leave && z.closed && g,
                    !z.transition && w && h
                ))
                    ? void 0
                    : r.trim()) || void 0,
            ...R$1(z),
        }),
        G = 0;
    "visible" === C && (G |= i.Open),
        "hidden" === C && (G |= i.Closed),
        z.enter && (G |= i.Opening),
        z.leave && (G |= i.Closing);
    let V = L$1();
    return React$1.createElement(
        M.Provider,
        { value: N },
        React$1.createElement(
            c$3,
            { value: G },
            V({
                ourProps: W,
                theirProps: x,
                defaultTag: de,
                features: fe,
                visible: "visible" === C,
                name: "Transition.Child",
            })
        )
    );
}
function Ie$1(e, t) {
    let { show: n, appear: r = !1, unmount: s = !0, ...a } = e,
        o = reactExports.useRef(null),
        l = y$4(...(ue(e) ? [o, t] : null === t ? [] : [t]));
    l$3();
    let c = u$2();
    if (
        (void 0 === n && null !== c && (n = (c & i.Open) === i.Open),
        void 0 === n)
    )
        throw new Error(
            "A <Transition /> is used but it is missing a `show={true | false}` prop."
        );
    let [u, d] = reactExports.useState(n ? "visible" : "hidden"),
        p = Te(() => {
            n || d("hidden");
        }),
        [h, f] = reactExports.useState(!0),
        m = reactExports.useRef([n]);
    n$5(() => {
        !1 !== h &&
            m.current[m.current.length - 1] !== n &&
            (m.current.push(n), f(!1));
    }, [m, n]);
    let g = reactExports.useMemo(
        () => ({ show: n, appear: r, initial: h }),
        [n, r, h]
    );
    n$5(() => {
        n ? d("visible") : !U(p) && null !== o.current && d("hidden");
    }, [n, p]);
    let x = { unmount: s },
        v = o$2(() => {
            var t;
            h && f(!1), null == (t = e.beforeEnter) || t.call(e);
        }),
        b = o$2(() => {
            var t;
            h && f(!1), null == (t = e.beforeLeave) || t.call(e);
        }),
        y = L$1();
    return React$1.createElement(
        M.Provider,
        { value: p },
        React$1.createElement(
            w$1.Provider,
            { value: g },
            y({
                ourProps: {
                    ...x,
                    as: reactExports.Fragment,
                    children: React$1.createElement(me, {
                        ref: l,
                        ...x,
                        ...a,
                        beforeEnter: v,
                        beforeLeave: b,
                    }),
                },
                theirProps: {},
                defaultTag: reactExports.Fragment,
                features: fe,
                visible: "visible" === u,
                name: "Transition",
            })
        )
    );
}
function Le(e, t) {
    let n = null !== reactExports.useContext(w$1),
        r = null !== u$2();
    return React$1.createElement(
        React$1.Fragment,
        null,
        !n && r
            ? React$1.createElement(X, { ref: t, ...e })
            : React$1.createElement(me, { ref: t, ...e })
    );
}
let X = K(Ie$1),
    me = K(Ae),
    Fe = K(Le),
    ze = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((e) => (
        (e[(e.Open = 0)] = "Open"), (e[(e.Closed = 1)] = "Closed"), e
    ))(Oe || {}),
    he = ((e) => ((e[(e.SetTitleId = 0)] = "SetTitleId"), e))(he || {});
let Se = { 0: (e, t) => (e.titleId === t.id ? e : { ...e, titleId: t.id }) },
    k$2 = reactExports.createContext(null);
function O(e) {
    let t = reactExports.useContext(k$2);
    if (null === t) {
        let t = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
        throw (Error.captureStackTrace && Error.captureStackTrace(t, O), t);
    }
    return t;
}
function Ie(e, t) {
    return u$5(t.type, Se, e, t);
}
k$2.displayName = "DialogContext";
let V = K(function (e, t) {
        let n = reactExports.useId(),
            {
                id: r = `headlessui-dialog-${n}`,
                open: s,
                onClose: a,
                initialFocus: o,
                role: l = "dialog",
                autoFocus: c = !0,
                __demoMode: u = !1,
                unmount: d = !1,
                ...p
            } = e,
            h = reactExports.useRef(!1);
        l =
            "dialog" === l || "alertdialog" === l
                ? l
                : (h.current ||
                      ((h.current = !0),
                      console.warn(
                          `Invalid role [${l}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`
                      )),
                  "dialog");
        let f = u$2();
        void 0 === s && null !== f && (s = (f & i.Open) === i.Open);
        let m = reactExports.useRef(null),
            g = y$4(m, t),
            x = n$3(m),
            v = s ? 0 : 1,
            [b, y] = reactExports.useReducer(Ie, {
                titleId: null,
                descriptionId: null,
                panelRef: reactExports.createRef(),
            }),
            _ = o$2(() => a(!1)),
            E = o$2((e) => y({ type: 0, id: e })),
            S = !!l$3() && 0 === v,
            [w, A] = te$1(),
            C = {
                get current() {
                    var e;
                    return null != (e = b.panelRef.current) ? e : m.current;
                },
            },
            j = b$2(),
            { resolveContainers: k } = R({
                mainTreeNode: j,
                portals: w,
                defaultContainers: [C],
            }),
            P = null !== f && (f & i.Closing) === i.Closing;
        y$3(!u && !P && S, {
            allowed: o$2(() => {
                var e, t;
                return [
                    null !=
                    (t =
                        null == (e = m.current)
                            ? void 0
                            : e.closest("[data-headlessui-portal]"))
                        ? t
                        : null,
                ];
            }),
            disallowed: o$2(() => {
                var e;
                return [
                    null !=
                    (e =
                        null == j
                            ? void 0
                            : j.closest(
                                  "body > *:not(#headlessui-portal-root)"
                              ))
                        ? e
                        : null,
                ];
            }),
        }),
            R$2(S, k, (e) => {
                e.preventDefault(), _();
            }),
            a$2(S, null == x ? void 0 : x.defaultView, (e) => {
                e.preventDefault(),
                    e.stopPropagation(),
                    document.activeElement &&
                        "blur" in document.activeElement &&
                        "function" == typeof document.activeElement.blur &&
                        document.activeElement.blur(),
                    _();
            }),
            f$4(!u && !P && S, x, k),
            m$4(S, m, _);
        let [T, M] = w$4(),
            $ = reactExports.useMemo(
                () => [
                    { dialogState: v, close: _, setTitleId: E, unmount: d },
                    b,
                ],
                [v, b, _, E, d]
            ),
            O = reactExports.useMemo(() => ({ open: 0 === v }), [v]),
            I = {
                ref: g,
                id: r,
                role: l,
                tabIndex: -1,
                "aria-modal": u ? void 0 : 0 === v || void 0,
                "aria-labelledby": b.titleId,
                "aria-describedby": T,
                unmount: d,
            },
            D = !f$3(),
            N = x$1.None;
        S &&
            !u &&
            ((N |= x$1.RestoreFocus),
            (N |= x$1.TabLock),
            c && (N |= x$1.AutoFocus),
            D && (N |= x$1.InitialFocus));
        let F = L$1();
        return React$1.createElement(
            s$1,
            null,
            React$1.createElement(
                l$2,
                { force: !0 },
                React$1.createElement(
                    re$1,
                    null,
                    React$1.createElement(
                        k$2.Provider,
                        { value: $ },
                        React$1.createElement(
                            X$1,
                            { target: m },
                            React$1.createElement(
                                l$2,
                                { force: !1 },
                                React$1.createElement(
                                    M,
                                    { slot: O },
                                    React$1.createElement(
                                        A,
                                        null,
                                        React$1.createElement(
                                            ye,
                                            {
                                                initialFocus: o,
                                                initialFocusFallback: m,
                                                containers: k,
                                                features: N,
                                            },
                                            React$1.createElement(
                                                C$1,
                                                { value: _ },
                                                F({
                                                    ourProps: I,
                                                    theirProps: p,
                                                    slot: O,
                                                    defaultTag: Me,
                                                    features: Ge,
                                                    visible: 0 === v,
                                                    name: "Dialog",
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            )
        );
    }),
    Me = "div",
    Ge = O$3.RenderStrategy | O$3.Static;
function ke(e, t)                                 jsxRuntimeExports.jsx("span", {
                                        children: "Dashboard",
                                    }),
                                ],
                            }),
                            jsxRuntimeExports.jsxs(Link, {
                                to: "profile",
                                className:
                                    "flex items-center mb-2 py-2.5 px-4 gap-3 rounded transition duration-200 hover:bg-gray-700 mg-2 " +
                                    ("/dashboard/admin/me/profile" ===
                                    t.pathname
                                        ? "bg-gray-700"
                                        : ""),
                                children: [
                                    jsxRuntimeExports.jsx(IoPerson, {
                                        className: "w-5 h-5",
                                    }),
                                    jsxRuntimeExports.jsx("span", {
                                        children: "Profile",
                                    }),
                                ],
                            }),
                        ],
                    }),
                    jsxRuntimeExports.jsxs("div", {
                        className: "space-y-2 mb-6",
                        children: [
                            jsxRuntimeExports.jsx("h4", {
                                className:
                                    "text-gray-300 text-sm px-4 uppercase tracking-wide",
                                children: "Wallet",
                            }),
                            jsxRuntimeExports.jsxs(Link, {
                                to: "/dashboard/admin/me/transactions",
                                className:
                                    "flex items-center mb-2 py-2.5 px-4 gap-3 rounded transition duration-200 hover:bg-gray-700 " +
                                    ("/dashboard/admin/me/transactions" === n
                                        ? "bg-gray-700"
                                        : ""),
                                children: [
                                    jsxRuntimeExports.jsx(IoBook, {
                                        className: "w-5 h-5",
                                    }),
                                    jsxRuntimeExports.jsx("span", {
                                        children: "Transactions",
                                    }),
                                ],
                            }),
                        ],
                    }),
                ],
            }),
        });
    },
    Navbar$1 = ({ toggleSidebar: e, profile: t }) => {
        const [n, r] = reactExports.useState(!1),
            i = useNavigate(),
            [s, { isSuccess: a }] = useLogoutMutation();
        reactExports.useEffect(() => {
            a && (localStorage.removeItem("accessToken"), i("/"));
        }, [a, i]);
        return jsxRuntimeExports.jsx("nav", {
            className: "bg-deepNavyBlue text-white p-4 shadow-md",
            children: jsxRuntimeExports.jsxs("div", {
                className:
                    "container mx-auto flex justify-between items-center",
                children: [
                    jsxRuntimeExports.jsx("div", {
                        className: "flex items-center",
                        children: jsxRuntimeExports.jsx("button", {
                            onClick: e,
                            className: "mr-4 block md:hidden",
                            children: jsxRuntimeExports.jsx(IoMenu, {
                                className: "text-white w-5 h-5",
                            }),
                        }),
                    }),
                    jsxRuntimeExports.jsx("div", {
                        className: "relative flex items-center space-x-4",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "relative",
                            children: [
                                jsxRuntimeExports.jsxs("button", {
                                    className: "flex items-center space-x-2",
                                    onClick: () => {
                                        r(!n);
                                    },
                                    children: [
                                        jsxRuntimeExports.jsx("img", {
                                            className: "w-8 h-8 rounded-full",
                                            src: t.user.profilePicture,
                                            alt: "User Profile",
                                        }),
                                        jsxRuntimeExports.jsxs("p", {
                                            className: "flex gap-1",
                                            children: [
                                                jsxRuntimeExports.jsx("span", {
                                                    children: t.user.firstName,
                                                }),
                                                jsxRuntimeExports.jsx("span", {
                                                    children: t.user.lastName,
                                                }),
                                            ],
                                        }),
                                    ],
                                }),
                                n &&
                                    jsxRuntimeExports.jsxs("div", {
                                        className:
                                            "absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg py-2 z-20",
                                        children: [
                                            jsxRuntimeExports.jsxs(Link, {
                                                to: "profile",
                                                className:
                                                    "px-4 py-2 text-gray-800 hover:bg-gray-200 flex gap-2 border-b-2",
                                                children: [
                                                    jsxRuntimeExports.jsx(
                                                        IoPerson,
                                                        { className: "w-5 h-5" }
                                                    ),
                                                    "Profile",
                                                ],
                                            }),
                                            jsxRuntimeExports.jsxs(Link, {
                                                to: "profile",
                                                className:
                                                    "flex gap-2 px-4 py-2 text-gray-800 hover:bg-gray-200 border-b-2",
                                                children: [
                                                    jsxRuntimeExports.jsx(
                                                        IoSettings,
                                                        { className: "w-5 h-5" }
                                                    ),
                                                    "Settings",
                                                ],
                                            }),
                                            jsxRuntimeExports.jsxs("button", {
                                                className:
                                                    "flex gap-2 w-full text-left px-4 py-2 text-gray-800 hover:bg-gray-200",
                                                onClick: () => s(null),
                                                children: [
                                                    jsxRuntimeExports.jsx(
                                                        IoLogOut,
                                                        { className: "w-5 h-5" }
                                                    ),
                                                    "Logout",
                                                ],
                                            }),
                                        ],
                                    }),
                            ],
                        }),
                    }),
                ],
            }),
        });
    },
    userApiSlice = baseApi.injectEndpoints({
        endpoints: (e) => ({
            fetchUserProfile: e.query({
                query: () => ({ url: "/profile/get-profile", method: "GET" }),
            }),
            fetchUserAccount: e.query({
                query: () => ({ url: "/profile/get-account", method: "GET" }),
            }),
            fetchTransactions: e.query({
                query: () => ({ url: "/transact/transactions", method: "GET" }),
            }),
            fetchATransactions: e.query({
                query: (e) => ({
                    url: `/transact/transactions/${e}`,
                    method: "GET",
                }),
            }),
            deposit: e.mutation({
                query: (e) => ({
                    url: "/transact/deposit",
                    method: "POST",
                    body: e,
                }),
            }),
            transfer: e.mutation({
                query: (e) => ({
                    url: "/transact/transfer",
                    method: "POST",
                    body: e,
                }),
            }),
            withdraw: e.mutation({
                query: (e) => ({
                    url: "/transact/withdraw",
                    method: "POST",
                    body: { ...e },
                }),
            }),
            getRecpientAccount: e.query({
                query: (e) => ({
                    url: `/transact/get-account?accountNumber=${e}`,
                    method: "GET",
                }),
            }),
            updateProfileInformation: e.mutation({
                query: (e) => ({
                    url: "profile/update-profile-information",
                    method: "POST",
                    body: e,
                }),
            }),
            updateContactInformation: e.mutation({
                query: (e) => ({
                    url: "profile/update-contact-information",
                    method: "POST",
                    body: e,
                }),
            }),
            uploadProfileImage: e.mutation({
                query: (e) => ({
                    url: "profile/upload-profile-picture",
                    method: "POST",
                    body: e,
                }),
            }),
            deleteAccount: e.mutation({
                query: () => ({
                    url: "profile/delete-account",
                    method: "POST",
                }),
            }),
            pauseAccount: e.mutation({
                query: () => ({ url: "profile/pause-account", method: "POST" }),
            }),
            resumeAccount: e.mutation({
                query: () => ({
                    url: "profile/resume-account",
                    method: "POST",
                }),
            }),
            changePassword: e.mutation({
                query: (e) => ({
                    url: "profile/change-password",
                    method: "POST",
                    body: e,
                }),
            }),
        }),
    }),
    {
        useFetchUserProfileQuery: useFetchUserProfileQuery,
        useFetchUserAccountQuery: useFetchUserAccountQuery,
        useFetchTransactionsQuery: useFetchTransactionsQuery,
        useDepositMutation: useDepositMutation,
        useTransferMutation: useTransferMutation,
        useWithdrawMutation: useWithdrawMutation,
        useGetRecpientAccountQuery: useGetRecpientAccountQuery,
        useUpdateProfileInformationMutation:
            useUpdateProfileInformationMutation,
        useUpdateContactInformationMutation:
            useUpdateContactInformationMutation,
        useDeleteAccountMutation: useDeleteAccountMutation,
        usePauseAccountMutation: usePauseAccountMutation,
        useResumeAccountMutation: useResumeAccountMutation,
        useUploadProfileImageMutation: useUploadProfileImageMutation,
        useChangePasswordMutation: useChangePasswordMutation,
        useFetchATransactionsQuery: useFetchATransactionsQuery$1,
    } = userApiSlice,
    AdminDashboardLayout = () => {
        const [e, t] = reactExports.useState(!1),
            {
                data: n,
                isLoading: r,
                isError: i,
                error: s,
            } = useFetchUserProfileQuery("userProfile");
        if (r) return jsxRuntimeExports.jsx("p", { children: "Loading..." });
        if (i)
            return jsxRuntimeExports.jsx("p", {
                children: "An error occurred...",
            });
        return jsxRuntimeExports.jsxs("div", {
            className: "flex h-screen bg-gray-200",
            children: [
                jsxRuntimeExports.jsx(Sidebar$1, { isOpen: e }),
                jsxRuntimeExports.jsxs("div", {
                    className: "flex-1 flex flex-col overflow-hidden",
                    children: [
                        jsxRuntimeExports.jsx(Navbar$1, {
                            toggleSidebar: () => {
                                t(!e);
                            },
                            profile: n,
                        }),
                        jsxRuntimeExports.jsx("main", {
                            className: "flex-1 overflow-auto p-6",
                            children: jsxRuntimeExports.jsx(Outlet, {}),
                        }),
                    ],
                }),
            ],
        });
    },
    adminApiSlice = baseApi.injectEndpoints({
        endpoints: (e) => ({
            fetchAllUsers: e.query({
                query: () => ({ url: "/admin/users", method: "GET" }),
            }),
            fetchAUser: e.query({
                query: (e) => ({ url: `/admin/users/${e}`, method: "GET" }),
            }),
            fetchAllTransactions: e.query({
                query: () => ({ url: "/admin/transactions", method: "GET" }),
            }),
            fetchATransactions: e.query({
                query: (e) => ({
                    url: `/admin/transactions/${e}`,
                    method: "GET",
                }),
            }),
            suspendUserAccount: e.mutation({
                query: (e) => ({
                    url: `/admin/users/suspend-user/${e}`,
                    method: "PUT",
                }),
            }),
            activateUserAccount: e.mutation({
                query: (e) => ({
                    url: `/admin/users/activate-user/${e}`,
                    method: "PUT",
                }),
            }),
            deleteUserAccount: e.mutation({
                query: (e) => ({
                    url: `/admin/users/delete-user/${e}`,
                    method: "PUT",
                }),
            }),
            confirmDeposit: e.mutation({
                query: (e) => ({
                    url: `/admin/transactions/confirm-deposit/${e}`,
                    method: "PUT",
                }),
            }),
            confirmWithdraw: e.mutation({
                query: (e) => ({
                    url: `/admin/transactions/confirm-withdrawal/${e}`,
                    method: "PUT",
                }),
            }),
        }),
    }),
    {
        useFetchAllUsersQuery: useFetchAllUsersQuery,
        useFetchAUserQuery: useFetchAUserQuery,
        useFetchAllTransactionsQuery: useFetchAllTransactionsQuery,
        useActivateUserAccountMutation: useActivateUserAccountMutation,
        useSuspendUserAccountMutation: useSuspendUserAccountMutation,
        useDeleteUserAccountMutation: useDeleteUserAccountMutation,
        useConfirmDepositMutation: useConfirmDepositMutation,
        useConfirmWithdrawMutation: useConfirmWithdrawMutation,
        useFetchATransactionsQuery: useFetchATransactionsQuery,
    } = adminApiSlice;
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function round$3(e) {
    return (e + 0.5) | 0;
}
const lim = (e, t, n) => Math.max(Math.min(e, n), t);
function p2b(e) {
    return lim(round$3(2.55 * e), 0, 255);
}
function n2b(e) {
    return lim(round$3(255 * e), 0, 255);
}
function b2n(e) {
    return lim(round$3(e / 2.55) / 100, 0, 1);
}
function n2p(e) {
    return lim(round$3(100 * e), 0, 100);
}
const map$1 = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15,
    },
    hex = [..."0123456789ABCDEF"],
    h1 = (e) => hex[15 & e],
    h2 = (e) => hex[(240 & e) >> 4] + hex[15 & e],
    eq = (e) => (240 & e) >> 4 == (15 & e),
    isShort = (e) => eq(e.r) && eq(e.g) && eq(e.b) && eq(e.a);
function hexParse(e) {
    var t,
        n = e.length;
    return (
        "#" === e[0] &&
            (4 === n || 5 === n
                ? (t = {
                      r: 255 & (17 * map$1[e[1]]),
                      g: 255 & (17 * map$1[e[2]]),
                      b: 255 & (17 * map$1[e[3]]),
                      a: 5 === n ? 17 * map$1[e[4]] : 255,
                  })
                : (7 !== n && 9 !== n) ||
                  (t = {
                      r: (map$1[e[1]] << 4) | map$1[e[2]],
                      g: (map$1[e[3]] << 4) | map$1[e[4]],
                      b: (map$1[e[5]] << 4) | map$1[e[6]],
                      a: 9 === n ? (map$1[e[7]] << 4) | map$1[e[8]] : 255,
                  })),
        t
    );
}
const alpha$1 = (e, t) => (e < 255 ? t(e) : "");
function hexString(e) {
    var t = isShort(e) ? h1 : h2;
    return e ? "#" + t(e.r) + t(e.g) + t(e.b) + alpha$1(e.a, t) : void 0;
}
const HUE_RE =
    /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(e, t, n) {
    const r = t * Math.min(n, 1 - n),
        i = (t, i = (t + e / 30) % 12) =>
            n - r * Math.max(Math.min(i - 3, 9 - i, 1), -1);
    return [i(0), i(8), i(4)];
}
function hsv2rgbn(e, t, n) {
    const r = (r, i = (r + e / 60) % 6) =>
        n - n * t * Math.max(Math.min(i, 4 - i, 1), 0);
    return [r(5), r(3), r(1)];
}
function hwb2rgbn(e, t, n) {
    const r = hsl2rgbn(e, 1, 0.5);
    let i;
    for (
        t + n > 1 && ((i = 1 / (t + n)), (t *= i), (n *= i)), i = 0;
        i < 3;
        i++
    )
        (r[i] *= 1 - t - n), (r[i] += t);
    return r;
}
function hueValue(e, t, n, r, i) {
    return e === i
        ? (t - n) / r + (t < n ? 6 : 0)
        : t === i
        ? (n - e) / r + 2
        : (e - t) / r + 4;
}
function rgb2hsl(e) {
    const t = e.r / 255,
        n = e.g / 255,
        r = e.b / 255,
        i = Math.max(t, n, r),
        s = Math.min(t, n, r),
        a = (i + s) / 2;
    let o, l, c;
    return (
        i !== s &&
            ((c = i - s),
            (l = a > 0.5 ? c / (2 - i - s) : c / (i + s)),
            (o = hueValue(t, n, r, c, i)),
            (o = 60 * o + 0.5)),
        [0 | o, l || 0, a]
    );
}
function calln(e, t, n, r) {
    return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, r)).map(n2b);
}
function hsl2rgb(e, t, n) {
    return calln(hsl2rgbn, e, t, n);
}
function hwb2rgb(e, t, n) {
    return calln(hwb2rgbn, e, t, n);
}
function hsv2rgb(e, t, n) {
    return calln(hsv2rgbn, e, t, n);
}
function hue(e) {
    return ((e % 360) + 360) % 360;
}
function hueParse(e) {
    const t = HUE_RE.exec(e);
    let n,
        r = 255;
    if (!t) return;
    t[5] !== n && (r = t[6] ? p2b(+t[5]) : n2b(+t[5]));
    const i = hue(+t[2]),
        s = +t[3] / 100,
        a = +t[4] / 100;
    return (
        (n =
            "hwb" === t[1]
                ? hwb2rgb(i, s, a)
                : "hsv" === t[1]
                ? hsv2rgb(i, s, a)
                : hsl2rgb(i, s, a)),
        { r: n[0], g: n[1], b: n[2], a: r }
    );
}
function rotate(e, t) {
    var n = rgb2hsl(e);
    (n[0] = hue(n[0] + t)),
        (n = hsl2rgb(n)),
        (e.r = n[0]),
        (e.g = n[1]),
        (e.b = n[2]);
}
function hslString(e) {
    if (!e) return;
    const t = rgb2hsl(e),
        n = t[0],
        r = n2p(t[1]),
        i = n2p(t[2]);
    return e.a < 255
        ? `hsla(${n}, ${r}%, ${i}%, ${b2n(e.a)})`
        : `hsl(${n}, ${r}%, ${i}%)`;
}
const map$2 = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh",
    },
    names$1 = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32",
    };
function unpack() {
    const e = {},
        t = Object.keys(names$1),
        n = Object.keys(map$2);
    let r, i, s, a, o;
    for (r = 0; r < t.length; r++) {
        for (a = o = t[r], i = 0; i < n.length; i++)
            (s = n[i]), (o = o.replace(s, map$2[s]));
        (s = parseInt(names$1[a], 16)),
            (e[o] = [(s >> 16) & 255, (s >> 8) & 255, 255 & s]);
    }
    return e;
}
let names;
function nameParse(e) {
    names || ((names = unpack()), (names.transparent = [0, 0, 0, 0]));
    const t = names[e.toLowerCase()];
    return t && { r: t[0], g: t[1], b: t[2], a: 4 === t.length ? t[3] : 255 };
}
const RGB_RE =
    /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(e) {
    const t = RGB_RE.exec(e);
    let n,
        r,
        i,
        s = 255;
    if (t) {
        if (t[7] !== n) {
            const e = +t[7];
            s = t[8] ? p2b(e) : lim(255 * e, 0, 255);
        }
        return (
            (n = +t[1]),
            (r = +t[3]),
            (i = +t[5]),
            (n = 255 & (t[2] ? p2b(n) : lim(n, 0, 255))),
            (r = 255 & (t[4] ? p2b(r) : lim(r, 0, 255))),
            (i = 255 & (t[6] ? p2b(i) : lim(i, 0, 255))),
            { r: n, g: r, b: i, a: s }
        );
    }
}
function rgbString(e) {
    return (
        e &&
        (e.a < 255
            ? `rgba(${e.r}, ${e.g}, ${e.b}, ${b2n(e.a)})`
            : `rgb(${e.r}, ${e.g}, ${e.b})`)
    );
}
const to = (e) =>
        e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055,
    from$1 = (e) =>
        e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function interpolate$1(e, t, n) {
    const r = from$1(b2n(e.r)),
        i = from$1(b2n(e.g)),
        s = from$1(b2n(e.b));
    return {
        r: n2b(to(r + n * (from$1(b2n(t.r)) - r))),
        g: n2b(to(i + n * (from$1(b2n(t.g)) - i))),
        b: n2b(to(s + n * (from$1(b2n(t.b)) - s))),
        a: e.a + n * (t.a - e.a),
    };
}
function modHSL(e, t, n) {
    if (e) {
        let r = rgb2hsl(e);
        (r[t] = Math.max(0, Math.min(r[t] + r[t] * n, 0 === t ? 360 : 1))),
            (r = hsl2rgb(r)),
            (e.r = r[0]),
            (e.g = r[1]),
            (e.b = r[2]);
    }
}
function clone$1(e, t) {
    return e ? Object.assign(t || {}, e) : e;
}
function fromObject(e) {
    var t = { r: 0, g: 0, b: 0, a: 255 };
    return (
        Array.isArray(e)
            ? e.length >= 3 &&
              ((t = { r: e[0], g: e[1], b: e[2], a: 255 }),
              e.length > 3 && (t.a = n2b(e[3])))
            : ((t = clone$1(e, { r: 0, g: 0, b: 0, a: 1 })).a = n2b(t.a)),
        t
    );
}
function functionParse(e) {
    return "r" === e.charAt(0) ? rgbParse(e) : hueParse(e);
}
class Color {
    constructor(e) {
        if (e instanceof Color) return e;
        const t = typeof e;
        let n;
        "object" === t
            ? (n = fromObject(e))
            : "string" === t &&
              (n = hexParse(e) || nameParse(e) || functionParse(e)),
            (this._rgb = n),
            (this._valid = !!n);
    }
    get valid() {
        return this._valid;
    }
    get rgb() {
        var e = clone$1(this._rgb);
        return e && (e.a = b2n(e.a)), e;
    }
    set rgb(e) {
        this._rgb = fromObject(e);
    }
    rgbString() {
        return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
        return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
        return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(e, t) {
        if (e) {
            const n = this.rgb,
                r = e.rgb;
            let i;
            const s = t === i ? 0.5 : t,
                a = 2 * s - 1,
                o = n.a - r.a,
                l = ((a * o == -1 ? a : (a + o) / (1 + a * o)) + 1) / 2;
            (i = 1 - l),
                (n.r = 255 & (l * n.r + i * r.r + 0.5)),
                (n.g = 255 & (l * n.g + i * r.g + 0.5)),
                (n.b = 255 & (l * n.b + i * r.b + 0.5)),
                (n.a = s * n.a + (1 - s) * r.a),
                (this.rgb = n);
        }
        return this;
    }
    interpolate(e, t) {
        return e && (this._rgb = interpolate$1(this._rgb, e._rgb, t)), this;
    }
    clone() {
        return new Color(this.rgb);
    }
    alpha(e) {
        return (this._rgb.a = n2b(e)), this;
    }
    clearer(e) {
        return (this._rgb.a *= 1 - e), this;
    }
    greyscale() {
        const e = this._rgb,
            t = round$3(0.3 * e.r + 0.59 * e.g + 0.11 * e.b);
        return (e.r = e.g = e.b = t), this;
    }
    opaquer(e) {
        return (this._rgb.a *= 1 + e), this;
    }
    negate() {
        const e = this._rgb;
        return (e.r = 255 - e.r), (e.g = 255 - e.g), (e.b = 255 - e.b), this;
    }
    lighten(e) {
        return modHSL(this._rgb, 2, e), this;
    }
    darken(e) {
        return modHSL(this._rgb, 2, -e), this;
    }
    saturate(e) {
        return modHSL(this._rgb, 1, e), this;
    }
    desaturate(e) {
        return modHSL(this._rgb, 1, -e), this;
    }
    rotate(e) {
        return rotate(this._rgb, e), this;
    }
}
/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */ function noop$1() {}
const uid = (() => {
    let e = 0;
    return () => e++;
})();
function isNullOrUndef(e) {
    return null == e;
}
function isArray(e) {
    if (Array.isArray && Array.isArray(e)) return !0;
    const t = Object.prototype.toString.call(e);
    return "[object" === t.slice(0, 7) && "Array]" === t.slice(-6);
}
function isObject(e) {
    return (
        null !== e && "[object Object]" === Object.prototype.toString.call(e)
    );
}
function isNumberFinite(e) {
    return ("number" == typeof e || e instanceof Number) && isFinite(+e);
}
function finiteOrDefault(e, t) {
    return isNumberFinite(e) ? e : t;
}
function valueOrDefault(e, t) {
    return void 0 === e ? t : e;
}
const toPercentage = (e, t) =>
        "string" == typeof e && e.endsWith("%") ? parseFloat(e) / 100 : +e / t,
    toDimension = (e, t) =>
        "string" == typeof e && e.endsWith("%")
            ? (parseFloat(e) / 100) * t
            : +e;
function callback(e, t, n) {
    if (e && "function" == typeof e.call) return e.apply(n, t);
}
function each(e, t, n, r) {
    let i, s, a;
    if (isArray(e)) for (s = e.length, i = 0; i < s; i++) t.call(n, e[i], i);
    else if (isObject(e))
        for (a = Object.keys(e), s = a.length, i = 0; i < s; i++)
            t.call(n, e[a[i]], a[i]);
}
function _elementsEqual(e, t) {
    let n, r, i, s;
    if (!e || !t || e.length !== t.length) return !1;
    for (n = 0, r = e.length; n < r; ++n)
        if (
            ((i = e[n]),
            (s = t[n]),
            i.datasetIndex !== s.datasetIndex || i.index !== s.index)
        )
            return !1;
    return !0;
}
function clone(e) {
    if (isArray(e)) return e.map(clone);
    if (isObject(e)) {
        const t = Object.create(null),
            n = Object.keys(e),
            r = n.length;
        let i = 0;
        for (; i < r; ++i) t[n[i]] = clone(e[n[i]]);
        return t;
    }
    return e;
}
function isValidKey(e) {
    return -1 === ["__proto__", "prototype", "constructor"].indexOf(e);
}
function _merger(e, t, n, r) {
    if (!isValidKey(e)) return;
    const i = t[e],
        s = n[e];
    isObject(i) && isObject(s) ? merge$1(i, s, r) : (t[e] = clone(s));
}
function merge$1(e, t, n) {
    const r = isArray(t) ? t : [t],
        i = r.length;
    if (!isObject(e)) return e;
    const s = (n = n || {}).merger || _merger;
    let a;
    for (let o = 0; o < i; ++o) {
        if (((a = r[o]), !isObject(a))) continue;
        const t = Object.keys(a);
        for (let r = 0, i = t.length; r < i; ++r) s(t[r], e, a, n);
    }
    return e;
}
function mergeIf(e, t) {
    return merge$1(e, t, { merger: _mergerIf });
}
function _mergerIf(e, t, n) {
    if (!isValidKey(e)) return;
    const r = t[e],
        i = n[e];
    isObject(r) && isObject(i)
        ? mergeIf(r, i)
        : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = clone(i));
}
const keyResolvers = { "": (e) => e, x: (e) => e.x, y: (e) => e.y };
function _splitKey(e) {
    const t = e.split("."),
        n = [];
    let r = "";
    for (const i of t)
        (r += i),
            r.endsWith("\\")
                ? (r = r.slice(0, -1) + ".")
                : (n.push(r), (r = ""));
    return n;
}
function _getKeyResolver(e) {
    const t = _splitKey(e);
    return (e) => {
        for (const n of t) {
            if ("" === n) break;
            e = e && e[n];
        }
        return e;
    };
}
function resolveObjectKey(e, t) {
    return (keyResolvers[t] || (keyResolvers[t] = _getKeyResolver(t)))(e);
}
function _capitalize(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
}
const defined = (e) => void 0 !== e,
    isFunction = (e) => "function" == typeof e,
    setsEqual = (e, t) => {
        if (e.size !== t.size) return !1;
        for (const n of e) if (!t.has(n)) return !1;
        return !0;
    };
function _isClickEvent(e) {
    return (
        "mouseup" === e.type || "click" === e.type || "contextmenu" === e.type
    );
}
const PI = Math.PI,
    TAU = 2 * PI,
    PITAU = TAU + PI,
    INFINITY = Number.POSITIVE_INFINITY,
    RAD_PER_DEG = PI / 180,
    HALF_PI = PI / 2,
    QUARTER_PI = PI / 4,
    TWO_THIRDS_PI = (2 * PI) / 3,
    log10 = Math.log10,
    sign = Math.sign;
function almostEquals(e, t, n) {
    return Math.abs(e - t) < n;
}
function niceNum(e) {
    const t = Math.round(e);
    e = almostEquals(e, t, e / 1e3) ? t : e;
    const n = Math.pow(10, Math.floor(log10(e))),
        r = e / n;
    return (r <= 1 ? 1 : r <= 2 ? 2 : r <= 5 ? 5 : 10) * n;
}
function _factorize(e) {
    const t = [],
        n = Math.sqrt(e);
    let r;
    for (r = 1; r < n; r++) e % r == 0 && (t.push(r), t.push(e / r));
    return n === (0 | n) && t.push(n), t.sort((e, t) => e - t).pop(), t;
}
function isNumber(e) {
    return !isNaN(parseFloat(e)) && isFinite(e);
}
function almostWhole(e, t) {
    const n = Math.round(e);
    return n - t <= e && n + t >= e;
}
function _setMinAndMaxByKey(e, t, n) {
    let r, i, s;
    for (r = 0, i = e.length; r < i; r++)
        (s = e[r][n]),
            isNaN(s) ||
                ((t.min = Math.min(t.min, s)), (t.max = Math.max(t.max, s)));
}
function toRadians(e) {
    return e * (PI / 180);
}
function toDegrees(e) {
    return e * (180 / PI);
}
function _decimalPlaces(e) {
    if (!isNumberFinite(e)) return;
    let t = 1,
        n = 0;
    for (; Math.round(e * t) / t !== e; ) (t *= 10), n++;
    return n;
}
function getAngleFromPoint(e, t) {
    const n = t.x - e.x,
        r = t.y - e.y,
        i = Math.sqrt(n * n + r * r);
    let s = Math.atan2(r, n);
    return s < -0.5 * PI && (s += TAU), { angle: s, distance: i };
}
function distanceBetweenPoints(e, t) {
    return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function _angleDiff(e, t) {
    return ((e - t + PITAU) % TAU) - PI;
}
function _normalizeAngle(e) {
    return ((e % TAU) + TAU) % TAU;
}
function _angleBetween(e, t, n, r) {
    const i = _normalizeAngle(e),
        s = _normalizeAngle(t),
        a = _normalizeAngle(n),
        o = _normalizeAngle(s - i),
        l = _normalizeAngle(a - i),
        c = _normalizeAngle(i - s),
        u = _normalizeAngle(i - a);
    return i === s || i === a || (r && s === a) || (o > l && c < u);
}
function _limitValue(e, t, n) {
    return Math.max(t, Math.min(n, e));
}
function _int16Range(e) {
    return _limitValue(e, -32768, 32767);
}
function _isBetween(e, t, n, r = 1e-6) {
    return e >= Math.min(t, n) - r && e <= Math.max(t, n) + r;
}
function _lookup(e, t, n) {
    n = n || ((n) => e[n] < t);
    let r,
        i = e.length - 1,
        s = 0;
    for (; i - s > 1; ) (r = (s + i) >> 1), n(r) ? (s = r) : (i = r);
    return { lo: s, hi: i };
}
const _lookupByKey = (e, t, n, r) =>
        _lookup(
            e,
            n,
            r
                ? (r) => {
                      const i = e[r][t];
                      return i < n || (i === n && e[r + 1][t] === n);
                  }
                : (r) => e[r][t] < n
        ),
    _rlookupByKey = (e, t, n) => _lookup(e, n, (r) => e[r][t] >= n);
function _filterBetween(e, t, n) {
    let r = 0,
        i = e.length;
    for (; r < i && e[r] < t; ) r++;
    for (; i > r && e[i - 1] > n; ) i--;
    return r > 0 || i < e.length ? e.slice(r, i) : e;
}
const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
function listenArrayEvents(e, t) {
    e._chartjs
        ? e._chartjs.listeners.push(t)
        : (Object.defineProperty(e, "_chartjs", {
              configurable: !0,
              enumerable: !1,
              value: { listeners: [t] },
          }),
          arrayEvents.forEach((t) => {
              const n = "_onData" + _capitalize(t),
                  r = e[t];
              Object.defineProperty(e, t, {
                  configurable: !0,
                  enumerable: !1,
                  value(...t) {
                      const i = r.apply(this, t);
                      return (
                          e._chartjs.listeners.forEach((e) => {
                              "function" == typeof e[n] && e[n](...t);
                          }),
                          i
                      );
                  },
              });
          }));
}
function unlistenArrayEvents(e, t) {
    const n = e._chartjs;
    if (!n) return;
    const r = n.listeners,
        i = r.indexOf(t);
    -1 !== i && r.splice(i, 1),
        r.length > 0 ||
            (arrayEvents.forEach((t) => {
                delete e[t];
            }),
            delete e._chartjs);
}
function _arrayUnique(e) {
    const t = new Set(e);
    return t.size === e.length ? e : Array.from(t);
}
const requestAnimFrame =
    "undefined" == typeof window
        ? function (e) {
              return e();
          }
        : window.requestAnimationFrame;
function throttled(e, t) {
    let n = [],
        r = !1;
    return function (...i) {
        (n = i),
            r ||
                ((r = !0),
                requestAnimFrame.call(window, () => {
                    (r = !1), e.apply(t, n);
                }));
    };
}
function debounce$2(e, t) {
    let n;
    return function (...r) {
        return (
            t ? (clearTimeout(n), (n = setTimeout(e, t, r))) : e.apply(this, r),
            t
        );
    };
}
const _toLeftRightCenter = (e) =>
        "start" === e ? "left" : "end" === e ? "right" : "center",
    _alignStartEnd = (e, t, n) =>
        "start" === e ? t : "end" === e ? n : (t + n) / 2,
    _textX = (e, t, n, r) =>
        e === (r ? "left" : "right") ? n : "center" === e ? (t + n) / 2 : t;
function _getStartAndCountOfVisiblePoints(e, t, n) {
    const r = t.length;
    let i = 0,
        s = r;
    if (e._sorted) {
        const { iScale: a, _parsed: o } = e,
            l = a.axis,
            {
                min: c,
                max: u,
                minDefined: d,
                maxDefined: p,
            } = a.getUserBounds();
        d &&
            (i = _limitValue(
                Math.min(
                    _lookupByKey(o, l, c).lo,
                    n ? r : _lookupByKey(t, l, a.getPixelForValue(c)).lo
                ),
                0,
                r - 1
            )),
            (s = p
                ? _limitValue(
                      Math.max(
                          _lookupByKey(o, a.axis, u, !0).hi + 1,
                          n
                              ? 0
                              : _lookupByKey(t, l, a.getPixelForValue(u), !0)
                                    .hi + 1
                      ),
                      i,
                      r
                  ) - i
                : r - i);
    }
    return { start: i, count: s };
}
function _scaleRangesChanged(e) {
    const { xScale: t, yScale: n, _scaleRanges: r } = e,
        i = { xmin: t.min, xmax: t.max, ymin: n.min, ymax: n.max };
    if (!r) return (e._scaleRanges = i), !0;
    const s =
        r.xmin !== t.min ||
        r.xmax !== t.max ||
        r.ymin !== n.min ||
        r.ymax !== n.max;
    return Object.assign(r, i), s;
}
const atEdge = (e) => 0 === e || 1 === e,
    elasticIn = (e, t, n) =>
        -Math.pow(2, 10 * (e -= 1)) * Math.sin(((e - t) * TAU) / n),
    elasticOut = (e, t, n) =>
        Math.pow(2, -10 * e) * Math.sin(((e - t) * TAU) / n) + 1,
    effects = {
        linear: (e) => e,
        easeInQuad: (e) => e * e,
        easeOutQuad: (e) => -e * (e - 2),
        easeInOutQuad: (e) =>
            (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
        easeInCubic: (e) => e * e * e,
        easeOutCubic: (e) => (e -= 1) * e * e + 1,
        easeInOutCubic: (e) =>
            (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
        easeInQuart: (e) => e * e * e * e,
        easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
        easeInOutQuart: (e) =>
            (e /= 0.5) < 1
                ? 0.5 * e * e * e * e
                : -0.5 * ((e -= 2) * e * e * e - 2),
        easeInQuint: (e) => e * e * e * e * e,
        easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
        easeInOutQuint: (e) =>
            (e /= 0.5) < 1
                ? 0.5 * e * e * e * e * e
                : 0.5 * ((e -= 2) * e * e * e * e + 2),
        easeInSine: (e) => 1 - Math.cos(e * HALF_PI),
        easeOutSine: (e) => Math.sin(e * HALF_PI),
        easeInOutSine: (e) => -0.5 * (Math.cos(PI * e) - 1),
        easeInExpo: (e) => (0 === e ? 0 : Math.pow(2, 10 * (e - 1))),
        easeOutExpo: (e) => (1 === e ? 1 : 1 - Math.pow(2, -10 * e)),
        easeInOutExpo: (e) =>
            atEdge(e)
                ? e
                : e < 0.5
                ? 0.5 * Math.pow(2, 10 * (2 * e - 1))
                : 0.5 * (2 - Math.pow(2, -10 * (2 * e - 1))),
        easeInCirc: (e) => (e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1)),
        easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
        easeInOutCirc: (e) =>
            (e /= 0.5) < 1
                ? -0.5 * (Math.sqrt(1 - e * e) - 1)
                : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
        easeInElastic: (e) => (atEdge(e) ? e : elasticIn(e, 0.075, 0.3)),
        easeOutElastic: (e) => (atEdge(e) ? e : elasticOut(e, 0.075, 0.3)),
        easeInOutElastic(e) {
            const t = 0.1125;
            return atEdge(e)
                ? e
                : e < 0.5
                ? 0.5 * elasticIn(2 * e, t, 0.45)
                : 0.5 + 0.5 * elasticOut(2 * e - 1, t, 0.45);
        },
        easeInBack(e) {
            const t = 1.70158;
            return e * e * ((t + 1) * e - t);
        },
        easeOutBack(e) {
            const t = 1.70158;
            return (e -= 1) * e * ((t + 1) * e + t) + 1;
        },
        easeInOutBack(e) {
            let t = 1.70158;
            return (e /= 0.5) < 1
                ? e * e * ((1 + (t *= 1.525)) * e - t) * 0.5
                : 0.5 * ((e -= 2) * e * ((1 + (t *= 1.525)) * e + t) + 2);
        },
        easeInBounce: (e) => 1 - effects.easeOutBounce(1 - e),
        easeOutBounce(e) {
            const t = 7.5625,
                n = 2.75;
            return e < 1 / n
                ? t * e * e
                : e < 2 / n
                ? t * (e -= 1.5 / n) * e + 0.75
                : e < 2.5 / n
                ? t * (e -= 2.25 / n) * e + 0.9375
                : t * (e -= 2.625 / n) * e + 0.984375;
        },
        easeInOutBounce: (e) =>
            e < 0.5
                ? 0.5 * effects.easeInBounce(2 * e)
                : 0.5 * effects.easeOutBounce(2 * e - 1) + 0.5,
    };
function isPatternOrGradient(e) {
    if (e && "object" == typeof e) {
        const t = e.toString();
        return (
            "[object CanvasPattern]" === t || "[object CanvasGradient]" === t
        );
    }
    return !1;
}
function color$1(e) {
    return isPatternOrGradient(e) ? e : new Color(e);
}
function getHoverColor(e) {
    return isPatternOrGradient(e)
        ? e
        : new Color(e).saturate(0.5).darken(0.1).hexString();
}
const numbers = ["x", "y", "borderWidth", "radius", "tension"],
    colors = ["color", "borderColor", "backgroundColor"];
function applyAnimationsDefaults(e) {
    e.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0,
    }),
        e.describe("animation", {
            _fallback: !1,
            _indexable: !1,
            _scriptable: (e) =>
                "onProgress" !== e && "onComplete" !== e && "fn" !== e,
        }),
        e.set("animations", {
            colors: { type: "color", properties: colors },
            numbers: { type: "number", properties: numbers },
        }),
        e.describe("animations", { _fallback: "animation" }),
        e.set("transitions", {
            active: { animation: { duration: 400 } },
            resize: { animation: { duration: 0 } },
            show: {
                animations: {
                    colors: { from: "transparent" },
                    visible: { type: "boolean", duration: 0 },
                },
            },
            hide: {
                animations: {
                    colors: { to: "transparent" },
                    visible: {
                        type: "boolean",
                        easing: "linear",
                        fn: (e) => 0 | e,
                    },
                },
            },
        });
}
function applyLayoutsDefaults(e) {
    e.set("layout", {
        autoPadding: !0,
        padding: { top: 0, right: 0, bottom: 0, left: 0 },
    });
}
const intlCache = new Map();
function getNumberFormat(e, t) {
    t = t || {};
    const n = e + JSON.stringify(t);
    let r = intlCache.get(n);
    return r || ((r = new Intl.NumberFormat(e, t)), intlCache.set(n, r)), r;
}
function formatNumber(e, t, n) {
    return getNumberFormat(t, n).format(e);
}
const formatters = {
    values: (e) => (isArray(e) ? e : "" + e),
    numeric(e, t, n) {
        if (0 === e) return "0";
        const r = this.chart.options.locale;
        let i,
            s = e;
        if (n.length > 1) {
            const t = Math.max(
                Math.abs(n[0].value),
                Math.abs(n[n.length - 1].value)
            );
            (t < 1e-4 || t > 1e15) && (i = "scientific"),
                (s = calculateDelta(e, n));
        }
        const a = log10(Math.abs(s)),
            o = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0),
            l = {
                notation: i,
                minimumFractionDigits: o,
                maximumFractionDigits: o,
            };
        return (
            Object.assign(l, this.options.ticks.format), formatNumber(e, r, l)
        );
    },
    logarithmic(e, t, n) {
        if (0 === e) return "0";
        const r = n[t].significand || e / Math.pow(10, Math.floor(log10(e)));
        return [1, 2, 3, 5, 10, 15].includes(r) || t > 0.8 * n.length
            ? formatters.numeric.call(this, e, t, n)
            : "";
    },
};
function calculateDelta(e, t) {
    let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
    return (
        Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n
    );
}
var Ticks = { formatters: formatters };
function applyScaleDefaults(e) {
    e.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        clip: !0,
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: (e, t) => t.lineWidth,
            tickColor: (e, t) => t.color,
            offset: !1,
        },
        border: { display: !0, dash: [], dashOffset: 0, width: 1 },
        title: { display: !1, text: "", padding: { top: 4, bottom: 4 } },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: Ticks.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2,
        },
    }),
        e.route("scale.ticks", "color", "", "color"),
        e.route("scale.grid", "color", "", "borderColor"),
        e.route("scale.border", "color", "", "borderColor"),
        e.route("scale.title", "color", "", "color"),
        e.describe("scale", {
            _fallback: !1,
            _scriptable: (e) =>
                !e.startsWith("before") &&
                !e.startsWith("after") &&
                "callback" !== e &&
                "parser" !== e,
            _indexable: (e) =>
                "borderDash" !== e && "tickBorderDash" !== e && "dash" !== e,
        }),
        e.describe("scales", { _fallback: "scale" }),
        e.describe("scale.ticks", {
            _scriptable: (e) => "backdropPadding" !== e && "callback" !== e,
            _indexable: (e) => "backdropPadding" !== e,
        });
}
const overrides = Object.create(null),
    descriptors = Object.create(null);
function getScope$1(e, t) {
    if (!t) return e;
    const n = t.split(".");
    for (let r = 0, i = n.length; r < i; ++r) {
        const t = n[r];
        e = e[t] || (e[t] = Object.create(null));
    }
    return e;
}
function set(e, t, n) {
    return "string" == typeof t
        ? merge$1(getScope$1(e, t), n)
        : merge$1(getScope$1(e, ""), t);
}
class Defaults {
    constructor(e, t) {
        (this.animation = void 0),
            (this.backgroundColor = "rgba(0,0,0,0.1)"),
            (this.borderColor = "rgba(0,0,0,0.1)"),
            (this.color = "#666"),
            (this.datasets = {}),
            (this.devicePixelRatio = (e) =>
                e.chart.platform.getDevicePixelRatio()),
            (this.elements = {}),
            (this.events = [
                "mousemove",
                "mouseout",
                "click",
                "touchstart",
                "touchmove",
            ]),
            (this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: "normal",
                lineHeight: 1.2,
                weight: null,
            }),
            (this.hover = {}),
            (this.hoverBackgroundColor = (e, t) =>
                getHoverColor(t.backgroundColor)),
            (this.hoverBorderColor = (e, t) => getHoverColor(t.borderColor)),
            (this.hoverColor = (e, t) => getHoverColor(t.color)),
            (this.indexAxis = "x"),
            (this.interaction = {
                mode: "nearest",
                intersect: !0,
                includeInvisible: !1,
            }),
            (this.maintainAspectRatio = !0),
            (this.onHover = null),
            (this.onClick = null),
            (this.parsing = !0),
            (this.plugins = {}),
            (this.responsive = !0),
            (this.scale = void 0),
            (this.scales = {}),
            (this.showLine = !0),
            (this.drawActiveElementsOnTop = !0),
            this.describe(e),
            this.apply(t);
    }
    set(e, t) {
        return set(this, e, t);
    }
    get(e) {
        return getScope$1(this, e);
    }
    describe(e, t) {
        return set(descriptors, e, t);
    }
    override(e, t) {
        return set(overrides, e, t);
    }
    route(e, t, n, r) {
        const i = getScope$1(this, e),
            s = getScope$1(this, n),
            a = "_" + t;
        Object.defineProperties(i, {
            [a]: { value: i[t], writable: !0 },
            [t]: {
                enumerable: !0,
                get() {
                    const e = this[a],
                        t = s[r];
                    return isObject(e)
                        ? Object.assign({}, t, e)
                        : valueOrDefault(e, t);
                },
                set(e) {
                    this[a] = e;
                },
            },
        });
    }
    apply(e) {
        e.forEach((e) => e(this));
    }
}
var defaults = new Defaults(
    {
        _scriptable: (e) => !e.startsWith("on"),
        _indexable: (e) => "events" !== e,
        hover: { _fallback: "interaction" },
        interaction: { _scriptable: !1, _indexable: !1 },
    },
    [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]
);
function toFontString(e) {
    return !e || isNullOrUndef(e.size) || isNullOrUndef(e.family)
        ? null
        : (e.style ? e.style + " " : "") +
              (e.weight ? e.weight + " " : "") +
              e.size +
              "px " +
              e.family;
}
function _measureText(e, t, n, r, i) {
    let s = t[i];
    return (
        s || ((s = t[i] = e.measureText(i).width), n.push(i)),
        s > r && (r = s),
        r
    );
}
function _longestText(e, t, n, r) {
    let i = ((r = r || {}).data = r.data || {}),
        s = (r.garbageCollect = r.garbageCollect || []);
    r.font !== t &&
        ((i = r.data = {}), (s = r.garbageCollect = []), (r.font = t)),
        e.save(),
        (e.font = t);
    let a = 0;
    const o = n.length;
    let l, c, u, d, p;
    for (l = 0; l < o; l++)
        if (((d = n[l]), null == d || isArray(d))) {
            if (isArray(d))
                for (c = 0, u = d.length; c < u; c++)
                    (p = d[c]),
                        null == p ||
                            isArray(p) ||
                            (a = _measureText(e, i, s, a, p));
        } else a = _measureText(e, i, s, a, d);
    e.restore();
    const h = s.length / 2;
    if (h > n.length) {
        for (l = 0; l < h; l++) delete i[s[l]];
        s.splice(0, h);
    }
    return a;
}
function _alignPixel(e, t, n) {
    const r = e.currentDevicePixelRatio,
        i = 0 !== n ? Math.max(n / 2, 0.5) : 0;
    return Math.round((t - i) * r) / r + i;
}
function clearCanvas(e, t) {
    (t || e) &&
        ((t = t || e.getContext("2d")).save(),
        t.resetTransform(),
        t.clearRect(0, 0, e.width, e.height),
        t.restore());
}
function drawPoint(e, t, n, r) {
    drawPointLegend(e, t, n, r, null);
}
function drawPointLegend(e, t, n, r, i) {
    let s, a, o, l, c, u, d, p;
    const h = t.pointStyle,
        f = t.rotation,
        m = t.radius;
    let g = (f || 0) * RAD_PER_DEG;
    if (
        h &&
        "object" == typeof h &&
        ((s = h.toString()),
        "[object HTMLImageElement]" === s || "[object HTMLCanvasElement]" === s)
    )
        return (
            e.save(),
            e.translate(n, r),
            e.rotate(g),
            e.drawImage(h, -h.width / 2, -h.height / 2, h.width, h.height),
            void e.restore()
        );
    if (!(isNaN(m) || m <= 0)) {
        switch ((e.beginPath(), h)) {
            default:
                i
                    ? e.ellipse(n, r, i / 2, m, 0, 0, TAU)
                    : e.arc(n, r, m, 0, TAU),
                    e.closePath();
                break;
            case "triangle":
                (u = i ? i / 2 : m),
                    e.moveTo(n + Math.sin(g) * u, r - Math.cos(g) * m),
                    (g += TWO_THIRDS_PI),
                    e.lineTo(n + Math.sin(g) * u, r - Math.cos(g) * m),
                    (g += TWO_THIRDS_PI),
                    e.lineTo(n + Math.sin(g) * u, r - Math.cos(g) * m),
                    e.closePath();
                break;
            case "rectRounded":
                (c = 0.516 * m),
                    (l = m - c),
                    (a = Math.cos(g + QUARTER_PI) * l),
                    (d = Math.cos(g + QUARTER_PI) * (i ? i / 2 - c : l)),
                    (o = Math.sin(g + QUARTER_PI) * l),
                    (p = Math.sin(g + QUARTER_PI) * (i ? i / 2 - c : l)),
                    e.arc(n - d, r - o, c, g - PI, g - HALF_PI),
                    e.arc(n + p, r - a, c, g - HALF_PI, g),
                    e.arc(n + d, r + o, c, g, g + HALF_PI),
                    e.arc(n - p, r + a, c, g + HALF_PI, g + PI),
                    e.closePath();
                break;
            case "rect":
                if (!f) {
                    (l = Math.SQRT1_2 * m),
                        (u = i ? i / 2 : l),
                        e.rect(n - u, r - l, 2 * u, 2 * l);
                    break;
                }
                g += QUARTER_PI;
            case "rectRot":
                (d = Math.cos(g) * (i ? i / 2 : m)),
                    (a = Math.cos(g) * m),
                    (o = Math.sin(g) * m),
                    (p = Math.sin(g) * (i ? i / 2 : m)),
                    e.moveTo(n - d, r - o),
                    e.lineTo(n + p, r - a),
                    e.lineTo(n + d, r + o),
                    e.lineTo(n - p, r + a),
                    e.closePath();
                break;
            case "crossRot":
                g += QUARTER_PI;
            case "cross":
                (d = Math.cos(g) * (i ? i / 2 : m)),
                    (a = Math.cos(g) * m),
                    (o = Math.sin(g) * m),
                    (p = Math.sin(g) * (i ? i / 2 : m)),
          ified: "' + r + '"'),
        (r = void 0));
    const i = {
        family: valueOrDefault(e.family, t.family),
        lineHeight: toLineHeight(valueOrDefault(e.lineHeight, t.lineHeight), n),
        size: n,
        style: r,
        weight: valueOrDefault(e.weight, t.weight),
        string: "",
    };
    return (i.string = toFontString(i)), i;
}
function resolve(e, t, n, r) {
    let i, s, a;
    for (i = 0, s = e.length; i < s; ++i)
        if (((a = e[i]), void 0 !== a && void 0 !== a)) return a;
}
function _addGrace(e, t, n) {
    const { min: r, max: i } = e,
        s = toDimension(t, (i - r) / 2),
        a = (e, t) => (n && 0 === e ? 0 : e + t);
    return { min: a(r, -Math.abs(s)), max: a(i, s) };
}
function createContext(e, t) {
    return Object.assign(Object.create(e), t);
}
function _createResolver(e, t = [""], n, r, i = () => e[0]) {
    const s = n || e;
    void 0 === r && (r = _resolve("_fallback", e));
    const a = {
        [Symbol.toStringTag]: "Object",
        _cacheable: !0,
        _scopes: e,
        _rootScopes: s,
        _fallback: r,
        _getTarget: i,
        override: (n) => _createResolver([n, ...e], t, s, r),
    };
    return new Proxy(a, {
        deleteProperty: (t, n) => (
            delete t[n], delete t._keys, delete e[0][n], !0
        ),
        get: (n, r) => _cached(n, r, () => _resolveWithPrefixes(r, t, e, n)),
        getOwnPropertyDescriptor: (e, t) =>
            Reflect.getOwnPropertyDescriptor(e._scopes[0], t),
        getPrototypeOf: () => Reflect.getPrototypeOf(e[0]),
        has: (e, t) => getKeysFromAllScopes(e).includes(t),
        ownKeys: (e) => getKeysFromAllScopes(e),
        set(e, t, n) {
            const r = e._storage || (e._storage = i());
            return (e[t] = r[t] = n), delete e._keys, !0;
        },
    });
}
function _attachContext(e, t, n, r) {
    const i = {
        _cacheable: !1,
        _proxy: e,
        _context: t,
        _subProxy: n,
        _stack: new Set(),
        _descriptors: _descriptors(e, r),
        setContext: (t) => _attachContext(e, t, n, r),
        override: (i) => _attachContext(e.override(i), t, n, r),
    };
    return new Proxy(i, {
        deleteProperty: (t, n) => (delete t[n], delete e[n], !0),
        get: (e, t, n) => _cached(e, t, () => _resolveWithContext(e, t, n)),
        getOwnPropertyDescriptor: (t, n) =>
            t._descriptors.allKeys
                ? Reflect.has(e, n)
                    ? { enumerable: !0, configurable: !0 }
                    : void 0
                : Reflect.getOwnPropertyDescriptor(e, n),
        getPrototypeOf: () => Reflect.getPrototypeOf(e),
        has: (t, n) => Reflect.has(e, n),
        ownKeys: () => Reflect.ownKeys(e),
        set: (t, n, r) => ((e[n] = r), delete t[n], !0),
    });
}
function _descriptors(e, t = { scriptable: !0, indexable: !0 }) {
    const {
        _scriptable: n = t.scriptable,
        _indexable: r = t.indexable,
        _allKeys: i = t.allKeys,
    } = e;
    return {
        allKeys: i,
        scriptable: n,
        indexable: r,
        isScriptable: isFunction(n) ? n : () => n,
        isIndexable: isFunction(r) ? r : () => r,
    };
}
const readKey = (e, t) => (e ? e + _capitalize(t) : t),
    needsSubResolver = (e, t) =>
        isObject(t) &&
        "adapters" !== e &&
        (null === Object.getPrototypeOf(t) || t.constructor === Object);
function _cached(e, t, n) {
    if (Object.prototype.hasOwnProperty.call(e, t) || "constructor" === t)
        return e[t];
    const r = n();
    return (e[t] = r), r;
}
function _resolveWithContext(e, t, n) {
    const { _proxy: r, _context: i, _subProxy: s, _descriptors: a } = e;
    let o = r[t];
    return (
        isFunction(o) &&
            a.isScriptable(t) &&
            (o = _resolveScriptable(t, o, e, n)),
        isArray(o) && o.length && (o = _resolveArray(t, o, e, a.isIndexable)),
        needsSubResolver(t, o) && (o = _attachContext(o, i, s && s[t], a)),
        o
    );
}
function _resolveScriptable(e, t, n, r) {
    const { _proxy: i, _context: s, _subProxy: a, _stack: o } = n;
    if (o.has(e))
        throw new Error(
            "Recursion detected: " + Array.from(o).join("->") + "->" + e
        );
    o.add(e);
    let l = t(s, a || r);
    return (
        o.delete(e),
        needsSubResolver(e, l) && (l = createSubResolver(i._scopes, i, e, l)),
        l
    );
}
function _resolveArray(e, t, n, r) {
    const { _proxy: i, _context: s, _subProxy: a, _descriptors: o } = n;
    if (void 0 !== s.index && r(e)) return t[s.index % t.length];
    if (isObject(t[0])) {
        const n = t,
            r = i._scopes.filter((e) => e !== n);
        t = [];
        for (const l of n) {
            const n = createSubResolver(r, i, e, l);
            t.push(_attachContext(n, s, a && a[e], o));
        }
    }
    return t;
}
function resolveFallback(e, t, n) {
    return isFunction(e) ? e(t, n) : e;
}
const getScope = (e, t) =>
    !0 === e ? t : "string" == typeof e ? resolveObjectKey(t, e) : void 0;
function addScopes(e, t, n, r, i) {
    for (const s of t) {
        const t = getScope(n, s);
        if (t) {
            e.add(t);
            const s = resolveFallback(t._fallback, n, i);
            if (void 0 !== s && s !== n && s !== r) return s;
        } else if (!1 === t && void 0 !== r && n !== r) return null;
    }
    return !1;
}
function createSubResolver(e, t, n, r) {
    const i = t._rootScopes,
        s = resolveFallback(t._fallback, n, r),
        a = [...e, ...i],
        o = new Set();
    o.add(r);
    let l = addScopesFromKey(o, a, n, s || n, r);
    return (
        null !== l &&
        (void 0 === s ||
            s === n ||
            ((l = addScopesFromKey(o, a, s, l, r)), null !== l)) &&
        _createResolver(Array.from(o), [""], i, s, () => subGetTarget(t, n, r))
    );
}
function addScopesFromKey(e, t, n, r, i) {
    for (; n; ) n = addScopes(e, t, n, r, i);
    return n;
}
function subGetTarget(e, t, n) {
    const r = e._getTarget();
    t in r || (r[t] = {});
    const i = r[t];
    return isArray(i) && isObject(n) ? n : i || {};
}
function _resolveWithPrefixes(e, t, n, r) {
    let i;
    for (const s of t)
        if (((i = _resolve(readKey(s, e), n)), void 0 !== i))
            return needsSubResolver(e, i) ? createSubResolver(n, r, e, i) : i;
}
function _resolve(e, t) {
    for (const n of t) {
        if (!n) continue;
        const t = n[e];
        if (void 0 !== t) return t;
    }
}
function getKeysFromAllScopes(e) {
    let t = e._keys;
    return t || (t = e._keys = resolveKeysFromAllScopes(e._scopes)), t;
}
function resolveKeysFromAllScopes(e) {
    const t = new Set();
    for (const n of e)
        for (const e of Object.keys(n).filter((e) => !e.startsWith("_")))
            t.add(e);
    return Array.from(t);
}
function _parseObjectDataRadialScale(e, t, n, r) {
    const { iScale: i } = e,
        { key: s = "r" } = this._parsing,
        a = new Array(r);
    let o, l, c, u;
    for (o = 0, l = r; o < l; ++o)
        (c = o + n),
            (u = t[c]),
            (a[o] = { r: i.parse(resolveObjectKey(u, s), c) });
    return a;
}
const EPSILON = Number.EPSILON || 1e-14,
    getPoint = (e, t) => t < e.length && !e[t].skip && e[t],
    getValueAxis = (e) => ("x" === e ? "y" : "x");
function splineCurve(e, t, n, r) {
    const i = e.skip ? t : e,
        s = t,
        a = n.skip ? t : n,
        o = distanceBetweenPoints(s, i),
        l = distanceBetweenPoints(a, s);
    let c = o / (o + l),
        u = l / (o + l);
    (c = isNaN(c) ? 0 : c), (u = isNaN(u) ? 0 : u);
    const d = r * c,
        p = r * u;
    return {
        previous: { x: s.x - d * (a.x - i.x), y: s.y - d * (a.y - i.y) },
        next: { x: s.x + p * (a.x - i.x), y: s.y + p * (a.y - i.y) },
    };
}
function monotoneAdjust(e, t, n) {
    const r = e.length;
    let i,
        s,
        a,
        o,
        l,
        c = getPoint(e, 0);
    for (let u = 0; u < r - 1; ++u)
        (l = c),
            (c = getPoint(e, u + 1)),
            l &&
                c &&
                (almostEquals(t[u], 0, EPSILON)
                    ? (n[u] = n[u + 1] = 0)
                    : ((i = n[u] / t[u]),
                      (s = n[u + 1] / t[u]),
                      (o = Math.pow(i, 2) + Math.pow(s, 2)),
                      o <= 9 ||
                          ((a = 3 / Math.sqrt(o)),
                          (n[u] = i * a * t[u]),
                          (n[u + 1] = s * a * t[u]))));
}
function monotoneCompute(e, t, n = "x") {
    const r = getValueAxis(n),
        i = e.length;
    let s,
        a,
        o,
        l = getPoint(e, 0);
    for (let c = 0; c < i; ++c) {
        if (((a = o), (o = l), (l = getPoint(e, c + 1)), !o)) continue;
        const i = o[n],
            u = o[r];
        a &&
            ((s = (i - a[n]) / 3),
            (o[`cp1${n}`] = i - s),
            (o[`cp1${r}`] = u - s * t[c])),
            l &&
                ((s = (l[n] - i) / 3),
                (o[`cp2${n}`] = i + s),
                (o[`cp2${r}`] = u + s * t[c]));
    }
}
function splineCurveMonotone(e, t = "x") {
    const n = getValueAxis(t),
        r = e.length,
        i = Array(r).fill(0),
        s = Array(r);
    let a,
        o,
        l,
        c = getPoint(e, 0);
    for (a = 0; a < r; ++a)
        if (((o = l), (l = c), (c = getPoint(e, a + 1)), l)) {
            if (c) {
                const e = c[t] - l[t];
                i[a] = 0 !== e ? (c[n] - l[n]) / e : 0;
            }
            s[a] = o
                ? c
                    ? sign(i[a - 1]) !== sign(i[a])
                        ? 0
                        : (i[a - 1] + i[a]) / 2
                    : i[a - 1]
                : i[a];
        }
    monotoneAdjust(e, i, s), monotoneCompute(e, s, t);
}
function capControlPoint(e, t, n) {
    return Math.max(Math.min(e, n), t);
}
function capBezierPoints(e, t) {
    let n,
        r,
        i,
        s,
        a,
        o = _isPointInArea(e[0], t);
    for (n = 0, r = e.length; n < r; ++n)
        (a = s),
            (s = o),
            (o = n < r - 1 && _isPointInArea(e[n + 1], t)),
            s &&
                ((i = e[n]),
                a &&
                    ((i.cp1x = capControlPoint(i.cp1x, t.left, t.right)),
                    (i.cp1y = capControlPoint(i.cp1y, t.top, t.bottom))),
                o &&
                    ((i.cp2x = capControlPoint(i.cp2x, t.left, t.right)),
                    (i.cp2y = capControlPoint(i.cp2y, t.top, t.bottom))));
}
function _updateBezierControlPoints(e, t, n, r, i) {
    let s, a, o, l;
    if (
        (t.spanGaps && (e = e.filter((e) => !e.skip)),
        "monotone" === t.cubicInterpolationMode)
    )
        splineCurveMonotone(e, i);
    else {
        let n = r ? e[e.length - 1] : e[0];
        for (s = 0, a = e.length; s < a; ++s)
            (o = e[s]),
                (l = splineCurve(
                    n,
                    o,
                    e[Math.min(s + 1, a - (r ? 0 : 1)) % a],
                    t.tension
                )),
                (o.cp1x = l.previous.x),
                (o.cp1y = l.previous.y),
                (o.cp2x = l.next.x),
                (o.cp2y = l.next.y),
                (n = o);
    }
    t.capBezierPoints && capBezierPoints(e, n);
}
function _isDomSupported() {
    return "undefined" != typeof window && "undefined" != typeof document;
}
function _getParentNode(e) {
    let t = e.parentNode;
    return t && "[object ShadowRoot]" === t.toString() && (t = t.host), t;
}
function parseMaxStyle(e, t, n) {
    let r;
    return (
        "string" == typeof e
            ? ((r = parseInt(e, 10)),
              -1 !== e.indexOf("%") && (r = (r / 100) * t.parentNode[n]))
            : (r = e),
        r
    );
}
const getComputedStyle$2 = (e) =>
    e.ownerDocument.defaultView.getComputedStyle(e, null);
function getStyle(e, t) {
    return getComputedStyle$2(e).getPropertyValue(t);
}
const positions = ["top", "right", "bottom", "left"];
function getPositionedStyle(e, t, n) {
    const r = {};
    n = n ? "-" + n : "";
    for (let i = 0; i < 4; i++) {
        const s = positions[i];
        r[s] = parseFloat(e[t + "-" + s + n]) || 0;
    }
    return (r.width = r.left + r.right), (r.height = r.top + r.bottom), r;
}
const useOffsetPos = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function getCanvasPosition(e, t) {
    const n = e.touches,
        r = n && n.length ? n[0] : e,
        { offsetX: i, offsetY: s } = r;
    let a,
        o,
        l = !1;
    if (useOffsetPos(i, s, e.target)) (a = i), (o = s);
    else {
        const e = t.getBoundingClientRect();
        (a = r.clientX - e.left), (o = r.clientY - e.top), (l = !0);
    }
    return { x: a, y: o, box: l };
}
function getRelativePosition(e, t) {
    if ("native" in e) return e;
    const { canvas: n, currentDevicePixelRatio: r } = t,
        i = getComputedStyle$2(n),
        s = "border-box" === i.boxSizing,
        a = getPositionedStyle(i, "padding"),
        o = getPositionedStyle(i, "border", "width"),
        { x: l, y: c, box: u } = getCanvasPosition(e, n),
        d = a.left + (u && o.left),
        p = a.top + (u && o.top);
    let { width: h, height: f } = t;
    return (
        s && ((h -= a.width + o.width), (f -= a.height + o.height)),
        {
            x: Math.round((((l - d) / h) * n.width) / r),
            y: Math.round((((c - p) / f) * n.height) / r),
        }
    );
}
function getContainerSize(e, t, n) {
    let r, i;
    if (void 0 === t || void 0 === n) {
        const s = e && _getParentNode(e);
        if (s) {
            const e = s.getBoundingClientRect(),
                a = getComputedStyle$2(s),
                o = getPositionedStyle(a, "border", "width"),
                l = getPositionedStyle(a, "padding");
            (t = e.width - l.width - o.width),
                (n = e.height - l.height - o.height),
                (r = parseMaxStyle(a.maxWidth, s, "clientWidth")),
                (i = parseMaxStyle(a.maxHeight, s, "clientHeight"));
        } else (t = e.clientWidth), (n = e.clientHeight);
    }
    return {
        width: t,
        height: n,
        maxWidth: r || INFINITY,
        maxHeight: i || INFINITY,
    };
}
const round1 = (e) => Math.round(10 * e) / 10;
function getMaximumSize(e, t, n, r) {
    const i = getComputedStyle$2(e),
        s = getPositionedStyle(i, "margin"),
        a = parseMaxStyle(i.maxWidth, e, "clientWidth") || INFINITY,
        o = parseMaxStyle(i.maxHeight, e, "clientHeight") || INFINITY,
        l = getContainerSize(e, t, n);
    let { width: c, height: u } = l;
    if ("content-box" === i.boxSizing) {
        const e = getPositionedStyle(i, "border", "width"),
            t = getPositionedStyle(i, "padding");
        (c -= t.width + e.width), (u -= t.height + e.height);
    }
    (c = Math.max(0, c - s.width)),
        (u = Math.max(0, r ? c / r : u - s.height)),
        (c = round1(Math.min(c, a, l.maxWidth))),
        (u = round1(Math.min(u, o, l.maxHeight))),
        c && !u && (u = round1(c / 2));
    return (
        (void 0 !== t || void 0 !== n) &&
            r &&
            l.height &&
            u > l.height &&
            ((u = l.height), (c = round1(Math.floor(u * r)))),
        { width: c, height: u }
    );
}
function retinaScale(e, t, n) {
    const r = t || 1,
        i = Math.floor(e.height * r),
        s = Math.floor(e.width * r);
    (e.height = Math.floor(e.height)), (e.width = Math.floor(e.width));
    const a = e.canvas;
    return (
        a.style &&
            (n || (!a.style.height && !a.style.width)) &&
            ((a.style.height = `${e.height}px`),
            (a.style.width = `${e.width}px`)),
        (e.currentDevicePixelRatio !== r || a.height !== i || a.width !== s) &&
            ((e.currentDevicePixelRatio = r),
            (a.height = i),
            (a.width = s),
            e.ctx.setTransform(r, 0, 0, r, 0, 0),
            !0)
    );
}
const supportsEventListenerOptions = (function () {
    let e = !1;
    try {
        const t = {
            get passive() {
                return (e = !0), !1;
            },
        };
        _isDomSupported() &&
            (window.addEventListener("test", null, t),
            window.removeEventListener("test", null, t));
    } catch (e2) {}
    return e;
})();
function readUsedSize(e, t) {
    const n = getStyle(e, t),
        r = n && n.match(/^(\d+)(\.\d+)?px$/);
    return r ? +r[1] : void 0;
}
function _pointInLine(e, t, n, r) {
    return { x: e.x + n * (t.x - e.x), y: e.y + n * (t.y - e.y) };
}
function _steppedInterpolation(e, t, n, r) {
    return {
        x: e.x + n * (t.x - e.x),
        y:
            "middle" === r
                ? n < 0.5
                    ? e.y
                    : t.y
                : "after" === r
                ? n < 1
                    ? e.y
                    : t.y
                : n > 0
                ? t.y
                : e.y,
    };
}
function _bezierInterpolation(e, t, n, r) {
    const i = { x: e.cp2x, y: e.cp2y },
        s = { x: t.cp1x, y: t.cp1y },
        a = _pointInLine(e, i, n),
        o = _pointInLine(i, s, n),
        l = _pointInLine(s, t, n),
        c = _pointInLine(a, o, n),
        u = _pointInLine(o, l, n);
    return _pointInLine(c, u, n);
}
const getRightToLeftAdapter = function (e, t) {
        return {
            x: (n) => e + e + t - n,
            setWidth(e) {
                t = e;
            },
            textAlign: (e) =>
                "center" === e ? e : "right" === e ? "left" : "right",
            xPlus: (e, t) => e - t,
            leftForLtr: (e, t) => e - t,
        };
    },
    getLeftToRightAdapter = function () {
        return {
            x: (e) => e,
            setWidth(e) {},
            textAlign: (e) => e,
            xPlus: (e, t) => e + t,
            leftForLtr: (e, t) => e,
        };
    };
function getRtlAdapter(e, t, n) {
    return e ? getRightToLeftAdapter(t, n) : getLeftToRightAdapter();
}
function overrideTextDirection(e, t) {
    let n, r;
    ("ltr" !== t && "rtl" !== t) ||
        ((n = e.canvas.style),
        (r = [
            n.getPropertyValue("direction"),
            n.getPropertyPriority("direction"),
        ]),
        n.setProperty("direction", t, "important"),
        (e.prevTextDirection = r));
}
function restoreTextDirection(e, t) {
    void 0 !== t &&
        (delete e.prevTextDirection,
        e.canvas.style.setProperty("direction", t[0], t[1]));
}
function propertyFn(e) {
    return "angle" === e
        ? {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle,
          }
        : {
              between: _isBetween,
              compare: (e, t) => e - t,
              normalize: (e) => e,
          };
}
function normalizeSegment({ start: e, end: t, count: n, loop: r, style: i }) {
    return {
        start: e % n,
        end: t % n,
        loop: r && (t - e + 1) % n == 0,
        style: i,
    };
}
function getSegment(e, t, n) {
    const { property: r, start: i, end: s } = n,
        { between: a, normalize: o } = propertyFn(r),
        l = t.length;
    let c,
        u,
        { start: d, end: p, loop: h } = e;
    if (h) {
        for (
            d += l, p += l, c = 0, u = l;
            c < u && a(o(t[d % l][r]), i, s);
            ++c
        )
            d--, p--;
        (d %= l), (p %= l);
    }
    return p < d && (p += l), { start: d, end: p, loop: h, style: e.style };
}
function _boundSegment(e, t, n) {
    if (!n) return [e];
    const { property: r, start: i, end: s } = n,
        a = t.length,
        { compare: o, between: l, normalize: c } = propertyFn(r),
        { start: u, end: d, loop: p, style: h } = getSegment(e, t, n),
        f = [];
    let m,
        g,
        x,
        v = !1,
        b = null;
    const y = () => v || (l(i, x, m) && 0 !== o(i, x)),
        _ = () => !v || 0 === o(s, m) || l(s, x, m);
    for (let E = u, S = u; E <= d; ++E)
        (g = t[E % a]),
            g.skip ||
                ((m = c(g[r])),
                m !== x &&
                    ((v = l(m, i, s)),
                    null === b && y() && (b = 0 === o(m, i) ? E : S),
                    null !== b &&
                        _() &&
                        (f.push(
                            normalizeSegment({
                                start: b,
                                end: E,
                                loop: p,
                                count: a,
                                style: h,
                            })
                        ),
                        (b = null)),
                    (S = E),
                    (x = m)));
    return (
        null !== b &&
            f.push(
                normalizeSegment({
                    start: b,
                    end: d,
                    loop: p,
                    count: a,
                    style: h,
                })
            ),
        f
    );
}
function _boundSegments(e, t) {
    const n = [],
        r = e.segments;
    for (let i = 0; i < r.length; i++) {
        const s = _boundSegment(r[i], e.points, t);
        s.length && n.push(...s);
    }
    return n;
}
function findStartAndEnd(e, t, n, r) {
    let i = 0,
        s = t - 1;
    if (n && !r) for (; i < t && !e[i].skip; ) i++;
    for (; i < t && e[i].skip; ) i++;
    for (i %= t, n && (s += i); s > i && e[s % t].skip; ) s--;
    return (s %= t), { start: i, end: s };
}
function solidSegments(e, t, n, r) {
    const i = e.length,
        s = [];
    let a,
        o = t,
        l = e[t];
    for (a = t + 1; a <= n; ++a) {
        const n = e[a % i];
        n.skip || n.stop
            ? l.skip ||
              ((r = !1),
              s.push({ start: t % i, end: (a - 1) % i, loop: r }),
              (t = o = n.stop ? a : null))
            : ((o = a), l.skip && (t = a)),
            (l = n);
    }
    return null !== o && s.push({ start: t % i, end: o % i, loop: r }), s;
}
function _computeSegments(e, t) {
    const n = e.points,
        r = e.options.spanGaps,
        i = n.length;
    if (!i) return [];
    const s = !!e._loop,
        { start: a, end: o } = findStartAndEnd(n, i, s, r);
    if (!0 === r)
        return splitByStyles(e, [{ start: a, end: o, loop: s }], n, t);
    return splitByStyles(
        e,
        solidSegments(
            n,
            a,
            o < a ? o + i : o,
            !!e._fullLoop && 0 === a && o === i - 1
        ),
        n,
        t
    );
}
function splitByStyles(e, t, n, r) {
    return r && r.setContext && n ? doSplitByStyles(e, t, n, r) : t;
}
function doSplitByStyles(e, t, n, r) {
    const i = e._chart.getContext(),
        s = readStyle(e.options),
        {
            _datasetIndex: a,
            options: { spanGaps: o },
        } = e,
        l = n.length,
        c = [];
    let u = s,
        d = t[0].start,
        p = d;
    function h(e, t, r, i) {
        const s = o ? -1 : 1;
        if (e !== t) {
            for (e += l; n[e % l].skip; ) e -= s;
            for (; n[t % l].skip; ) t += s;
            e % l != t % l &&
                (c.push({ start: e % l, end: t % l, loop: r, style: i }),
                (u = i),
                (d = t % l));
        }
    }
    for (const f of t) {
        d = o ? d : f.start;
        let e,
            t = n[d % l];
        for (p = d + 1; p <= f.end; p++) {
            const s = n[p % l];
            (e = readStyle(
                r.setContext(
                    createContext(i, {
                        type: "segment",
                        p0: t,
                        p1: s,
                        p0DataIndex: (p - 1) % l,
                        p1DataIndex: p % l,
                        datasetIndex: a,
                    })
                )
            )),
                styleChanged(e, u) && h(d, p - 1, f.loop, u),
                (t = s),
                (u = e);
        }
        d < p - 1 && h(d, p - 1, f.loop, u);
    }
    return c;
}
function readStyle(e) {
    return {
        backgroundColor: e.backgroundColor,
        borderCapStyle: e.borderCapStyle,
        borderDash: e.borderDash,
        borderDashOffset: e.borderDashOffset,
        borderJoinStyle: e.borderJoinStyle,
        borderWidth: e.borderWidth,
        borderColor: e.borderColor,
    };
}
function styleChanged(e, t) {
    if (!t) return !1;
    const n = [],
        r = function (e, t) {
            return isPatternOrGradient(t)
                ? (n.includes(t) || n.push(t), n.indexOf(t))
                : t;
        };
    return JSON.stringify(e, r) !== JSON.stringify(t, r);
}
/*!
 * Chart.js v4.4.3
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */ class Animator {
    constructor() {
        (this._request = null),
            (this._charts = new Map()),
            (this._running = !1),
            (this._lastDate = void 0);
    }
    _notify(e, t, n, r) {
        const i = t.listeners[r],
            s = t.duration;
        i.forEach((r) =>
            r({
                chart: e,
                initial: t.initial,
                numSteps: s,
                currentStep: Math.min(n - t.start, s),
            })
        );
    }
    _refresh() {
        this._request ||
            ((this._running = !0),
            (this._request = requestAnimFrame.call(window, () => {
                this._update(),
                    (this._request = null),
                    this._running && this._refresh();
            })));
    }
    _update(e = Date.now()) {
        let t = 0;
        this._charts.forEach((n, r) => {
            if (!n.running || !n.items.length) return;
            const i = n.items;
            let s,
                a = i.length - 1,
                o = !1;
            for (; a >= 0; --a)
                (s = i[a]),
                    s._active
                        ? (s._total > n.duration && (n.duration = s._total),
                          s.tick(e),
                          (o = !0))
                        : ((i[a] = i[i.length - 1]), i.pop());
            o && (r.draw(), this._notify(r, n, e, "progress")),
                i.length ||
                    ((n.running = !1),
                    this._notify(r, n, e, "complete"),
                    (n.initial = !1)),
                (t += i.length);
        }),
            (this._lastDate = e),
            0 === t && (this._running = !1);
    }
    _getAnims(e) {
        const t = this._charts;
        let n = t.get(e);
        return (
            n ||
                ((n = {
                    running: !1,
                    initial: !0,
                    items: [],
                    listeners: { complete: [], progress: [] },
                }),
                t.set(e, n)),
            n
        );
    }
    listen(e, t, n) {
        this._getAnims(e).listeners[t].push(n);
    }
    add(e, t) {
        t && t.length && this._getAnims(e).items.push(...t);
    }
    has(e) {
        return this._getAnims(e).items.length > 0;
    }
    start(e) {
        const t = this._charts.get(e);
        t &&
            ((t.running = !0),
            (t.start = Date.now()),
            (t.duration = t.items.reduce(
                (e, t) => Math.max(e, t._duration),
                0
            )),
            this._refresh());
    }
    running(e) {
        if (!this._running) return !1;
        const t = this._charts.get(e);
        return !!(t && t.running && t.items.length);
    }
    stop(e) {
        const t = this._charts.get(e);
        if (!t || !t.items.length) return;
        const n = t.items;
        let r = n.length - 1;
        for (; r >= 0; --r) n[r].cancel();
        (t.items = []), this._notify(e, t, Date.now(), "complete");
    }
    remove(e) {
        return this._charts.delete(e);
    }
}
var animator = new Animator();
const transparent = "transparent",
    interpolators = {
        boolean: (e, t, n) => (n > 0.5 ? t : e),
        color(e, t, n) {
            const r = color$1(e || transparent),
                i = r.valid && color$1(t || transparent);
            return i && i.valid ? i.mix(r, n).hexString() : t;
        },
        number: (e, t, n) => e + (t - e) * n,
    };
class Animation {
    constructor(e, t, n, r) {
        const i = t[n];
        r = resolve([e.to, r, i, e.from]);
        const s = resolve([e.from, i, r]);
        (this._active = !0),
            (this._fn = e.fn || interpolators[e.type || typeof s]),
            (this._easing = effects[e.easing] || effects.linear),
            (this._start = Math.floor(Date.now() + (e.delay || 0))),
            (this._duration = this._total = Math.floor(e.duration)),
            (this._loop = !!e.loop),
            (this._target = t),
            (this._prop = n),
            (this._from = s),
            (this._to = r),
            (this._promises = void 0);
    }
    active() {
        return this._active;
    }
    update(e, t, n) {
        if (this._active) {
            this._notify(!1);
            const r = this._target[this._prop],
                i = n - this._start,
                s = this._duration - i;
            (this._start = n),
                (this._duration = Math.floor(Math.max(s, e.duration))),
                (this._total += i),
                (this._loop = !!e.loop),
                (this._to = resolve([e.to, t, r, e.from])),
                (this._from = resolve([e.from, r, t]));
        }
    }
    cancel() {
        this._active &&
            (this.tick(Date.now()), (this._active = !1), this._notify(!1));
    }
    tick(e) {
        const t = e - this._start,
            n = this._duration,
            r = this._prop,
            i = this._from,
            s = this._loop,
            a = this._to;
        let o;
        if (((this._active = i !== a && (s || t < n)), !this._active))
            return (this._target[r] = a), void this._notify(!0);
        t < 0
            ? (this._target[r] = i)
            : ((o = (t / n) % 2),
              (o = s && o > 1 ? 2 - o : o),
              (o = this._easing(Math.min(1, Math.max(0, o)))),
              (this._target[r] = this._fn(i, a, o)));
    }
    wait() {
        const e = this._promises || (this._promises = []);
        return new Promise((t, n) => {
            e.push({ res: t, rej: n });
        });
    }
    _notify(e) {
        const t = e ? "res" : "rej",
            n = this._promises || [];
        for (let r = 0; r < n.length; r++) n[r][t]();
    }
}
class Animations {
    constructor(e, t) {
        (this._chart = e), (this._properties = new Map()), this.configure(t);
    }
    configure(e) {
        if (!isObject(e)) return;
        const t = Object.keys(defaults.animation),
            n = this._properties;
        Object.getOwnPropertyNames(e).forEach((r) => {
            const i = e[r];
            if (!isObject(i)) return;
            const s = {};
            for (const e of t) s[e] = i[e];
            ((isArray(i.properties) && i.properties) || [r]).forEach((e) => {
                (e !== r && n.has(e)) || n.set(e, s);
            });
        });
    }
    _animateOptions(e, t) {
        const n = t.options,
            r = resolveTargetOptions(e, n);
        if (!r) return [];
        const i = this._createAnimations(r, n);
        return (
            n.$shared &&
                awaitAll(e.options.$animations, n).then(
                    () => {
                        e.options = n;
                    },
                    () => {}
                ),
            i
        );
    }
    _createAnimations(e, t) {
        const n = this._properties,
            r = [],
            i = e.$animations || (e.$animations = {}),
            s = Object.keys(t),
            a = Date.now();
        let o;
        for (o = s.length - 1; o >= 0; --o) {
            const l = s[o];
            if ("$" === l.charAt(0)) continue;
            if ("options" === l) {
                r.push(...this._animateOptions(e, t));
                continue;
            }
            const c = t[l];
            let u = i[l];
            const d = n.get(l);
            if (u) {
                if (d && u.active()) {
                    u.update(d, c, a);
                    continue;
                }
                u.cancel();
            }
            d && d.duration
                ? ((i[l] = u = new Animation(d, e, l, c)), r.push(u))
                : (e[l] = c);
        }
        return r;
    }
    update(e, t) {
        if (0 === this._properties.size) return void Object.assign(e, t);
        const n = this._createAnimations(e, t);
        return n.length ? (animator.add(this._chart, n), !0) : void 0;
    }
}
function awaitAll(e, t) {
    const n = [],
        r = Object.keys(t);
    for (let i = 0; i < r.length; i++) {
        const t = e[r[i]];
        t && t.active() && n.push(t.wait());
    }
    return Promise.all(n);
}
function resolveTargetOptions(e, t) {
    if (!t) return;
    let n = e.options;
    if (n)
        return (
            n.$shared &&
                (e.options = n =
                    Object.assign({}, n, { $shared: !1, $animations: {} })),
            n
        );
    e.options = t;
}
function scaleClip(e, t) {
    const n = (e && e.options) || {},
        r = n.reverse,
        i = void 0 === n.min ? t : 0,
        s = void 0 === n.max ? t : 0;
    return { start: r ? s : i, end: r ? i : s };
}
function defaultClip(e, t, n) {
    if (!1 === n) return !1;
    const r = scaleClip(e, n),
        i = scaleClip(t, n);
    return { top: i.end, right: r.end, bottom: i.start, left: r.start };
}
function toClip(e) {
    let t, n, r, i;
    return (
        isObject(e)
            ? ((t = e.top), (n = e.right), (r = e.bottom), (i = e.left))
            : (t = n = r = i = e),
        { top: t, right: n, bottom: r, left: i, disabled: !1 === e }
    );
}
function getSortedDatasetIndices(e, t) {
    const n = [],
        r = e._getSortedDatasetMetas(t);
    let i, s;
    for (i = 0, s = r.length; i < s; ++i) n.push(r[i].index);
    return n;
}
function applyStack(e, t, n, r = {}) {
    const i = e.keys,
        s = "single" === r.mode;
    let a, o, l, c;
    if (null !== t) {
        for (a = 0, o = i.length; a < o; ++a) {
            if (((l = +i[a]), l === n)) {
                if (r.all) continue;
                break;
            }
            (c = e.values[l]),
                isNumberFinite(c) &&
                    (s || 0 === t || sign(t) === sign(c)) &&
                    (t += c);
        }
        return t;
    }
}
function convertObjectDataToArray(e, t) {
    const { iScale: n, vScale: r } = t,
        i = "x" === n.axis ? "x" : "y",
        s = "x" === r.axis ? "x" : "y",
        a = Object.keys(e),
        o = new Array(a.length);
    let l, c, u;
    for (l = 0, c = a.length; l < c; ++l)
        (u = a[l]), (o[l] = { [i]: u, [s]: e[u] });
    return o;
}
function isStacked(e, t) {
    const n = e && e.options.stacked;
    return n || (void 0 === n && void 0 !== t.stack);
}
function getStackKey(e, t, n) {
    return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function getUserBounds(e) {
    const { min: t, max: n, minDefined: r, maxDefined: i } = e.getUserBounds();
    return {
        min: r ? t : Number.NEGATIVE_INFINITY,
        max: i ? n : Number.POSITIVE_INFINITY,
    };
}
function getOrCreateStack(e, t, n) {
    const r = e[t] || (e[t] = {});
    return r[n] || (r[n] = {});
}
function getLastIndexInStack(e, t, n, r) {
    for (const i of t.getMatchingVisibleMetas(r).reverse()) {
        const t = e[i.index];
        if ((n && t > 0) || (!n && t < 0)) return i.index;
    }
    return null;
}
function updateStacks(e, t) {
    const { chart: n, _cachedMeta: r } = e,
        i = n._stacks || (n._stacks = {}),
        { iScale: s, vScale: a, index: o } = r,
        l = s.axis,
        c = a.axis,
        u = getStackKey(s, a, r),
        d = t.length;
    let p;
    for (let h = 0; h < d; ++h) {
        const e = t[h],
            { [l]: n, [c]: s } = e;
        (p = (e._stacks || (e._stacks = {}))[c] = getOrCreateStack(i, u, n)),
            (p[o] = s),
            (p._top = getLastIndexInStack(p, a, !0, r.type)),
            (p._bottom = getLastIndexInStack(p, a, !1, r.type));
        (p._visualValues || (p._visualValues = {}))[o] = s;
    }
}
function getFirstScaleId(e, t) {
    const n = e.scales;
    return Object.keys(n)
        .filter((e) => n[e].axis === t)
        .shift();
}
function createDatasetContext(e, t) {
    return createContext(e, {
        active: !1,
        dataset: void 0,
        datasetIndex: t,
        index: t,
        mode: "default",
        type: "dataset",
    });
}
function createDataContext(e, t, n) {
    return createContext(e, {
        active: !1,
        dataIndex: t,
        parsed: void 0,
        raw: void 0,
        element: n,
        index: t,
        mode: "default",
        type: "data",
    });
}
function clearStacks(e, t) {
    const n = e.controller.index,
        r = e.vScale && e.vScale.axis;
    if (r) {
        t = t || e._parsed;
        for (const e of t) {
            const t = e._stacks;
            if (!t || void 0 === t[r] || void 0 === t[r][n]) return;
            delete t[r][n],
                void 0 !== t[r]._visualValues &&
                    void 0 !== t[r]._visualValues[n] &&
                    delete t[r]._visualValues[n];
        }
    }
}
const isDirectUpdateMode = (e) => "reset" === e || "none" === e,
    cloneIfNotShared = (e, t) => (t ? e : Object.assign({}, e)),
    createStack$1 = (e, t, n) =>
        e &&
        !t.hidden &&
        t._stacked && { keys: getSortedDatasetIndices(n, !0), values: null };
class DatasetController {
    constructor(e, t) {
        (this.chart = e),
            (this._ctx = e.ctx),
            (this.index = t),
            (this._cachedDataOpts = {}),
            (this._cachedMeta = this.getMeta()),
            (this._type = this._cachedMeta.type),
            (this.options = void 0),
            (this._parsing = !1),
            (this._data = void 0),
            (this._objectData = void 0),
            (this._sharedOptions = void 0),
            (this._drawStart = void 0),
            (this._drawCount = void 0),
            (this.enableOptionSharing = !1),
            (this.supportsDecimation = !1),
            (this.$context = void 0),
            (this._syncList = []),
            (this.datasetElementType = new.target.datasetElementType),
            (this.dataElementType = new.target.dataElementType),
            this.initialize();
    }
    initialize() {
        const e = this._cachedMeta;
        this.configure(),
            this.linkScales(),
            (e._stacked = isStacked(e.vScale, e)),
            this.addElements(),
            this.options.fill &&
                !this.chart.isPluginEnabled("filler") &&
                console.warn(
                    "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
                );
    }
    updateIndex(e) {
        this.index !== e && clearStacks(this._cachedMeta), (this.index = e);
    }
    linkScales() {
        const e = this.chart,
            t = this._cachedMeta,
            n = this.getDataset(),
            r = (e, t, n, r) => ("x" === e ? t : "r" === e ? r : n),
            i = (t.xAxisID = valueOrDefault(
                n.xAxisID,
                getFirstScaleId(e, "x")
            )),
            s = (t.yAxisID = valueOrDefault(
                n.yAxisID,
                getFirstScaleId(e, "y")
            )),
            a = (t.rAxisID = valueOrDefault(
                n.rAxisID,
                getFirstScaleId(e, "r")
            )),
            o = t.indexAxis,
            l = (t.iAxisID = r(o, i, s, a)),
            c = (t.vAxisID = r(o, s, i, a));
        (t.xScale = this.getScaleForId(i)),
            (t.yScale = this.getScaleForId(s)),
            (t.rScale = this.getScaleForId(a)),
            (t.iScale = this.getScaleForId(l)),
            (t.vScale = this.getScaleForId(c));
    }
    getDataset() {
        return this.chart.data.datasets[this.index];
    }
    getMeta() {
        return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(e) {
        return this.chart.scales[e];
    }
    _getOtherScale(e) {
        const t = this._cachedMeta;
        return e === t.iScale ? t.vScale : t.iScale;
    }
    reset() {
        this._update("reset");
    }
    _destroy() {
        const e = this._cachedMeta;
        this._data && unlistenArrayEvents(this._data, this),
            e._stacked && clearStacks(e);
    }
    _dataCheck() {
        const e = this.getDataset(),
            t = e.data || (e.data = []),
            n = this._data;
        if (isObject(t)) {
            const e = this._cachedMeta;
            this._data = convertObjectDataToArray(t, e);
        } else if (n !== t) {
            if (n) {
                unlistenArrayEvents(n, this);
                const e = this._cachedMeta;
                clearStacks(e), (e._parsed = []);
            }
            t && Object.isExtensible(t) && listenArrayEvents(t, this),
                (this._syncList = []),
                (this._data = t);
        }
    }
    addElements() {
        const e = this._cachedMeta;
        this._dataCheck(),
            this.datasetElementType &&
                (e.dataset = new this.datasetElementType());
    }
    buildOrUpdateElements(e) {
        const t = this._cachedMeta,
            n = this.getDataset();
        let r = !1;
        this._dataCheck();
        const i = t._stacked;
        (t._stacked = isStacked(t.vScale, t)),
            t.stack !== n.stack &&
                ((r = !0), clearStacks(t), (t.stack = n.stack)),
            this._resyncElements(e),
            (r || i !== t._stacked) && updateStacks(this, t._parsed);
    }
    configure() {
        const e = this.chart.config,
            t = e.datasetScopeKeys(this._type),
            n = e.getOptionScopes(this.getDataset(), t, !0);
        (this.options = e.createResolver(n, this.getContext())),
            (this._parsing = this.options.parsing),
            (this._cachedDataOpts = {});
    }
    parse(e, t) {
        const { _cachedMeta: n, _data: r } = this,
            { iScale: i, _stacked: s } = n,
            a = i.axis;
        let o,
            l,
            c,
            u = (0 === e && t === r.length) || n._sorted,
            d = e > 0 && n._parsed[e - 1];
        if (!1 === this._parsing) (n._parsed = r), (n._sorted = !0), (c = r);
        else {
            c = isArray(r[e])
                ? this.parseArrayData(n, r, e, t)
                : isObject(r[e])
                ? this.parseObjectData(n, r, e, t)
                : this.parsePrimitiveData(n, r, e, t);
            const i = () => null === l[a] || (d && l[a] < d[a]);
            for (o = 0; o < t; ++o)
                (n._parsed[o + e] = l = c[o]), u && (i() && (u = !1), (d = l));
            n._sorted = u;
        }
        s && updateStacks(this, c);
    }
    parsePrimitiveData(e, t, n, r) {
        const { iScale: i, vScale: s } = e,
            a = i.axis,
            o = s.axis,
            l = i.getLabels(),
            c = i === s,
            u = new Array(r);
        let d, p, h;
        for (d = 0, p = r; d < p; ++d)
            (h = d + n),
                (u[d] = { [a]: c || i.parse(l[h], h), [o]: s.parse(t[h], h) });
        return u;
    }
    parseArrayData(e, t, n, r) {
        const { xScale: i, yScale: s } = e,
            a = new Array(r);
        let o, l, c, u;
        for (o = 0, l = r; o < l; ++o)
            (c = o + n),
                (u = t[c]),
                (a[o] = { x: i.parse(u[0], c), y: s.parse(u[1], c) });
        return a;
    }
    parseObjectData(e, t, n, r) {
        const { xScale: i, yScale: s } = e,
            { xAxisKey: a = "x", yAxisKey: o = "y" } = this._parsing,
            l = new Array(r);
        let c, u, d, p;
        for (c = 0, u = r; c < u; ++c)
            (d = c + n),
                (p = t[d]),
                (l[c] = {
                    x: i.parse(resolveObjectKey(p, a), d),
                    y: s.parse(resolveObjectKey(p, o), d),
                });
        return l;
    }
    getParsed(e) {
        return this._cachedMeta._parsed[e];
    }
    getDataElement(e) {
        return this._cachedMeta.data[e];
    }
    applyStack(e, t, n) {
        const r = this.chart,
            i = this._cachedMeta,
            s = t[e.axis];
        return applyStack(
            {
                keys: getSortedDatasetIndices(r, !0),
                values: t._stacks[e.axis]._visualValues,
            },
            s,
            i.index,
            { mode: n }
        );
    }
    updateRangeFromParsed(e, t, n, r) {
        const i = n[t.axis];
        let s = null === i ? NaN : i;
        const a = r && n._stacks[t.axis];
        r &&
            a &&
            ((r.values = a), (s = applyStack(r, i, this._cachedMeta.index))),
            (e.min = Math.min(e.min, s)),
            (e.max = Math.max(e.max, s));
    }
    getMinMax(e, t) {
        const n = this._cachedMeta,
            r = n._parsed,
            i = n._sorted && e === n.iScale,
            s = r.length,
            a = this._getOtherScale(e),
            o = createStack$1(t, n, this.chart),
            l = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY,
            },
            { min: c, max: u } = getUserBounds(a);
        let d, p;
        function h() {
            p = r[d];
            const t = p[a.axis];
            return !isNumberFinite(p[e.axis]) || c > t || u < t;
        }
        for (
            d = 0;
            d < s && (h() || (this.updateRangeFromParsed(l, e, p, o), !i));
            ++d
        );
        if (i)
            for (d = s - 1; d >= 0; --d)
                if (!h()) {
                    this.updateRangeFromParsed(l, e, p, o);
                    break;
                }
        return l;
    }
    getAllParsedValues(e) {
        const t = this._cachedMeta._parsed,
            n = [];
        let r, i, s;
        for (r = 0, i = t.length; r < i; ++r)
            (s = t[r][e.axis]), isNumberFinite(s) && n.push(s);
        return n;
    }
    getMaxOverflow() {
        return !1;
    }
    getLabelAndValue(e) {
        const t = this._cachedMeta,
            n = t.iScale,
            r = t.vScale,
            i = this.getParsed(e);
        return {
            label: n ? "" + n.getLabelForValue(i[n.axis]) : "",
            value: r ? "" + r.getLabelForValue(i[r.axis]) : "",
        };
    }
    _update(e) {
        const t = this._cachedMeta;
        this.update(e || "default"),
            (t._clip = toClip(
                valueOrDefault(
                    this.options.clip,
                    defaultClip(t.xScale, t.yScale, this.getMaxOverflow())
                )
            ));
    }
    update(e) {}
    draw() {
        const e = this._ctx,
            t = this.chart,
            n = this._cachedMeta,
            r = n.data || [],
            i = t.chartArea,
            s = [],
            a = this._drawStart || 0,
            o = this._drawCount || r.length - a,
            l = this.options.drawActiveElementsOnTop;
        let c;
        for (n.dataset && n.dataset.draw(e, i, a, o), c = a; c < a + o; ++c) {
            const t = r[c];
            t.hidden || (t.active && l ? s.push(t) : t.draw(e, i));
        }
        for (c = 0; c < s.length; ++c) s[c].draw(e, i);
    }
    getStyle(e, t) {
        const n = t ? "active" : "default";
        return void 0 === e && this._cachedMeta.dataset
            ? this.resolveDatasetElementOptions(n)
            : this.resolveDataElementOptions(e || 0, n);
    }
    getContext(e, t, n) {
        const r = this.getDataset();
        let i;
        if (e >= 0 && e < this._cachedMeta.data.length) {
            const t = this._cachedMeta.data[e];
            (i =
                t.$context ||
                (t.$context = createDataContext(this.getContext(), e, t))),
                (i.parsed = this.getParsed(e)),
                (i.raw = r.data[e]),
                (i.index = i.dataIndex = e);
        } else
            (i =
                this.$context ||
                (this.$context = createDatasetContext(
                    this.chart.getContext(),
                    this.index
                ))),
                (i.dataset = r),
                (i.index = i.datasetIndex = this.index);
        return (i.active = !!t), (i.mode = n), i;
    }
    resolveDatasetElementOptions(e) {
        return this._resolveElementOptions(this.datasetElementType.id, e);
    }
    resolveDataElementOptions(e, t) {
        return this._resolveElementOptions(this.dataElementType.id, t, e);
    }
    _resolveElementOptions(e, t = "default", n) {
        const r = "active" === t,
            i = this._cachedDataOpts,
            s = e + "-" + t,
            a = i[s],
            o = this.enableOptionSharing && defined(n);
        if (a) return cloneIfNotShared(a, o);
        const l = this.chart.config,
            c = l.datasetElementScopeKeys(this._type, e),
            u = r ? [`${e}Hover`, "hover", e, ""] : [e, ""],
            d = l.getOptionScopes(this.getDataset(), c),
            p = Object.keys(defaults.elements[e]),
            h = l.resolveNamedOptions(d, p, () => this.getContext(n, r, t), u);
        return (
            h.$shared &&
                ((h.$shared = o),
                (i[s] = Object.freeze(cloneIfNotShared(h, o)))),
            h
        );
    }
    _resolveAnimations(e, t, n) {
        const r = this.chart,
            i = this._cachedDataOpts,
            s = `animation-${t}`,
            a = i[s];
        if (a) return a;
        let o;
        if (!1 !== r.options.animation) {
            const r = this.chart.config,
                i = r.datasetAnimationScopeKeys(this._type, t),
                s = r.getOptionScopes(this.getDataset(), i);
            o = r.createResolver(s, this.getContext(e, n, t));
        }
        const l = new Animations(r, o && o.animations);
        return o && o._cacheable && (i[s] = Object.freeze(l)), l;
    }
    getSharedOptions(e) {
        if (e.$shared)
            return (
                this._sharedOptions ||
                (this._sharedOptions = Object.assign({}, e))
            );
    }
    includeOptions(e, t) {
        return !t || isDirectUpdateMode(e) || this.chart._animationsDisabled;
    }
    _getSharedOptions(e, t) {
        const n = this.resolveDataElementOptions(e, t),
            r = this._sharedOptions,
            i = this.getSharedOptions(n),
            s = this.includeOptions(t, i) || i !== r;
        return (
            this.updateSharedOptions(i, t, n),
            { sharedOptions: i, includeOptions: s }
        );
    }
    updateElement(e, t, n, r) {
        isDirectUpdateMode(r)
            ? Object.assign(e, n)
            : this._resolveAnimations(t, r).update(e, n);
    }
    updateSharedOptions(e, t, n) {
        e &&
            !isDirectUpdateMode(t) &&
            this._resolveAnimations(void 0, t).update(e, n);
    }
    _setStyle(e, t, n, r) {
        e.active = r;
        const i = this.getStyle(t, r);
        this._resolveAnimations(t, n, r).update(e, {
            options: (!r && this.getSharedOptions(i)) || i,
        });
    }
    removeHoverStyle(e, t, n) {
        this._setStyle(e, n, "active", !1);
    }
    setHoverStyle(e, t, n) {
        this._setStyle(e, n, "active", !0);
    }
    _removeDatasetHoverStyle() {
        const e = this._cachedMeta.dataset;
        e && this._setStyle(e, void 0, "active", !1);
    }
    _setDatasetHoverStyle() {
        const e = this._cachedMeta.dataset;
        e && this._setStyle(e, void 0, "active", !0);
    }
    _resyncElements(e) {
        const t = this._data,
            n = this._cachedMeta.data;
        for (const [a, o, l] of this._syncList) this[a](o, l);
        this._syncList = [];
        const r = n.length,
            i = t.length,
            s = Math.min(i, r);
        s && this.parse(0, s),
            i > r
                ? this._insertElements(r, i - r, e)
                : i < r && this._removeElements(i, r - i);
    }
    _insertElements(e, t, n = !0) {
        const r = this._cachedMeta,
            i = r.data,
            s = e + t;
        let a;
        const o = (e) => {
            for (e.length += t, a = e.length - 1; a >= s; a--) e[a] = e[a - t];
        };
        for (o(i), a = e; a < s; ++a) i[a] = new this.dataElementType();
        this._parsing && o(r._parsed),
            this.parse(e, t),
            n && this.updateElements(i, e, t, "reset");
    }
    updateElements(e, t, n, r) {}
    _removeElements(e, t) {
        const n = this._cachedMeta;
        if (this._parsing) {
            const r = n._parsed.splice(e, t);
            n._stacked && clearStacks(n, r);
        }
        n.data.splice(e, t);
    }
    _sync(e) {
        if (this._parsing) this._syncList.push(e);
        else {
            const [t, n, r] = e;
            this[t](n, r);
        }
        this.chart._dataChanges.push([this.index, ...e]);
    }
    _onDataPush() {
        const e = arguments.length;
        this._sync(["_insertElements", this.getDataset().data.length - e, e]);
    }
    _onDataPop() {
        this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
    }
    _onDataShift() {
        this._sync(["_removeElements", 0, 1]);
    }
    _onDataSplice(e, t) {
        t && this._sync(["_removeElements", e, t]);
        const n = arguments.length - 2;
        n && this._sync(["_insertElements", e, n]);
    }
    _onDataUnshift() {
        this._sync(["_insertElements", 0, arguments.length]);
    }
}
function getAllScaleValues(e, t) {
    if (!e._cache.$bar) {
        const n = e.getMatchingVisibleMetas(t);
        let r = [];
        for (let t = 0, i = n.length; t < i; t++)
            r = r.concat(n[t].controller.getAllParsedValues(e));
        e._cache.$bar = _arrayUnique(r.sort((e, t) => e - t));
    }
    return e._cache.$bar;
}
function computeMinSampleSize(e) {
    const t = e.iScale,
        n = getAllScaleValues(t, e.type);
    let r,
        i,
        s,
        a,
        o = t._length;
    const l = () => {
        32767 !== s &&
            -32768 !== s &&
            (defined(a) && (o = Math.min(o, Math.abs(s - a) || o)), (a = s));
    };
    for (r = 0, i = n.length; r < i; ++r) (s = t.getPixelForValue(n[r])), l();
    for (a = void 0, r = 0, i = t.ticks.length; r < i; ++r)
        (s = t.getPixelForTick(r)), l();
    return o;
}
function computeFitCategoryTraits(e, t, n, r) {
    const i = n.barThickness;
    let s, a;
    return (
        isNullOrUndef(i)
            ? ((s = t.min * n.categoryPercentage), (a = n.barPercentage))
            : ((s = i * r), (a = 1)),
        { chunk: s / r, ratio: a, start: t.pixels[e] - s / 2 }
    );
}
function computeFlexCategoryTraits(e, t, n, r) {
    const i = t.pixels,
        s = i[e];
    let a = e > 0 ? i[e - 1] : null,
        o = e < i.length - 1 ? i[e + 1] : null;
    const l = n.categoryPercentage;
    null === a && (a = s - (null === o ? t.end - t.start : o - s)),
        null === o && (o = s + s - a);
    const c = s - ((s - Math.min(a, o)) / 2) * l;
    return {
        chunk: ((Math.abs(o - a) / 2) * l) / r,
        ratio: n.barPercentage,
        start: c,
    };
}
function parseFloatBar(e, t, n, r) {
    const i = n.parse(e[0], r),
        s = n.parse(e[1], r),
        a = Math.min(i, s),
        o = Math.max(i, s);
    let l = a,
        c = o;
    Math.abs(a) > Math.abs(o) && ((l = o), (c = a)),
        (t[n.axis] = c),
        (t._custom = {
            barStart: l,
            barEnd: c,
            start: i,
            end: s,
            min: a,
            max: o,
        });
}
function parseValue(e, t, n, r) {
    return (
        isArray(e) ? parseFloatBar(e, t, n, r) : (t[n.axis] = n.parse(e, r)), t
    );
}
function parseArrayOrPrimitive(e, t, n, r) {
    const i = e.iScale,
        s = e.vScale,
        a = i.getLabels(),
        o = i === s,
        l = [];
    let c, u, d, p;
    for (c = n, u = n + r; c < u; ++c)
        (p = t[c]),
            (d = {}),
            (d[i.axis] = o || i.parse(a[c], c)),
            l.push(parseValue(p, d, s, c));
    return l;
}
function isFloatBar(e) {
    return e && void 0 !== e.barStart && void 0 !== e.barEnd;
}
function barSign(e, t, n) {
    return 0 !== e
        ? sign(e)
        : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1);
}
function borderProps(e) {
    let t, n, r, i, s;
    return (
        e.horizontal
            ? ((t = e.base > e.x), (n = "left"), (r = "right"))
            : ((t = e.base < e.y), (n = "bottom"), (r = "top")),
        t ? ((i = "end"), (s = "start")) : ((i = "start"), (s = "end")),
        { start: n, end: r, reverse: t, top: i, bottom: s }
    );
}
function setBorderSkipped(e, t, n, r) {
    let i = t.borderSkipped;
    const s = {};
    if (!i) return void (e.borderSkipped = s);
    if (!0 === i)
        return void (e.borderSkipped = {
            top: !0,
            right: !0,
            bottom: !0,
            left: !0,
        });
    const { start: a, end: o, reverse: l, top: c, bottom: u } = borderProps(e);
    "middle" === i &&
        n &&
        ((e.enableBorderRadius = !0),
        (n._top || 0) === r
            ? (i = c)
            : (n._bottom || 0) === r
            ? (i = u)
            : ((s[parseEdge(u, a, o, l)] = !0), (i = c))),
        (s[parseEdge(i, a, o, l)] = !0),
        (e.borderSkipped = s);
}
function parseEdge(e, t, n, r) {
    return (e = r ? startEnd((e = swap(e, t, n)), n, t) : startEnd(e, t, n));
}
function swap(e, t, n) {
    return e === t ? n : e === n ? t : e;
}
function startEnd(e, t, n) {
    return "start" === e ? t : "end" === e ? n : e;
}
function setInflateAmount(e, { inflateAmount: t }, n) {
    e.inflateAmount = "auto" === t ? (1 === n ? 0.33 : 0) : t;
}
__publicField(DatasetController, "defaults", {}),
    __publicField(DatasetController, "datasetElementType", null),
    __publicField(DatasetController, "dataElementType", null);
class BarController extends DatasetController {
    parsePrimitiveData(e, t, n, r) {
        return parseArrayOrPrimitive(e, t, n, r);
    }
    parseArrayData(e, t, n, r) {
        return parseArrayOrPrimitive(e, t, n, r);
    }
    parseObjectData(e, t, n, r) {
        const { iScale: i, vScale: s } = e,
            { xAxisKey: a = "x", yAxisKey: o = "y" } = this._parsing,
            l = "x" === i.axis ? a : o,
            c = "x" === s.axis ? a : o,
            u = [];
        let d, p, h, f;
        for (d = n, p = n + r; d < p; ++d)
            (f = t[d]),
                (h = {}),
                (h[i.axis] = i.parse(resolveObjectKey(f, l), d)),
                u.push(parseValue(resolveObjectKey(f, c), h, s, d));
        return u;
    }
    updateRangeFromParsed(date(),
            (this.maxWidth = e),
            (this.maxHeight = t),
            (this._margins = n =
                Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, n)),
            (this.ticks = null),
            (this._labelSizes = null),
            (this._gridLineItems = null),
            (this._labelItems = null),
            this.beforeSetDimensions(),
            this.setDimensions(),
            this.afterSetDimensions(),
            (this._maxLength = this.isHorizontal()
                ? this.width + n.left + n.right
                : this.height + n.top + n.bottom),
            this._dataLimitsCached ||
                (this.beforeDataLimits(),
                this.determineDataLimits(),
                this.afterDataLimits(),
                (this._range = _addGrace(this, i, r)),
                (this._dataLimitsCached = !0)),
            this.beforeBuildTicks(),
            (this.ticks = this.buildTicks() || []),
            this.afterBuildTicks();
        const o = a < this.ticks.length;
        this._convertTicksToLabels(o ? sample(this.ticks, a) : this.ticks),
            this.configure(),
            this.beforeCalculateLabelRotation(),
            this.calculateLabelRotation(),
            this.afterCalculateLabelRotation(),
            s.display &&
                (s.autoSkip || "auto" === s.source) &&
                ((this.ticks = autoSkip(this, this.ticks)),
                (this._labelSizes = null),
                this.afterAutoSkip()),
            o && this._convertTicksToLabels(this.ticks),
            this.beforeFit(),
            this.fit(),
            this.afterFit(),
            this.afterUpdate();
    }
    configure() {
        let e,
            t,
            n = this.options.reverse;
        this.isHorizontal()
            ? ((e = this.left), (t = this.right))
            : ((e = this.top), (t = this.bottom), (n = !n)),
            (this._startPixel = e),
            (this._endPixel = t),
            (this._reversePixels = n),
            (this._length = t - e),
            (this._alignToPixels = this.options.alignToPixels);
    }
    afterUpdate() {
        callback(this.options.afterUpdate, [this]);
    }
    beforeSetDimensions() {
        callback(this.options.beforeSetDimensions, [this]);
    }
    setDimensions() {
        this.isHorizontal()
            ? ((this.width = this.maxWidth),
              (this.left = 0),
              (this.right = this.width))
            : ((this.height = this.maxHeight),
              (this.top = 0),
              (this.bottom = this.height)),
            (this.paddingLeft = 0),
            (this.paddingTop = 0),
            (this.paddingRight = 0),
            (this.paddingBottom = 0);
    }
    afterSetDimensions() {
        callback(this.options.afterSetDimensions, [this]);
    }
    _callHooks(e) {
        this.chart.notifyPlugins(e, this.getContext()),
            callback(this.options[e], [this]);
    }
    beforeDataLimits() {
        this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {}
    afterDataLimits() {
        this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
        this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
        return [];
    }
    afterBuildTicks() {
        this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
        callback(this.options.beforeTickToLabelConversion, [this]);
    }
    generateTickLabels(e) {
        const t = this.options.ticks;
        let n, r, i;
        for (n = 0, r = e.length; n < r; n++)
            (i = e[n]), (i.label = callback(t.callback, [i.value, n, e], this));
    }
    afterTickToLabelConversion() {
        callback(this.options.afterTickToLabelConversion, [this]);
    }
    beforeCalculateLabelRotation() {
        callback(this.options.beforeCalculateLabelRotation, [this]);
    }
    calculateLabelRotation() {
        const e = this.options,
            t = e.ticks,
            n = getTicksLimit(this.ticks.length, e.ticks.maxTicksLimit),
            r = t.minRotation || 0,
            i = t.maxRotation;
        let s,
            a,
            o,
            l = r;
        if (
            !this._isVisible() ||
            !t.display ||
            r >= i ||
            n <= 1 ||
            !this.isHorizontal()
        )
            return void (this.labelRotation = r);
        const c = this._getLabelSizes(),
            u = c.widest.width,
            d = c.highest.height,
            p = _limitValue(this.chart.width - u, 0, this.maxWidth);
        (s = e.offset ? this.maxWidth / n : p / (n - 1)),
            u + 6 > s &&
                ((s = p / (n - (e.offset ? 0.5 : 1))),
                (a =
                    this.maxHeight -
                    getTickMarkLength(e.grid) -
                    t.padding -
                    getTitleHeight(e.title, this.chart.options.font)),
                (o = Math.sqrt(u * u + d * d)),
                (l = toDegrees(
                    Math.min(
                        Math.asin(
                            _limitValue((c.highest.height + 6) / s, -1, 1)
                        ),
                        Math.asin(_limitValue(a / o, -1, 1)) -
                            Math.asin(_limitValue(d / o, -1, 1))
                    )
                )),
                (l = Math.max(r, Math.min(i, l)))),
            (this.labelRotation = l);
    }
    afterCalculateLabelRotation() {
        callback(this.options.afterCalculateLabelRotation, [this]);
    }
    afterAutoSkip() {}
    beforeFit() {
        callback(this.options.beforeFit, [this]);
    }
    fit() {
        const e = { width: 0, height: 0 },
            {
                chart: t,
                options: { ticks: n, title: r, grid: i },
            } = this,
            s = this._isVisible(),
            a = this.isHorizontal();
        if (s) {
            const s = getTitleHeight(r, t.options.font);
            if (
                (a
                    ? ((e.width = this.maxWidth),
                      (e.height = getTickMarkLength(i) + s))
                    : ((e.height = this.maxHeight),
                      (e.width = getTickMarkLength(i) + s)),
                n.display && this.ticks.length)
            ) {
                const {
                        first: t,
                        last: r,
                        widest: i,
                        highest: s,
                    } = this._getLabelSizes(),
                    o = 2 * n.padding,
                    l = toRadians(this.labelRotation),
                    c = Math.cos(l),
                    u = Math.sin(l);
                if (a) {
                    const t = n.mirror ? 0 : u * i.width + c * s.height;
                    e.height = Math.min(this.maxHeight, e.height + t + o);
                } else {
                    const t = n.mirror ? 0 : c * i.width + u * s.height;
                    e.width = Math.min(this.maxWidth, e.width + t + o);
                }
                this._calculatePadding(t, r, u, c);
            }
        }
        this._handleMargins(),
            a
                ? ((this.width = this._length =
                      t.width - this._margins.left - this._margins.right),
                  (this.height = e.height))
                : ((this.width = e.width),
                  (this.height = this._length =
                      t.height - this._margins.top - this._margins.bottom));
    }
    _calculatePadding(e, t, n, r) {
        const {
                ticks: { align: i, padding: s },
                position: a,
            } = this.options,
            o = 0 !== this.labelRotation,
            l = "top" !== a && "x" === this.axis;
        if (this.isHorizontal()) {
            const a = this.getPixelForTick(0) - this.left,
                c = this.right - this.getPixelForTick(this.ticks.length - 1);
            let u = 0,
                d = 0;
            o
                ? l
                    ? ((u = r * e.width), (d = n * t.height))
                    : ((u = n * e.height), (d = r * t.width))
                : "start" === i
                ? (d = t.width)
                : "end" === i
                ? (u = e.width)
                : "inner" !== i && ((u = e.width / 2), (d = t.width / 2)),
                (this.paddingLeft = Math.max(
                    ((u - a + s) * this.width) / (this.width - a),
                    0
                )),
                (this.paddingRight = Math.max(
                    ((d - c + s) * this.width) / (this.width - c),
                    0
                ));
        } else {
            let n = t.height / 2,
                r = e.height / 2;
            "start" === i
                ? ((n = 0), (r = e.height))
                : "end" === i && ((n = t.height), (r = 0)),
                (this.paddingTop = n + s),
                (this.paddingBottom = r + s);
        }
    }
    _handleMargins() {
        this._margins &&
            ((this._margins.left = Math.max(
                this.paddingLeft,
                this._margins.left
            )),
            (this._margins.top = Math.max(this.paddingTop, this._margins.top)),
            (this._margins.right = Math.max(
                this.paddingRight,
                this._margins.right
            )),
            (this._margins.bottom = Math.max(
                this.paddingBottom,
                this._margins.bottom
            )));
    }
    afterFit() {
        callback(this.options.afterFit, [this]);
    }
    isHorizontal() {
        const { axis: e, position: t } = this.options;
        return "top" === t || "bottom" === t || "x" === e;
    }
    isFullSize() {
        return this.options.fullSize;
    }
    _convertTicksToLabels(e) {
        let t, n;
        for (
            this.beforeTickToLabelConversion(),
                this.generateTickLabels(e),
                t = 0,
                n = e.length;
            t < n;
            t++
        )
            isNullOrUndef(e[t].label) && (e.splice(t, 1), n--, t--);
        this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
        let e = this._labelSizes;
        if (!e) {
            const t = this.options.ticks.sampleSize;
            let n = this.ticks;
            t < n.length && (n = sample(n, t)),
                (this._labelSizes = e =
                    this._computeLabelSizes(
                        n,
                        n.length,
                        this.options.ticks.maxTicksLimit
                    ));
        }
        return e;
    }
    _computeLabelSizes(e, t, n) {
        const { ctx: r, _longestTextCache: i } = this,
            s = [],
            a = [],
            o = Math.floor(t / getTicksLimit(t, n));
        let l,
            c,
            u,
            d,
            p,
            h,
            f,
            m,
            g,
            x,
            v,
            b = 0,
            y = 0;
        for (l = 0; l < t; l += o) {
            if (
                ((d = e[l].label),
                (p = this._resolveTickFontOptions(l)),
                (r.font = h = p.string),
                (f = i[h] = i[h] || { data: {}, gc: [] }),
                (m = p.lineHeight),
                (g = x = 0),
                isNullOrUndef(d) || isArray(d))
            ) {
                if (isArray(d))
                    for (c = 0, u = d.length; c < u; ++c)
                        (v = d[c]),
                            isNullOrUndef(v) ||
                                isArray(v) ||
                                ((g = _measureText(r, f.data, f.gc, g, v)),
                                (x += m));
            } else (g = _measureText(r, f.data, f.gc, g, d)), (x = m);
            s.push(g), a.push(x), (b = Math.max(g, b)), (y = Math.max(x, y));
        }
        garbageCollect(i, t);
        const _ = s.indexOf(b),
            E = a.indexOf(y),
            S = (e) => ({ width: s[e] || 0, height: a[e] || 0 });
        return {
            first: S(0),
            last: S(t - 1),
            widest: S(_),
            highest: S(E),
            widths: s,
            heights: a,
        };
    }
    getLabelForValue(e) {
        return e;
    }
    getPixelForValue(e, t) {
        return NaN;
    }
    getValueForPixel(e) {}
    getPixelForTick(e) {
        const t = this.ticks;
        return e < 0 || e > t.length - 1
            ? null
            : this.getPixelForValue(t[e].value);
    }
    getPixelForDecimal(e) {
        this._reversePixels && (e = 1 - e);
        const t = this._startPixel + e * this._length;
        return _int16Range(
            this._alignToPixels ? _alignPixel(this.chart, t, 0) : t
        );
    }
    getDecimalForPixel(e) {
        const t = (e - this._startPixel) / this._length;
        return this._reversePixels ? 1 - t : t;
    }
    getBasePixel() {
        return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
        const { min: e, max: t } = this;
        return e < 0 && t < 0 ? t : e > 0 && t > 0 ? e : 0;
    }
    getContext(e) {
        const t = this.ticks || [];
        if (e >= 0 && e < t.length) {
            const n = t[e];
            return (
                n.$context ||
                (n.$context = createTickContext(this.getContext(), e, n))
            );
        }
        return (
            this.$context ||
            (this.$context = createScaleContext(this.chart.getContext(), this))
        );
    }
    _tickSize() {
        const e = this.options.ticks,
            t = toRadians(this.labelRotation),
            n = Math.abs(Math.cos(t)),
            r = Math.abs(Math.sin(t)),
            i = this._getLabelSizes(),
            s = e.autoSkipPadding || 0,
            a = i ? i.widest.width + s : 0,
            o = i ? i.highest.height + s : 0;
        return this.isHorizontal()
            ? o * n > a * r
                ? a / n
                : o / r
            : o * r < a * n
            ? o / n
            : a / r;
    }
    _isVisible() {
        const e = this.options.display;
        return "auto" !== e ? !!e : this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(e) {
        const t = this.axis,
            n = this.chart,
            r = this.options,
            { grid: i, position: s, border: a } = r,
            o = i.offset,
            l = this.isHorizontal(),
            c = this.ticks.length + (o ? 1 : 0),
            u = getTickMarkLength(i),
            d = [],
            p = a.setContext(this.getContext()),
            h = p.display ? p.width : 0,
            f = h / 2,
            m = function (e) {
                return _alignPixel(n, e, h);
            };
        let g, x, v, b, y, _, E, S, w, A, R, C;
        if ("top" === s)
            (g = m(this.bottom)),
                (_ = this.bottom - u),
                (S = g - f),
                (A = m(e.top) + f),
                (C = e.bottom);
        else if ("bottom" === s)
            (g = m(this.top)),
                (A = e.top),
                (C = m(e.bottom) - f),
                (_ = g + f),
                (S = this.top + u);
        else if ("left" === s)
            (g = m(this.right)),
                (y = this.right - u),
                (E = g - f),
                (w = m(e.left) + f),
                (R = e.right);
        else if ("right" === s)
            (g = m(this.left)),
                (w = e.left),
                (R = m(e.right) - f),
                (y = g + f),
                (E = this.left + u);
        else if ("x" === t) {
            if ("center" === s) g = m((e.top + e.bottom) / 2 + 0.5);
            else if (isObject(s)) {
                const e = Object.keys(s)[0],
                    t = s[e];
                g = m(this.chart.scales[e].getPixelForValue(t));
            }
            (A = e.top), (C = e.bottom), (_ = g + f), (S = _ + u);
        } else if ("y" === t) {
            if ("center" === s) g = m((e.left + e.right) / 2);
            else if (isObject(s)) {
                const e = Object.keys(s)[0],
                    t = s[e];
                g = m(this.chart.scales[e].getPixelForValue(t));
            }
            (y = g - f), (E = y - u), (w = e.left), (R = e.right);
        }
        const j = valueOrDefault(r.ticks.maxTicksLimit, c),
            k = Math.max(1, Math.ceil(c / j));
        for (x = 0; x < c; x += k) {
            const e = this.getContext(x),
                t = i.setContext(e),
                r = a.setContext(e),
                s = t.lineWidth,
                c = t.color,
                u = r.dash || [],
                p = r.dashOffset,
                h = t.tickWidth,
                f = t.tickColor,
                m = t.tickBorderDash || [],
                g = t.tickBorderDashOffset;
            (v = getPixelForGridLine(this, x, o)),
                void 0 !== v &&
                    ((b = _alignPixel(n, v, s)),
                    l ? (y = E = w = R = b) : (_ = S = A = C = b),
                    d.push({
                        tx1: y,
                        ty1: _,
                        tx2: E,
                        ty2: S,
                        x1: w,
                        y1: A,
                        x2: R,
                        y2: C,
                        width: s,
                        color: c,
                        borderDash: u,
                        borderDashOffset: p,
                        tickWidth: h,
                        tickColor: f,
                        tickBorderDash: m,
                        tickBorderDashOffset: g,
                    }));
        }
        return (this._ticksLength = c), (this._borderValue = g), d;
    }
    _computeLabelItems(e) {
        const t = this.axis,
            n = this.options,
            { position: r, ticks: i } = n,
            s = this.isHorizontal(),
            a = this.ticks,
            { align: o, crossAlign: l, padding: c, mirror: u } = i,
            d = getTickMarkLength(n.grid),
            p = d + c,
            h = u ? -c : p,
            f = -toRadians(this.labelRotation),
            m = [];
        let g,
            x,
            v,
            b,
            y,
            _,
            E,
            S,
            w,
            A,
            R,
            C,
            j = "middle";
        if ("top" === r)
            (_ = this.bottom - h), (E = this._getXAxisLabelAlignment());
        else if ("bottom" === r)
            (_ = this.top + h), (E = this._getXAxisLabelAlignment());
        else if ("left" === r) {
            const e = this._getYAxisLabelAlignment(d);
            (E = e.textAlign), (y = e.x);
        } else if ("right" === r) {
            const e = this._getYAxisLabelAlignment(d);
            (E = e.textAlign), (y = e.x);
        } else if ("x" === t) {
            if ("center" === r) _ = (e.top + e.bottom) / 2 + p;
            else if (isObject(r)) {
                const e = Object.keys(r)[0],
                    t = r[e];
                _ = this.chart.scales[e].getPixelForValue(t) + p;
            }
            E = this._getXAxisLabelAlignment();
        } else if ("y" === t) {
            if ("center" === r) y = (e.left + e.right) / 2 - p;
            else if (isObject(r)) {
                const e = Object.keys(r)[0],
                    t = r[e];
                y = this.chart.scales[e].getPixelForValue(t);
            }
            E = this._getYAxisLabelAlignment(d).textAlign;
        }
        "y" === t &&
            ("start" === o ? (j = "top") : "end" === o && (j = "bottom"));
        const k = this._getLabelSizes();
        for (g = 0, x = a.length; g < x; ++g) {
            (v = a[g]), (b = v.label);
            const e = i.setContext(this.getContext(g));
            (S = this.getPixelForTick(g) + i.labelOffset),
                (w = this._resolveTickFontOptions(g)),
                (A = w.lineHeight),
                (R = isArray(b) ? b.length : 1);
            const t = R / 2,
                n = e.color,
                o = e.textStrokeColor,
                c = e.textStrokeWidth;
            let d,
                p = E;
            if (
                (s
                    ? ((y = S),
                      "inner" === E &&
                          (p =
                              g === x - 1
                                  ? this.options.reverse
                                      ? "left"
                                      : "right"
                                  : 0 === g
                                  ? this.options.reverse
                                      ? "right"
                                      : "left"
                                  : "center"),
                      (C =
                          "top" === r
                              ? "near" === l || 0 !== f
                                  ? -R * A + A / 2
                                  : "center" === l
                                  ? -k.highest.height / 2 - t * A + A
                                  : -k.highest.height + A / 2
                              : "near" === l || 0 !== f
                              ? A / 2
                              : "center" === l
                              ? k.highest.height / 2 - t * A
                              : k.highest.height - R * A),
                      u && (C *= -1),
                      0 === f ||
                          e.showLabelBackdrop ||
                          (y += (A / 2) * Math.sin(f)))
                    : ((_ = S), (C = ((1 - R) * A) / 2)),
                e.showLabelBackdrop)
            ) {
                const t = toPadding(e.backdropPadding),
                    n = k.heights[g],
                    r = k.widths[g];
                let i = C - t.top,
                    s = 0 - t.left;
                switch (j) {
                    case "middle":
                        i -= n / 2;
                        break;
                    case "bottom":
                        i -= n;
                }
                switch (E) {
                    case "center":
                        s -= r / 2;
                        break;
                    case "right":
                        s -= r;
                        break;
                    case "inner":
                        g === x - 1 ? (s -= r) : g > 0 && (s -= r / 2);
                }
                d = {
                    left: s,
                    top: i,
                    width: r + t.width,
                    height: n + t.height,
                    color: e.backdropColor,
                };
            }
            m.push({
                label: b,
                font: w,
                textOffset: C,
                options: {
                    rotation: f,
                    color: n,
                    strokeColor: o,
                    strokeWidth: c,
                    textAlign: p,
                    textBaseline: j,
                    translation: [y, _],
                    backdrop: d,
                },
            });
        }
        return m;
    }
    _getXAxisLabelAlignment() {
        const { position: e, ticks: t } = this.options;
        if (-toRadians(this.labelRotation))
            return "top" === e ? "left" : "right";
        let n = "center";
        return (
            "start" === t.align
                ? (n = "left")
                : "end" === t.align
                ? (n = "right")
                : "inner" === t.align && (n = "inner"),
            n
        );
    }
    _getYAxisLabelAlignment(e) {
        const {
                position: t,
                ticks: { crossAlign: n, mirror: r, padding: i },
            } = this.options,
            s = e + i,
            a = this._getLabelSizes().widest.width;
        let o, l;
        return (
            "left" === t
                ? r
                    ? ((l = this.right + i),
                      "near" === n
                          ? (o = "left")
                          : "center" === n
                          ? ((o = "center"), (l += a / 2))
                          : ((o = "right"), (l += a)))
                    : ((l = this.right - s),
                      "near" === n
                          ? (o = "right")
                          : "center" === n
                          ? ((o = "center"), (l -= a / 2))
                          : ((o = "left"), (l = this.left)))
                : "right" === t
                ? r
                    ? ((l = this.left + i),
                      "near" === n
                          ? (o = "right")
                          : "center" === n
                          ? ((o = "center"), (l -= a / 2))
                          : ((o = "left"), (l -= a)))
                    : ((l = this.left + s),
                      "near" === n
                          ? (o = "left")
                          : "center" === n
                          ? ((o = "center"), (l += a / 2))
                          : ((o = "right"), (l = this.right)))
                : (o = "right"),
            { textAlign: o, x: l }
        );
    }
    _computeLabelArea() {
        if (this.options.ticks.mirror) return;
        const e = this.chart,
            t = this.options.position;
        return "left" === t || "right" === t
            ? { top: 0, left: this.left, bottom: e.height, right: this.right }
            : "top" === t || "bottom" === t
            ? { top: this.top, left: 0, bottom: this.bottom, right: e.width }
            : void 0;
    }
    drawBackground() {
        const {
            ctx: e,
            options: { backgroundColor: t },
            left: n,
            top: r,
            width: i,
            height: s,
        } = this;
        t && (e.save(), (e.fillStyle = t), e.fillRect(n, r, i, s), e.restore());
    }
    getLineWidthForValue(e) {
        const t = this.options.grid;
        if (!this._isVisible() || !t.display) return 0;
        const n = this.ticks.findIndex((t) => t.value === e);
        if (n >= 0) {
            return t.setContext(this.getContext(n)).lineWidth;
        }
        return 0;
    }
    drawGrid(e) {
        const t = this.options.grid,
            n = this.ctx,
            r =
                this._gridLineItems ||
                (this._gridLineItems = this._computeGridLineItems(e));
        let i, s;
        const a = (e, t, r) => {
            r.width &&
                r.color &&
                (n.save(),
                (n.lineWidth = r.width),
                (n.strokeStyle = r.color),
                n.setLineDash(r.borderDash || []),
                (n.lineDashOffset = r.borderDashOffset),
                n.beginPath(),
                n.moveTo(e.x, e.y),
                n.lineTo(t.x, t.y),
                n.stroke(),
                n.restore());
        };
        if (t.display)
            for (i = 0, s = r.length; i < s; ++i) {
                const e = r[i];
                t.drawOnChartArea &&
                    a({ x: e.x1, y: e.y1 }, { x: e.x2, y: e.y2 }, e),
                    t.drawTicks &&
                        a(
                            { x: e.tx1, y: e.ty1 },
                            { x: e.tx2, y: e.ty2 },
                            {
                                color: e.tickColor,
                                width: e.tickWidth,
                                borderDash: e.tickBorderDash,
                                borderDashOffset: e.tickBorderDashOffset,
                            }
                        );
            }
    }
    drawBorder() {
        const {
                chart: e,
                ctx: t,
                options: { border: n, grid: r },
            } = this,
            i = n.setContext(this.getContext()),
            s = n.display ? i.width : 0;
        if (!s) return;
        const a = r.setContext(this.getContext(0)).lineWidth,
            o = this._borderValue;
        let l, c, u, d;
        this.isHorizontal()
            ? ((l = _alignPixel(e, this.left, s) - s / 2),
              (c = _alignPixel(e, this.right, a) + a / 2),
              (u = d = o))
            : ((u = _alignPixel(e, this.top, s) - s / 2),
              (d = _alignPixel(e, this.bottom, a) + a / 2),
              (l = c = o)),
            t.save(),
            (t.lineWidth = i.width),
            (t.strokeStyle = i.color),
            t.beginPath(),
            t.moveTo(l, u),
            t.lineTo(c, d),
            t.stroke(),
            t.restore();
    }
    drawLabels(e) {
        if (!this.options.ticks.display) return;
        const t = this.ctx,
            n = this._computeLabelArea();
        n && clipArea(t, n);
        const r = this.getLabelItems(e);
        for (const i of r) {
            const e = i.options,
                n = i.font;
            renderText(t, i.label, 0, i.textOffset, n, e);
        }
        n && unclipArea(t);
    }
    drawTitle() {
        const {
            ctx: e,
            options: { position: t, title: n, reverse: r },
        } = this;
        if (!n.display) return;
        const i = toFont(n.font),
            s = toPadding(n.padding),
            a = n.align;
        let o = i.lineHeight / 2;
        "bottom" === t || "center" === t || isObject(t)
            ? ((o += s.bottom),
              isArray(n.text) && (o += i.lineHeight * (n.text.length - 1)))
            : (o += s.top);
        const {
            titleX: l,
            titleY: c,
            maxWidth: u,
            rotation: d,
        } = titleArgs(this, o, t, a);
        renderText(e, n.text, 0, 0, i, {
            color: n.color,
            maxWidth: u,
            rotation: d,
            textAlign: titleAlign(a, t, r),
            textBaseline: "middle",
            translation: [l, c],
        });
    }
    draw(e) {
        this._isVisible() &&
            (this.drawBackground(),
            this.drawGrid(e),
            this.drawBorder(),
            this.drawTitle(),
            this.drawLabels(e));
    }
    _layers() {
        const e = this.options,
            t = (e.ticks && e.ticks.z) || 0,
            n = valueOrDefault(e.grid && e.grid.z, -1),
            r = valueOrDefault(e.border && e.border.z, 0);
        return this._isVisible() && this.draw === Scale.prototype.draw
            ? [
                  {
                      z: n,
                      draw: (e) => {
                          this.drawBackground(),
                              this.drawGrid(e),
                              this.drawTitle();
                      },
                  },
                  {
                      z: r,
                      draw: () => {
                          this.drawBorder();
                      },
                  },
                  {
                      z: t,
                      draw: (e) => {
                          this.drawLabels(e);
                      },
                  },
              ]
            : [
                  {
                      z: t,
                      draw: (e) => {
                          this.draw(e);
                      },
                  },
              ];
    }
    getMatchingVisibleMetas(e) {
        const t = this.chart.getSortedVisibleDatasetMetas(),
            n = this.axis + "AxisID",
            r = [];
        let i, s;
        for (i = 0, s = t.length; i < s; ++i) {
            const s = t[i];
            s[n] !== this.id || (e && s.type !== e) || r.push(s);
        }
        return r;
    }
    _resolveTickFontOptions(e) {
        return toFont(this.options.ticks.setContext(this.getContext(e)).font);
    }
    _maxDigits() {
        const e = this._resolveTickFontOptions(0).lineHeight;
        return (this.isHorizontal() ? this.width : this.height) / e;
    }
}
class TypedRegistry {
    constructor(e, t, n) {
        (this.type = e),
            (this.scope = t),
            (this.override = n),
            (this.items = Object.create(null));
    }
    isForType(e) {
        return Object.prototype.isPrototypeOf.call(
            this.type.prototype,
            e.prototype
        );
    }
    register(e) {
        const t = Object.getPrototypeOf(e);
        let n;
        isIChartComponent(t) && (n = this.register(t));
        const r = this.items,
            i = e.id,
            s = this.scope + "." + i;
        if (!i) throw new Error("class does not have id: " + e);
        return (
            i in r ||
                ((r[i] = e),
                registerDefaults(e, s, n),
                this.override && defaults.override(e.id, e.overrides)),
            s
        );
    }
    get(e) {
        return this.items[e];
    }
    unregister(e) {
        const t = this.items,
            n = e.id,
            r = this.scope;
        n in t && delete t[n],
            r &&
                n in defaults[r] &&
                (delete defaults[r][n], this.override && delete overrides[n]);
    }
}
function registerDefaults(e, t, n) {
    const r = merge$1(Object.create(null), [
        n ? defaults.get(n) : {},
        defaults.get(t),
        e.defaults,
    ]);
    defaults.set(t, r),
        e.defaultRoutes && routeDefaults(t, e.defaultRoutes),
        e.descriptors && defaults.describe(t, e.descriptors);
}
function routeDefaults(e, t) {
    Object.keys(t).forEach((n) => {
        const r = n.split("."),
            i = r.pop(),
            s = [e].concat(r).join("."),
            a = t[n].split("."),
            o = a.pop(),
            l = a.join(".");
        defaults.route(s, i, l, o);
    });
}
function isIChartComponent(e) {
    return "id" in e && "defaults" in e;
}
class Registry {
    constructor() {
        (this.controllers = new TypedRegistry(
            DatasetController,
            "datasets",
            !0
        )),
            (this.elements = new TypedRegistry(Element$1, "elements")),
            (this.plugins = new TypedRegistry(Object, "plugins")),
            (this.scales = new TypedRegistry(Scale, "scales")),
            (this._typedRegistries = [
                this.controllers,
                this.scales,
                this.elements,
            ]);
    }
    add(...e) {
        this._each("register", e);
    }
    remove(...e) {
        this._each("unregister", e);
    }
    addControllers(...e) {
        this._each("register", e, this.controllers);
    }
    addElements(...e) {
        this._each("register", e, this.elements);
    }
    addPlugins(...e) {
        this._each("register", e, this.plugins);
    }
    addScales(...e) {
        this._each("register", e, this.scales);
    }
    getController(e) {
        return this._get(e, this.controllers, "controller");
    }
    getElement(e) {
        return this._get(e, this.elements, "element");
    }
    getPlugin(e) {
        return this._get(e, this.plugins, "plugin");
    }
    getScale(e) {
        return this._get(e, this.scales, "scale");
    }
    removeControllers(...e) {
        this._each("unregister", e, this.controllers);
    }
    removeElements(...e) {
        this._each("unregister", e, this.elements);
    }
    removePlugins(...e) {
        this._each("unregister", e, this.plugins);
    }
    removeScales(...e) {
        this._each("unregister", e, this.scales);
    }
    _each(e, t, n) {
        [...t].forEach((t) => {
            const r = n || this._getRegistryForType(t);
            n || r.isForType(t) || (r === this.plugins && t.id)
                ? this._exec(e, r, t)
                : each(t, (t) => {
                      const r = n || this._getRegistryForType(t);
                      this._exec(e, r, t);
                  });
        });
    }
    _exec(e, t, n) {
        const r = _capitalize(e);
        callback(n["before" + r], [], n),
            t[e](n),
            callback(n["after" + r], [], n);
    }
    _getRegistryForType(e) {
        for (let t = 0; t < this._typedRegistries.length; t++) {
            const n = this._typedRegistries[t];
            if (n.isForType(e)) return n;
        }
        return this.plugins;
    }
    _get(e, t, n) {
        const r = t.get(e);
        if (void 0 === r)
            throw new Error('"' + e + '" is not a registered ' + n + ".");
        return r;
    }
}
var registry = new Registry();
class PluginService {
    constructor() {
        this._init = [];
    }
    notify(e, t, n, r) {
        "beforeInit" === t &&
            ((this._init = this._createDescriptors(e, !0)),
            this._notify(this._init, e, "install"));
        const i = r ? this._descriptors(e).filter(r) : this._descriptors(e),
            s = this._notify(i, e, t, n);
        return (
            "afterDestroy" === t &&
                (this._notify(i, e, "stop"),
                this._notify(this._init, e, "uninstall")),
            s
        );
    }
    _notify(e, t, n, r) {
        r = r || {};
        for (const i of e) {
            const e = i.plugin;
            if (!1 === callback(e[n], [t, r, i.options], e) && r.cancelable)
                return !1;
        }
        return !0;
    }
    invalidate() {
        isNullOrUndef(this._cache) ||
            ((this._oldCache = this._cache), (this._cache = void 0));
    }
    _descriptors(e) {
        if (this._cache) return this._cache;
        const t = (this._cache = this._createDescriptors(e));
        return this._notifyStateChanges(e), t;
    }
    _createDescriptors(e, t) {
        const n = e && e.config,
            r = valueOrDefault(n.options && n.options.plugins, {}),
            i = allPlugins(n);
        return !1 !== r || t ? createDescriptors(e, i, r, t) : [];
    }
    _notifyStateChanges(e) {
        const t = this._oldCache || [],
            n = this._cache,
            r = (e, t) =>
                e.filter((e) => !t.some((t) => e.plugin.id === t.plugin.id));
        this._notify(r(t, n), e, "stop"), this._notify(r(n, t), e, "start");
    }
}
function allPlugins(e) {
    const t = {},
        n = [],
        r = Object.keys(registry.plugins.items);
    for (let s = 0; s < r.length; s++) n.push(registry.getPlugin(r[s]));
    const i = e.plugins || [];
    for (let s = 0; s < i.length; s++) {
        const e = i[s];
        -1 === n.indexOf(e) && (n.push(e), (t[e.id] = !0));
    }
    return { plugins: n, localIds: t };
}
function getOpts(e, t) {
    return t || !1 !== e ? (!0 === e ? {} : e) : null;
}
function createDescriptors(e, { plugins: t, localIds: n }, r, i) {
    const s = [],
        a = e.getContext();
    for (const o of t) {
        const t = o.id,
            l = getOpts(r[t], i);
        null !== l &&
            s.push({
                plugin: o,
                options: pluginOpts(e.config, { plugin: o, local: n[t] }, l, a),
            });
    }
    return s;
}
function pluginOpts(e, { plugin: t, local: n }, r, i) {
    const s = e.pluginScopeKeys(t),
        a = e.getOptionScopes(r, s);
    return (
        n && t.defaults && a.push(t.defaults),
        e.createResolver(a, i, [""], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0,
        })
    );
}
function getIndexAxis(e, t) {
    const n = defaults.datasets[e] || {};
    return (
        ((t.datasets || {})[e] || {}).indexAxis ||
        t.indexAxis ||
        n.indexAxis ||
        "x"
    );
}
function getAxisFromDefaultScaleID(e, t) {
    let n = e;
    return (
        "_index_" === e
            ? (n = t)
            : "_value_" === e && (n = "x" === t ? "y" : "x"),
        n
    );
}
function getDefaultScaleIDFromAxis(e, t) {
    return e === t ? "_index_" : "_value_";
}
function idMatchesAxis(e) {
    if ("x" === e || "y" === e || "r" === e) return e;
}
function axisFromPosition(e) {
    return "top" === e || "bottom" === e
        ? "x"
        : "left" === e || "right" === e
        ? "y"
        : void 0;
}
function determineAxis(e, ...t) {
    if (idMatchesAxis(e)) return e;
    for (const n of t) {
        const t =
            n.axis ||
            axisFromPosition(n.position) ||
            (e.length > 1 && idMatchesAxis(e[0].toLowerCase()));
        if (t) return t;
    }
    throw new Error(
        `Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`
    );
}
function getAxisFromDataset(e, t, n) {
    if (n[t + "AxisID"] === e) return { axis: t };
}
function retrieveAxisFromDatasets(e, t) {
    if (t.data && t.data.datasets) {
        const n = t.data.datasets.filter(
            (t) => t.xAxisID === e || t.yAxisID === e
        );
        if (n.length)
            return (
                getAxisFromDataset(e, "x", n[0]) ||
                getAxisFromDataset(e, "y", n[0])
            );
    }
    return {};
}
function mergeScaleConfig(e, t) {
    const n = overrides[e.type] || { scales: {} },
        r = t.scales || {},
        i = getIndexAxis(e.type, t),
        s = Object.create(null);
    return (
        Object.keys(r).forEach((t) => {
            const a = r[t];
            if (!isObject(a))
                return console.error(
                    `Invalid scale configuration for scale: ${t}`
                );
            if (a._proxy)
                return console.warn(
                    `Ignoring resolver passed as options for scale: ${t}`
                );
            const o = determineAxis(
                    t,
                    a,
                    retrieveAxisFromDatasets(t, e),
                    defaults.scales[a.type]
                ),
                l = getDefaultScaleIDFromAxis(o, i),
                c = n.scales || {};
            s[t] = mergeIf(Object.create(null), [{ axis: o }, a, c[o], c[l]]);
        }),
        e.data.datasets.forEach((n) => {
            const i = n.type || e.type,
                a = n.indexAxis || getIndexAxis(i, t),
                o = (overrides[i] || {}).scales || {};
            Object.keys(o).forEach((e) => {
                const t = getAxisFromDefaultScaleID(e, a),
                    i = n[t + "AxisID"] || t;
                (s[i] = s[i] || Object.create(null)),
                    mergeIf(s[i], [{ axis: t }, r[i], o[e]]);
            });
        }),
        Object.keys(s).forEach((e) => {
            const t = s[e];
            mergeIf(t, [defaults.scales[t.type], defaults.scale]);
        }),
        s
    );
}
function initOptions(e) {
    const t = e.options || (e.options = {});
    (t.plugins = valueOrDefault(t.plugins, {})),
        (t.scales = mergeScaleConfig(e, t));
}
function initData(e) {
    return (
        ((e = e || {}).datasets = e.datasets || []),
        (e.labels = e.labels || []),
        e
    );
}
function initConfig(e) {
    return ((e = e || {}).data = initData(e.data)), initOptions(e), e;
}
const keyCache = new Map(),
    keysCached = new Set();
function cachedKeys(e, t) {
    let n = keyCache.get(e);
    return n || ((n = t()), keyCache.set(e, n), keysCached.add(n)), n;
}
const addIfFound = (e, t, n) => {
    const r = resolveObjectKey(t, n);
    void 0 !== r && e.add(r);
};
class Config {
    constructor(e) {
        (this._config = initConfig(e)),
            (this._scopeCache = new Map()),
            (this._resolverCache = new Map());
    }
    get platform() {
        return this._config.platform;
    }
    get type() {
        return this._config.type;
    }
    set type(e) {
        this._config.type = e;
    }
    get data() {
        return this._config.data;
    }
    set data(e) {
        this._config.data = initData(e);
    }
    get options() {
        return this._config.options;
    }
    set options(e) {
        this._config.options = e;
    }
    get plugins() {
        return this._config.plugins;
    }
    update() {
        const e = this._config;
        this.clearCache(), initOptions(e);
    }
    clearCache() {
        this._scopeCache.clear(), this._resolverCache.clear();
    }
    datasetScopeKeys(e) {
        return cachedKeys(e, () => [[`datasets.${e}`, ""]]);
    }
    datasetAnimationScopeKeys(e, t) {
        return cachedKeys(`${e}.transition.${t}`, () => [
            [`datasets.${e}.transitions.${t}`, `transitions.${t}`],
            [`datasets.${e}`, ""],
        ]);
    }
    datasetElementScopeKeys(e, t) {
        return cachedKeys(`${e}-${t}`, () => [
            [
                `datasets.${e}.elements.${t}`,
                `datasets.${e}`,
                `elements.${t}`,
                "",
            ],
        ]);
    }
    pluginScopeKeys(e) {
        const t = e.id;
        return cachedKeys(`${this.type}-plugin-${t}`, () => [
            [`plugins.${t}`, ...(e.additionalOptionScopes || [])],
        ]);
    }
    _cachedScopes(e, t) {
        const n = this._scopeCache;
        let r = n.get(e);
        return (r && !t) || ((r = new Map()), n.set(e, r)), r;
    }
    getOptionScopes(e, t, n) {
        const { options: r, type: i } = this,
            s = this._cachedScopes(e, n),
            a = s.get(t);
        if (a) return a;
        const o = new Set();
        t.forEach((t) => {
            e && (o.add(e), t.forEach((t) => addIfFound(o, e, t))),
                t.forEach((e) => addIfFound(o, r, e)),
                t.forEach((e) => addIfFound(o, overrides[i] || {}, e)),
                t.forEach((e) => addIfFound(o, defaults, e)),
                t.forEach((e) => addIfFound(o, descriptors, e));
        });
        const l = Array.from(o);
        return (
            0 === l.length && l.push(Object.create(null)),
            keysCached.has(t) && s.set(t, l),
            l
        );
    }
    chartOptionScopes() {
        const { options: e, type: t } = this;
        return [
            e,
            overrides[t] || {},
            defaults.datasets[t] || {},
            { type: t },
            defaults,
            descriptors,
        ];
    }
    resolveNamedOptions(e, t, n, r = [""]) {
        const i = { $shared: !0 },
            { resolver: s, subPrefixes: a } = getResolver(
                this._resolverCache,
                e,
                r
            );
        let o = s;
        if (needContext(s, t)) {
            i.$shared = !1;
            o = _attachContext(
                s,
                (n = isFunction(n) ? n() : n),
                this.createResolver(e, n, a)
            );
        }
        for (const l of t) i[l] = o[l];
        return i;
    }
    createResolver(e, t, n = [""], r) {
        const { resolver: i } = getResolver(this._resolverCache, e, n);
        return isObject(t) ? _attachContext(i, t, void 0, r) : i;
    }
}
function getResolver(e, t, n) {
    let r = e.get(t);
    r || ((r = new Map()), e.set(t, r));
    const i = n.join();
    let s = ets,
                n = [];
            let r, i;
            for (r = 0, i = t.length; r < i; ++r) {
                const i = t[r];
                (e && !i.visible) || n.push(i);
            }
            return n;
        }
        getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(!0);
        }
        _drawDatasets() {
            if (
                !1 ===
                this.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })
            )
                return;
            const e = this.getSortedVisibleDatasetMetas();
            for (let t = e.length - 1; t >= 0; --t) this._drawDataset(e[t]);
            this.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(e) {
            const t = this.ctx,
                n = e._clip,
                r = !n.disabled,
                i = getDatasetArea(e, this.chartArea),
                s = { meta: e, index: e.index, cancelable: !0 };
            !1 !== this.notifyPlugins("beforeDatasetDraw", s) &&
                (r &&
                    clipArea(t, {
                        left: !1 === n.left ? 0 : i.left - n.left,
                        right: !1 === n.right ? this.width : i.right + n.right,
                        top: !1 === n.top ? 0 : i.top - n.top,
                        bottom:
                            !1 === n.bottom ? this.height : i.bottom + n.bottom,
                    }),
                e.controller.draw(),
                r && unclipArea(t),
                (s.cancelable = !1),
                this.notifyPlugins("afterDatasetDraw", s));
        }
        isPointInArea(e) {
            return _isPointInArea(e, this.chartArea, this._minPadding);
        }
        getElementsAtEventForMode(e, t, n, r) {
            const i = Interaction.modes[t];
            return "function" == typeof i ? i(this, e, n, r) : [];
        }
        getDatasetMeta(e) {
            const t = this.data.datasets[e],
                n = this._metasets;
            let r = n.filter((e) => e && e._dataset === t).pop();
            return (
                r ||
                    ((r = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: (t && t.order) || 0,
                        index: e,
                        _dataset: t,
                        _parsed: [],
                        _sorted: !1,
                    }),
                    n.push(r)),
                r
            );
        }
        getContext() {
            return (
                this.$context ||
                (this.$context = createContext(null, {
                    chart: this,
                    type: "chart",
                }))
            );
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(e) {
            const t = this.data.datasets[e];
            if (!t) return !1;
            const n = this.getDatasetMeta(e);
            return "boolean" == typeof n.hidden ? !n.hidden : !t.hidden;
        }
        setDatasetVisibility(e, t) {
            this.getDatasetMeta(e).hidden = !t;
        }
        toggleDataVisibility(e) {
            this._hiddenIndices[e] = !this._hiddenIndices[e];
        }
        getDataVisibility(e) {
            return !this._hiddenIndices[e];
        }
        _updateVisibility(e, t, n) {
            const r = n ? "show" : "hide",
                i = this.getDatasetMeta(e),
                s = i.controller._resolveAnimations(void 0, r);
            defined(t)
                ? ((i.data[t].hidden = !n), this.update())
                : (this.setDatasetVisibility(e, n),
                  s.update(i, { visible: n }),
                  this.update((t) => (t.datasetIndex === e ? r : void 0)));
        }
        hide(e, t) {
            this._updateVisibility(e, t, !1);
        }
        show(e, t) {
            this._updateVisibility(e, t, !0);
        }
        _destroyDatasetMeta(e) {
            const t = this._metasets[e];
            t && t.controller && t.controller._destroy(),
                delete this._metasets[e];
        }
        _stop() {
            let e, t;
            for (
                this.stop(),
                    animator.remove(this),
                    e = 0,
                    t = this.data.datasets.length;
                e < t;
                ++e
            )
                this._destroyDatasetMeta(e);
        }
        destroy() {
            this.notifyPlugins("beforeDestroy");
            const { canvas: e, ctx: t } = this;
            this._stop(),
                this.config.clearCache(),
                e &&
                    (this.unbindEvents(),
                    clearCanvas(e, t),
                    this.platform.releaseContext(t),
                    (this.canvas = null),
                    (this.ctx = null)),
                delete instances[this.id],
                this.notifyPlugins("afterDestroy");
        }
        toBase64Image(...e) {
            return this.canvas.toDataURL(...e);
        }
        bindEvents() {
            this.bindUserEvents(),
                this.options.responsive
                    ? this.bindResponsiveEvents()
                    : (this.attached = !0);
        }
        bindUserEvents() {
            const e = this._listeners,
                t = this.platform,
                n = (n, r) => {
                    t.addEventListener(this, n, r), (e[n] = r);
                },
                r = (e, t, n) => {
                    (e.offsetX = t), (e.offsetY = n), this._eventHandler(e);
                };
            each(this.options.events, (e) => n(e, r));
        }
        bindResponsiveEvents() {
            this._responsiveListeners || (this._responsiveListeners = {});
            const e = this._responsiveListeners,
                t = this.platform,
                n = (n, r) => {
                    t.addEventListener(this, n, r), (e[n] = r);
                },
                r = (n, r) => {
                    e[n] && (t.removeEventListener(this, n, r), delete e[n]);
                },
                i = (e, t) => {
                    this.canvas && this.resize(e, t);
                };
            let s;
            const a = () => {
                r("attach", a),
                    (this.attached = !0),
                    this.resize(),
                    n("resize", i),
                    n("detach", s);
            };
            (s = () => {
                (this.attached = !1),
                    r("resize", i),
                    this._stop(),
                    this._resize(0, 0),
                    n("attach", a);
            }),
                t.isAttached(this.canvas) ? a() : s();
        }
        unbindEvents() {
            each(this._listeners, (e, t) => {
                this.platform.removeEventListener(this, t, e);
            }),
                (this._listeners = {}),
                each(this._responsiveListeners, (e, t) => {
                    this.platform.removeEventListener(this, t, e);
                }),
                (this._responsiveListeners = void 0);
        }
        updateHoverStyle(e, t, n) {
            const r = n ? "set" : "remove";
            let i, s, a, o;
            for (
                "dataset" === t &&
                    ((i = this.getDatasetMeta(e[0].datasetIndex)),
                    i.controller["_" + r + "DatasetHoverStyle"]()),
                    a = 0,
                    o = e.length;
                a < o;
                ++a
            ) {
                s = e[a];
                const t = s && this.getDatasetMeta(s.datasetIndex).controller;
                t && t[r + "HoverStyle"](s.element, s.datasetIndex, s.index);
            }
        }
        getActiveElements() {
            return this._active || [];
        }
        setActiveElements(e) {
            const t = this._active || [],
                n = e.map(({ datasetIndex: e, index: t }) => {
                    const n = this.getDatasetMeta(e);
                    if (!n) throw new Error("No dataset found at index " + e);
                    return { datasetIndex: e, element: n.data[t], index: t };
                });
            !_elementsEqual(n, t) &&
                ((this._active = n),
                (this._lastEvent = null),
                this._updateHoverStyles(n, t));
        }
        notifyPlugins(e, t, n) {
            return this._plugins.notify(this, e, t, n);
        }
        isPluginEnabled(e) {
            return (
                1 ===
                this._plugins._cache.filter((t) => t.plugin.id === e).length
            );
        }
        _updateHoverStyles(e, t, n) {
            const r = this.options.hover,
                i = (e, t) =>
                    e.filter(
                        (e) =>
                            !t.some(
                                (t) =>
                                    e.datasetIndex === t.datasetIndex &&
                                    e.index === t.index
                            )
                    ),
                s = i(t, e),
                a = n ? e : i(e, t);
            s.length && this.updateHoverStyle(s, r.mode, !1),
                a.length && r.mode && this.updateHoverStyle(a, r.mode, !0);
        }
        _eventHandler(e, t) {
            const n = {
                    event: e,
                    replay: t,
                    cancelable: !0,
                    inChartArea: this.isPointInArea(e),
                },
                r = (t) =>
                    (t.options.events || this.options.events).includes(
                        e.native.type
                    );
            if (!1 === this.notifyPlugins("beforeEvent", n, r)) return;
            const i = this._handleEvent(e, t, n.inChartArea);
            return (
                (n.cancelable = !1),
                this.notifyPlugins("afterEvent", n, r),
                (i || n.changed) && this.render(),
                this
            );
        }
        _handleEvent(e, t, n) {
            const { _active: r = [], options: i } = this,
                s = t,
                a = this._getActiveElements(e, r, n, s),
                o = _isClickEvent(e),
                l = determineLastEvent(e, this._lastEvent, n, o);
            n &&
                ((this._lastEvent = null),
                callback(i.onHover, [e, a, this], this),
                o && callback(i.onClick, [e, a, this], this));
            const c = !_elementsEqual(a, r);
            return (
                (c || t) &&
                    ((this._active = a), this._updateHoverStyles(a, r, t)),
                (this._lastEvent = l),
                c
            );
        }
        _getActiveElements(e, t, n, r) {
            if ("mouseout" === e.type) return [];
            if (!n) return t;
            const i = this.options.hover;
            return this.getElementsAtEventForMode(e, i.mode, i, r);
        }
    }),
    __publicField(_b, "defaults", defaults),
    __publicField(_b, "instances", instances),
    __publicField(_b, "overrides", overrides),
    __publicField(_b, "registry", registry),
    __publicField(_b, "version", version),
    __publicField(_b, "getChart", getChart),
    _b);
function invalidatePlugins() {
    return each(Chart$1.instances, (e) => e._plugins.invalidate());
}
function clipArc(e, t, n) {
    const {
        startAngle: r,
        pixelMargin: i,
        x: s,
        y: a,
        outerRadius: o,
        innerRadius: l,
    } = t;
    let c = i / o;
    e.beginPath(),
        e.arc(s, a, o, r - c, n + c),
        l > i
            ? ((c = i / l), e.arc(s, a, l, n + c, r - c, !0))
            : e.arc(s, a, i, n + HALF_PI, r - HALF_PI),
        e.closePath(),
        e.clip();
}
function toRadiusCorners(e) {
    return _readValueToProps(e, [
        "outerStart",
        "outerEnd",
        "innerStart",
        "innerEnd",
    ]);
}
function parseBorderRadius$1(e, t, n, r) {
    const i = toRadiusCorners(e.options.borderRadius),
        s = (n - t) / 2,
        a = Math.min(s, (r * t) / 2),
        o = (e) => {
            const t = ((n - Math.min(s, e)) * r) / 2;
            return _limitValue(e, 0, Math.min(s, t));
        };
    return {
        outerStart: o(i.outerStart),
        outerEnd: o(i.outerEnd),
        innerStart: _limitValue(i.innerStart, 0, a),
        innerEnd: _limitValue(i.innerEnd, 0, a),
    };
}
function rThetaToXY(e, t, n, r) {
    return { x: n + e * Math.cos(t), y: r + e * Math.sin(t) };
}
function pathArc(e, t, n, r, i, s) {
    const { x: a, y: o, startAngle: l, pixelMargin: c, innerRadius: u } = t,
        d = Math.max(t.outerRadius + r + n - c, 0),
        p = u > 0 ? u + r + n + c : 0;
    let h = 0;
    const f = i - l;
    if (r) {
        const e = ((u > 0 ? u - r : 0) + (d > 0 ? d - r : 0)) / 2;
        h = (f - (0 !== e ? (f * e) / (e + r) : f)) / 2;
    }
    const m = (f - Math.max(0.001, f * d - n / PI) / d) / 2,
        g = l + m + h,
        x = i - m - h,
        {
            outerStart: v,
            outerEnd: b,
            innerStart: y,
            innerEnd: _,
        } = parseBorderRadius$1(t, p, d, x - g),
        E = d - v,
        S = d - b,
        w = g + v / E,
        A = x - b / S,
        R = p + y,
        C = p + _,
        j = g + y / R,
        k = x - _ / C;
    if ((e.beginPath(), s)) {
        const t = (w + A) / 2;
        if ((e.arc(a, o, d, w, t), e.arc(a, o, d, t, A), b > 0)) {
            const t = rThetaToXY(S, A, a, o);
            e.arc(t.x, t.y, b, A, x + HALF_PI);
        }
        const n = rThetaToXY(C, x, a, o);
        if ((e.lineTo(n.x, n.y), _ > 0)) {
            const t = rThetaToXY(C, k, a, o);
            e.arc(t.x, t.y, _, x + HALF_PI, k + Math.PI);
        }
        const r = (x - _ / p + (g + y / p)) / 2;
        if (
            (e.arc(a, o, p, x - _ / p, r, !0),
            e.arc(a, o, p, r, g + y / p, !0),
            y > 0)
        ) {
            const t = rThetaToXY(R, j, a, o);
            e.arc(t.x, t.y, y, j + Math.PI, g - HALF_PI);
        }
        const i = rThetaToXY(E, g, a, o);
        if ((e.lineTo(i.x, i.y), v > 0)) {
            const t = rThetaToXY(E, w, a, o);
            e.arc(t.x, t.y, v, g - HALF_PI, w);
        }
    } else {
        e.moveTo(a, o);
        const t = Math.cos(w) * d + a,
            n = Math.sin(w) * d + o;
        e.lineTo(t, n);
        const r = Math.cos(A) * d + a,
            i = Math.sin(A) * d + o;
        e.lineTo(r, i);
    }
    e.closePath();
}
function drawArc(e, t, n, r, i) {
    const { fullCircles: s, startAngle: a, circumference: o } = t;
    let l = t.endAngle;
    if (s) {
        pathArc(e, t, n, r, l, i);
        for (let t = 0; t < s; ++t) e.fill();
        isNaN(o) || (l = a + (o % TAU || TAU));
    }
    return pathArc(e, t, n, r, l, i), e.fill(), l;
}
function drawBorder(e, t, n, r, i) {
    const { fullCircles: s, startAngle: a, circumference: o, options: l } = t,
        {
            borderWidth: c,
            borderJoinStyle: u,
            borderDash: d,
            borderDashOffset: p,
        } = l,
        h = "inner" === l.borderAlign;
    if (!c) return;
    e.setLineDash(d || []),
        (e.lineDashOffset = p),
        h
            ? ((e.lineWidth = 2 * c), (e.lineJoin = u || "round"))
            : ((e.lineWidth = c), (e.lineJoin = u || "bevel"));
    let f = t.endAngle;
    if (s) {
        pathArc(e, t, n, r, f, i);
        for (let t = 0; t < s; ++t) e.stroke();
        isNaN(o) || (f = a + (o % TAU || TAU));
    }
    h && clipArc(e, t, f), s || (pathArc(e, t, n, r, f, i), e.stroke());
}
class ArcElement extends Element$1 {
    constructor(e) {
        super(),
            __publicField(this, "circumference"),
            __publicField(this, "endAngle"),
            __publicField(this, "fullCircles"),
            __publicField(this, "innerRadius"),
            __publicField(this, "outerRadius"),
            __publicField(this, "pixelMargin"),
            __publicField(this, "startAngle"),
            (this.options = void 0),
            (this.circumference = void 0),
            (this.startAngle = void 0),
            (this.endAngle = void 0),
            (this.innerRadius = void 0),
            (this.outerRadius = void 0),
            (this.pixelMargin = 0),
            (this.fullCircles = 0),
            e && Object.assign(this, e);
    }
    inRange(e, t, n) {
        const r = this.getProps(["x", "y"], n),
            { angle: i, distance: s } = getAngleFromPoint(r, { x: e, y: t }),
            {
                startAngle: a,
                endAngle: o,
                innerRadius: l,
                outerRadius: c,
                circumference: u,
            } = this.getProps(
                [
                    "startAngle",
                    "endAngle",
                    "innerRadius",
                    "outerRadius",
                    "circumference",
                ],
                n
            ),
            d = (this.options.spacing + this.options.borderWidth) / 2,
            p = valueOrDefault(u, o - a) >= TAU || _angleBetween(i, a, o),
            h = _isBetween(s, l + d, c + d);
        return p && h;
    }
    getCenterPoint(e) {
        const {
                x: t,
                y: n,
                startAngle: r,
                endAngle: i,
                innerRadius: s,
                outerRadius: a,
            } = this.getProps(
                [
                    "x",
                    "y",
                    "startAngle",
                    "endAngle",
                    "innerRadius",
                    "outerRadius",
                ],
                e
            ),
            { offset: o, spacing: l } = this.options,
            c = (r + i) / 2,
            u = (s + a + l + o) / 2;
        return { x: t + Math.cos(c) * u, y: n + Math.sin(c) * u };
    }
    tooltipPosition(e) {
        return this.getCenterPoint(e);
    }
    draw(e) {
        const { options: t, circumference: n } = this,
            r = (t.offset || 0) / 4,
            i = (t.spacing || 0) / 2,
            s = t.circular;
        if (
            ((this.pixelMargin = "inner" === t.borderAlign ? 0.33 : 0),
            (this.fullCircles = n > TAU ? Math.floor(n / TAU) : 0),
            0 === n || this.innerRadius < 0 || this.outerRadius < 0)
        )
            return;
        e.save();
        const a = (this.startAngle + this.endAngle) / 2;
        e.translate(Math.cos(a) * r, Math.sin(a) * r);
        const o = r * (1 - Math.sin(Math.min(PI, n || 0)));
        (e.fillStyle = t.backgroundColor),
            (e.strokeStyle = t.borderColor),
            drawArc(e, this, o, i, s),
            drawBorder(e, this, o, i, s),
            e.restore();
    }
}
function setStyle(e, t, n = t) {
    (e.lineCap = valueOrDefault(n.borderCapStyle, t.borderCapStyle)),
        e.setLineDash(valueOrDefault(n.borderDash, t.borderDash)),
        (e.lineDashOffset = valueOrDefault(
            n.borderDashOffset,
            t.borderDashOffset
        )),
        (e.lineJoin = valueOrDefault(n.borderJoinStyle, t.borderJoinStyle)),
        (e.lineWidth = valueOrDefault(n.borderWidth, t.borderWidth)),
        (e.strokeStyle = valueOrDefault(n.borderColor, t.borderColor));
}
function lineTo(e, t, n) {
    e.lineTo(n.x, n.y);
}
function getLineMethod(e) {
    return e.stepped
        ? _steppedLineTo
        : e.tension || "monotone" === e.cubicInterpolationMode
        ? _bezierCurveTo
        : lineTo;
}
function pathVars(e, t, n = {}) {
    const r = e.length,
        { start: i = 0, end: s = r - 1 } = n,
        { start: a, end: o } = t,
        l = Math.max(i, a),
        c = Math.min(s, o),
        u = (i < a && s < a) || (i > o && s > o);
    return {
        count: r,
        start: l,
        loop: t.loop,
        ilen: c < l && !u ? r + c - l : c - l,
    };
}
function pathSegment(e, t, n, r) {
    const { points: i, options: s } = t,
        { count: a, start: o, loop: l, ilen: c } = pathVars(i, n, r),
        u = getLineMethod(s);
    let d,
        p,
        h,
        { move: f = !0, reverse: m } = r || {};
    for (d = 0; d <= c; ++d)
        (p = i[(o + (m ? c - d : d)) % a]),
            p.skip ||
                (f ? (e.moveTo(p.x, p.y), (f = !1)) : u(e, h, p, m, s.stepped),
                (h = p));
    return l && ((p = i[(o + (m ? c : 0)) % a]), u(e, h, p, m, s.stepped)), !!l;
}
function fastPathSegment(e, t, n, r) {
    const i = t.points,
        { count: s, start: a, ilen: o } = pathVars(i, n, r),
        { move: l = !0, reverse: c } = r || {};
    let u,
        d,
        p,
        h,
        f,
        m,
        g = 0,
        x = 0;
    const v = (e) => (a + (c ? o - e : e)) % s,
        b = () => {
            h !== f && (e.lineTo(g, f), e.lineTo(g, h), e.lineTo(g, m));
        };
    for (l && ((d = i[v(0)]), e.moveTo(d.x, d.y)), u = 0; u <= o; ++u) {
        if (((d = i[v(u)]), d.skip)) continue;
        const t = d.x,
            n = d.y,
            r = 0 | t;
        r === p
            ? (n < h ? (h = n) : n > f && (f = n), (g = (x * g + t) / ++x))
            : (b(), e.lineTo(t, n), (p = r), (x = 0), (h = f = n)),
            (m = n);
    }
    b();
}
function _getSegmentMethod(e) {
    const t = e.options,
        n = t.borderDash && t.borderDash.length;
    return !(
        e._decimated ||
        e._loop ||
        t.tension ||
        "monotone" === t.cubicInterpolationMode ||
        t.stepped ||
        n
    )
        ? fastPathSegment
        : pathSegment;
}
function _getInterpolationMethod(e) {
    return e.stepped
        ? _steppedInterpolation
        : e.tension || "monotone" === e.cubicInterpolationMode
        ? _bezierInterpolation
        : _pointInLine;
}
function strokePathWithCache(e, t, n, r) {
    let i = t._path;
    i || ((i = t._path = new Path2D()), t.path(i, n, r) && i.closePath()),
        setStyle(e, t.options),
        e.stroke(i);
}
function strokePathDirect(e, t, n, r) {
    const { segments: i, options: s } = t,
        a = _getSegmentMethod(t);
    for (const o of i)
        setStyle(e, s, o.style),
            e.beginPath(),
            a(e, t, o, { start: n, end: n + r - 1 }) && e.closePath(),
            e.stroke();
}
__publicField(ArcElement, "id", "arc"),
    __publicField(ArcElement, "defaults", {
        borderAlign: "center",
        borderColor: "#fff",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: !0,
    }),
    __publicField(ArcElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
    }),
    __publicField(ArcElement, "descriptors", {
        _scriptable: !0,
        _indexable: (e) => "borderDash" !== e,
    });
const usePath2D = "function" == typeof Path2D;
function draw(e, t, n, r) {
    usePath2D && !t.options.segment
        ? strokePathWithCache(e, t, n, r)
        : strokePathDirect(e, t, n, r);
}
class LineElement extends Element$1 {
    constructor(e) {
        super(),
            (this.animated = !0),
            (this.options = void 0),
            (this._chart = void 0),
            (this._loop = void 0),
            (this._fullLoop = void 0),
            (this._path = void 0),
            (this._points = void 0),
            (this._segments = void 0),
            (this._decimated = !1),
            (this._pointsUpdated = !1),
            (this._datasetIndex = void 0),
            e && Object.assign(this, e);
    }
    updateControlPoints(e, t) {
        const n = this.options;
        if (
            (n.tension || "monotone" === n.cubicInterpolationMode) &&
            !n.stepped &&
            !this._pointsUpdated
        ) {
            const r = n.spanGaps ? this._loop : this._fullLoop;
            _updateBezierControlPoints(this._points, n, e, r, t),
                (this._pointsUpdated = !0);
        }
    }
    set points(e) {
        (this._points = e),
            delete this._segments,
            delete this._path,
            (this._pointsUpdated = !1);
    }
    get points() {
        return this._points;
    }
    get segments() {
        return (
            this._segments ||
            (this._segments = _computeSegments(this, this.options.segment))
        );
    }
    first() {
        const e = this.segments,
            t = this.points;
        return e.length && t[e[0].start];
    }
    last() {
        const e = this.segments,
            t = this.points,
            n = e.length;
        return n && t[e[n - 1].end];
    }
    interpolate(e, t) {
        const n = this.options,
            r = e[t],
            i = this.points,
            s = _boundSegments(this, { property: t, start: r, end: r });
        if (!s.length) return;
        const a = [],
            o = _getInterpolationMethod(n);
        let l, c;
        for (l = 0, c = s.length; l < c; ++l) {
            const { start: c, end: u } = s[l],
                d = i[c],
                p = i[u];
            if (d === p) {
                a.push(d);
                continue;
            }
            const h = o(d, p, Math.abs((r - d[t]) / (p[t] - d[t])), n.stepped);
            (h[t] = e[t]), a.push(h);
        }
        return 1 === a.length ? a[0] : a;
    }
    pathSegment(e, t, n) {
        return _getSegmentMethod(this)(e, this, t, n);
    }
    path(e, t, n) {
        const r = this.segments,
            i = _getSegmentMethod(this);
        let s = this._loop;
        (t = t || 0), (n = n || this.points.length - t);
        for (const a of r) s &= i(e, this, a, { start: t, end: t + n - 1 });
        return !!s;
    }
    draw(e, t, n, r) {
        const i = this.options || {};
        (this.points || []).length &&
            i.borderWidth &&
            (e.save(), draw(e, this, n, r), e.restore()),
            this.animated &&
                ((this._pointsUpdated = !1), (this._path = void 0));
    }
}
function inRange$1(e, t, n, r) {
    const i = e.options,
        { [n]: s } = e.getProps([n], r);
    return Math.abs(t - s) < i.radius + i.hitRadius;
}
__publicField(LineElement, "id", "line"),
    __publicField(LineElement, "defaults", {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0,
    }),
    __publicField(LineElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor",
    }),
    __publicField(LineElement, "descriptors", {
        _scriptable: !0,
        _indexable: (e) => "borderDash" !== e && "fill" !== e,
    });
class PointElement extends Element$1 {
    constructor(e) {
        super(),
            __publicField(this, "parsed"),
            __publicField(this, "skip"),
            __publicField(this, "stop"),
            (this.options = void 0),
            (this.parsed = void 0),
            (this.skip = void 0),
            (this.stop = void 0),
            e && Object.assign(this, e);
    }
    inRange(e, t, n) {
        const r = this.options,
            { x: i, y: s } = this.getProps(["x", "y"], n);
        return (
            Math.pow(e - i, 2) + Math.pow(t - s, 2) <
            Math.pow(r.hitRadius + r.radius, 2)
        );
    }
    inXRange(e, t) {
        return inRange$1(this, e, "x", t);
    }
    inYRange(e, t) {
        return inRange$1(this, e, "y", t);
    }
    getCenterPoint(e) {
        const { x: t, y: n } = this.getProps(["x", "y"], e);
        return { x: t, y: n };
    }
    size(e) {
        let t = (e = e || this.options || {}).radius || 0;
        t = Math.max(t, (t && e.hoverRadius) || 0);
        return 2 * (t + ((t && e.borderWidth) || 0));
    }
    draw(e, t) {
        const n = this.options;
        this.skip ||
            n.radius < 0.1 ||
            !_isPointInArea(this, t, this.size(n) / 2) ||
            ((e.strokeStyle = n.borderColor),
            (e.lineWidth = n.borderWidth),
            (e.fillStyle = n.backgroundColor),
            drawPoint(e, n, this.x, this.y));
    }
    getRange() {
        const e = this.options || {};
        return e.radius + e.hitRadius;
    }
}
function getBarBounds(e, t) {
    const {
        x: n,
        y: r,
        base: i,
        width: s,
        height: a,
    } = e.getProps(["x", "y", "base", "width", "height"], t);
    let o, l, c, u, d;
    return (
        e.horizontal
            ? ((d = a / 2),
              (o = Math.min(n, i)),
              (l = Math.max(n, i)),
              (c = r - d),
              (u = r + d))
            : ((d = s / 2),
              (o = n - d),
              (l = n + d),
              (c = Math.min(r, i)),
              (u = Math.max(r, i))),
        { left: o, top: c, right: l, bottom: u }
    );
}
function skipOrLimit(e, t, n, r) {
    return e ? 0 : _limitValue(t, n, r);
}
function parseBorderWidth(e, t, n) {
    const r = e.options.borderWidth,
        i = e.borderSkipped,
        s = toTRBL(r);
    return {
        t: skipOrLimit(i.top, s.top, 0, n),
        r: skipOrLimit(i.right, s.right, 0, t),
        b: skipOrLimit(i.bottom, s.bottom, 0, n),
        l: skipOrLimit(i.left, s.left, 0, t),
    };
}
function parseBorderRadius(e, t, n) {
    const { enableBorderRadius: r } = e.getProps(["enableBorderRadius"]),
        i = e.options.borderRadius,
        s = toTRBLCorners(i),
        a = Math.min(t, n),
        o = e.borderSkipped,
        l = r || isObject(i);
    return {
        topLeft: skipOrLimit(!l || o.top || o.left, s.topLeft, 0, a),
        topRight: skipOrLimit(!l || o.top || o.right, s.topRight, 0, a),
        bottomLeft: skipOrLimit(!l || o.bottom || o.left, s.bottomLeft, 0, a),
        bottomRight: skipOrLimit(
            !l || o.bottom || o.right,
            s.bottomRight,
            0,
            a
        ),
    };
}
function boundingRects(e) {
    const t = getBarBounds(e),
        n = t.right - t.left,
        r = t.bottom - t.top,
        i = parseBorderWidth(e, n / 2, r / 2),
        s = parseBorderRadius(e, n / 2, r / 2);
    return {
        outer: { x: t.left, y: t.top, w: n, h: r, radius: s },
        inner: {
            x: t.left + i.l,
            y: t.top + i.t,
            w: n - i.l - i.r,
            h: r - i.t - i.b,
            radius: {
                topLeft: Math.max(0, s.topLeft - Math.max(i.t, i.l)),
                topRight: Math.max(0, s.topRight - Math.max(i.t, i.r)),
                bottomLeft: Math.max(0, s.bottomLeft - Math.max(i.b, i.l)),
                bottomRight: Math.max(0, s.bottomRight - Math.max(i.b, i.r)),
            },
        },
    };
}
function inRange(e, t, n, r) {
    const i = null === t,
        s = null === n,
        a = e && !(i && s) && getBarBounds(e, r);
    return (
        a &&
        (i || _isBetween(t, a.left, a.right)) &&
        (s || _isBetween(n, a.top, a.bottom))
    );
}
function hasRadius(e) {
    return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function addNormalRectPath(e, t) {
    e.rect(t.x, t.y, t.w, t.h);
}
function inflateRect(e, t, n = {}) {
    const r = e.x !== n.x ? -t : 0,
        i = e.y !== n.y ? -t : 0,
        s = (e.x + e.w !== n.x + n.w ? t : 0) - r,
        a = (e.y + e.h !== n.y + n.h ? t : 0) - i;
    return { x: e.x + r, y: e.y + i, w: e.w + s, h: e.h + a, radius: e.radius };
}
__publicField(PointElement, "id", "point"),
    __publicField(PointElement, "defaults", {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0,
    }),
    __publicField(PointElement, "defaultRoutes", {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor",
    });
class BarElement extends Element$1 {
    constructor(e) {
        super(),
            (this.options = void 0),
            (this.horizontal = void 0),
            (this.base = void 0),
            (this.width = void 0),
            (this.height = void 0),
            (this.inflateAmount = void 0),
            e && Object.assign(this, e);
    }
    draw(e) {
        const {
                inflateAmount: t,
                options: { borderColor: n, backgroundColor: r },
            } = this,
            { inner: i, outer: s } = boundingRects(this),
            a = hasRadius(s.radius) ? addRoundedRectPath : addNormalRectPath;
        e.save(),
            (s.w === i.w && s.h === i.h) ||
                (e.beginPath(),
                a(e, inflateRect(s, t, i)),
                e.clip(),
                a(e, inflateRect(i, -t, s)),
                (e.fillStyle = n),
                e.fill("evenodd")),
            e.beginPath(),
            a(e, inflateRect(i, t)),
            (e.fillStyle = r),
            e.fill(),
            e.restore();
    }
    inRange(e, t, n) {
        return inRange(this, e, t, n);
    }
    inXRange(e, t) {
        return inRange(this, e, null, t);
    }
    inYRange(e, t) {
        return inRange(this, null, e, t);
    }
    getCenterPoint(e) {
        const {
            x: t,
                          textAlign: o.textAlign(n.textAlign),
                    });
                })(o.x(w), A, b),
                g)
            )
                p.x += S + c;
            else if ("string" != typeof b.text) {
                const e = l.lineHeight;
                p.y += calculateLegendItemHeight(b, e) + c;
            } else p.y += v;
        }),
            restoreTextDirection(this.ctx, e.textDirection);
    }
    drawTitle() {
        const e = this.options,
            t = e.title,
            n = toFont(t.font),
            r = toPadding(t.padding);
        if (!t.display) return;
        const i = getRtlAdapter(e.rtl, this.left, this.width),
            s = this.ctx,
            a = t.position,
            o = n.size / 2,
            l = r.top + o;
        let c,
            u = this.left,
            d = this.width;
        if (this.isHorizontal())
            (d = Math.max(...this.lineWidths)),
                (c = this.top + l),
                (u = _alignStartEnd(e.align, u, this.right - d));
        else {
            const t = this.columnSizes.reduce(
                (e, t) => Math.max(e, t.height),
                0
            );
            c =
                l +
                _alignStartEnd(
                    e.align,
                    this.top,
                    this.bottom -
                        t -
                        e.labels.padding -
                        this._computeTitleHeight()
                );
        }
        const p = _alignStartEnd(a, u, u + d);
        (s.textAlign = i.textAlign(_toLeftRightCenter(a))),
            (s.textBaseline = "middle"),
            (s.strokeStyle = t.color),
            (s.fillStyle = t.color),
            (s.font = n.string),
            renderText(s, t.text, p, c, n);
    }
    _computeTitleHeight() {
        const e = this.options.title,
            t = toFont(e.font),
            n = toPadding(e.padding);
        return e.display ? t.lineHeight + n.height : 0;
    }
    _getLegendItemAt(e, t) {
        let n, r, i;
        if (
            _isBetween(e, this.left, this.right) &&
            _isBetween(t, this.top, this.bottom)
        )
            for (i = this.legendHitBoxes, n = 0; n < i.length; ++n)
                if (
                    ((r = i[n]),
                    _isBetween(e, r.left, r.left + r.width) &&
                        _isBetween(t, r.top, r.top + r.height))
                )
                    return this.legendItems[n];
        return null;
    }
    handleEvent(e) {
        const t = this.options;
        if (!isListened(e.type, t)) return;
        const n = this._getLegendItemAt(e.x, e.y);
        if ("mousemove" === e.type || "mouseout" === e.type) {
            const r = this._hoveredItem,
                i = itemsEqual(r, n);
            r && !i && callback(t.onLeave, [e, r, this], this),
                (this._hoveredItem = n),
                n && !i && callback(t.onHover, [e, n, this], this);
        } else n && callback(t.onClick, [e, n, this], this);
    }
}
function calculateItemSize(e, t, n, r, i) {
    return {
        itemWidth: calculateItemWidth(r, e, t, n),
        itemHeight: calculateItemHeight(i, r, t.lineHeight),
    };
}
function calculateItemWidth(e, t, n, r) {
    let i = e.text;
    return (
        i &&
            "string" != typeof i &&
            (i = i.reduce((e, t) => (e.length > t.length ? e : t))),
        t + n.size / 2 + r.measureText(i).width
    );
}
function calculateItemHeight(e, t, n) {
    let r = e;
    return (
        "string" != typeof t.text && (r = calculateLegendItemHeight(t, n)), r
    );
}
function calculateLegendItemHeight(e, t) {
    return t * (e.text ? e.text.length : 0);
}
function isListened(e, t) {
    return (
        !(
            ("mousemove" !== e && "mouseout" !== e) ||
            (!t.onHover && !t.onLeave)
        ) || !(!t.onClick || ("click" !== e && "mouseup" !== e))
    );
}
var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(e, t, n) {
        const r = (e.legend = new Legend({ ctx: e.ctx, options: n, chart: e }));
        layouts.configure(e, r, n), layouts.addBox(e, r);
    },
    stop(e) {
        layouts.removeBox(e, e.legend), delete e.legend;
    },
    beforeUpdate(e, t, n) {
        const r = e.legend;
        layouts.configure(e, r, n), (r.options = n);
    },
    afterUpdate(e) {
        const t = e.legend;
        t.buildLabels(), t.adjustHitBoxes();
    },
    afterEvent(e, t) {
        t.replay || e.legend.handleEvent(t.event);
    },
    defaults: {
        display: !0,
        position: "top",
        align: "center",
        fullSize: !0,
        reverse: !1,
        weight: 1e3,
        onClick(e, t, n) {
            const r = t.datasetIndex,
                i = n.chart;
            i.isDatasetVisible(r)
                ? (i.hide(r), (t.hidden = !0))
                : (i.show(r), (t.hidden = !1));
        },
        onHover: null,
        onLeave: null,
        labels: {
            color: (e) => e.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(e) {
                const t = e.data.datasets,
                    {
                        labels: {
                            usePointStyle: n,
                            pointStyle: r,
                            textAlign: i,
                            color: s,
                            useBorderRadius: a,
                            borderRadius: o,
                        },
                    } = e.legend.options;
                return e._getSortedDatasetMetas().map((e) => {
                    const l = e.controller.getStyle(n ? 0 : void 0),
                        c = toPadding(l.borderWidth);
                    return {
                        text: t[e.index].label,
                        fillStyle: l.backgroundColor,
                        fontColor: s,
                        hidden: !e.visible,
                        lineCap: l.borderCapStyle,
                        lineDash: l.borderDash,
                        lineDashOffset: l.borderDashOffset,
                        lineJoin: l.borderJoinStyle,
                        lineWidth: (c.width + c.height) / 4,
                        strokeStyle: l.borderColor,
                        pointStyle: r || l.pointStyle,
                        rotation: l.rotation,
                        textAlign: i || l.textAlign,
                        borderRadius: a && (o || l.borderRadius),
                        datasetIndex: e.index,
                    };
                }, this);
            },
        },
        title: {
            color: (e) => e.chart.options.color,
            display: !1,
            position: "center",
            text: "",
        },
    },
    descriptors: {
        _scriptable: (e) => !e.startsWith("on"),
        labels: {
            _scriptable: (e) =>
                !["generateLabels", "filter", "sort"].includes(e),
        },
    },
};
class Title extends Element$1 {
    constructor(e) {
        super(),
            (this.chart = e.chart),
            (this.options = e.options),
            (this.ctx = e.ctx),
            (this._padding = void 0),
            (this.top = void 0),
            (this.bottom = void 0),
            (this.left = void 0),
            (this.right = void 0),
            (this.width = void 0),
            (this.height = void 0),
            (this.position = void 0),
            (this.weight = void 0),
            (this.fullSize = void 0);
    }
    update(e, t) {
        const n = this.options;
        if (((this.left = 0), (this.top = 0), !n.display))
            return void (this.width =
                this.height =
                this.right =
                this.bottom =
                    0);
        (this.width = this.right = e), (this.height = this.bottom = t);
        const r = isArray(n.text) ? n.text.length : 1;
        this._padding = toPadding(n.padding);
        const i = r * toFont(n.font).lineHeight + this._padding.height;
        this.isHorizontal() ? (this.height = i) : (this.width = i);
    }
    isHorizontal() {
        const e = this.options.position;
        return "top" === e || "bottom" === e;
    }
    _drawArgs(e) {
        const { top: t, left: n, bottom: r, right: i, options: s } = this,
            a = s.align;
        let o,
            l,
            c,
            u = 0;
        return (
            this.isHorizontal()
                ? ((l = _alignStartEnd(a, n, i)), (c = t + e), (o = i - n))
                : ("left" === s.position
                      ? ((l = n + e),
                        (c = _alignStartEnd(a, r, t)),
                        (u = -0.5 * PI))
                      : ((l = i - e),
                        (c = _alignStartEnd(a, t, r)),
                        (u = 0.5 * PI)),
                  (o = r - t)),
            { titleX: l, titleY: c, maxWidth: o, rotation: u }
        );
    }
    draw() {
        const e = this.ctx,
            t = this.options;
        if (!t.display) return;
        const n = toFont(t.font),
            r = n.lineHeight / 2 + this._padding.top,
            {
                titleX: i,
                titleY: s,
                maxWidth: a,
                rotation: o,
            } = this._drawArgs(r);
        renderText(e, t.text, 0, 0, n, {
            color: t.color,
            maxWidth: a,
            rotation: o,
            textAlign: _toLeftRightCenter(t.align),
            textBaseline: "middle",
            translation: [i, s],
        });
    }
}
function createTitle(e, t) {
    const n = new Title({ ctx: e.ctx, options: t, chart: e });
    layouts.configure(e, n, t), layouts.addBox(e, n), (e.titleBlock = n);
}
var plugin_title = {
    id: "title",
    _element: Title,
    start(e, t, n) {
        createTitle(e, n);
    },
    stop(e) {
        const t = e.titleBlock;
        layouts.removeBox(e, t), delete e.titleBlock;
    },
    beforeUpdate(e, t, n) {
        const r = e.titleBlock;
        layouts.configure(e, r, n), (r.options = n);
    },
    defaults: {
        align: "center",
        display: !1,
        font: { weight: "bold" },
        fullSize: !0,
        padding: 10,
        position: "top",
        text: "",
        weight: 2e3,
    },
    defaultRoutes: { color: "color" },
    descriptors: { _scriptable: !0, _indexable: !1 },
};
const map = new WeakMap();
var plugin_subtitle = {
    id: "subtitle",
    start(e, t, n) {
        const r = new Title({ ctx: e.ctx, options: n, chart: e });
        layouts.configure(e, r, n), layouts.addBox(e, r), map.set(e, r);
    },
    stop(e) {
        layouts.removeBox(e, map.get(e)), map.delete(e);
    },
    beforeUpdate(e, t, n) {
        const r = map.get(e);
        layouts.configure(e, r, n), (r.options = n);
    },
    defaults: {
        align: "center",
        display: !1,
        font: { weight: "normal" },
        fullSize: !0,
        padding: 0,
        position: "top",
        text: "",
        weight: 1500,
    },
    defaultRoutes: { color: "color" },
    descriptors: { _scriptable: !0, _indexable: !1 },
};
const positioners = {
    average(e) {
        if (!e.length) return !1;
        let t,
            n,
            r = new Set(),
            i = 0,
            s = 0;
        for (t = 0, n = e.length; t < n; ++t) {
            const n = e[t].element;
            if (n && n.hasValue()) {
                const e = n.tooltipPosition();
                r.add(e.x), (i += e.y), ++s;
            }
        }
        const a = [...r].reduce((e, t) => e + t) / r.size;
        return { x: a, y: i / s };
    },
    nearest(e, t) {
        if (!e.length) return !1;
        let n,
            r,
            i,
            s = t.x,
            a = t.y,
            o = Number.POSITIVE_INFINITY;
        for (n = 0, r = e.length; n < r; ++n) {
            const r = e[n].element;
            if (r && r.hasValue()) {
                const e = distanceBetweenPoints(t, r.getCenterPoint());
                e < o && ((o = e), (i = r));
            }
        }
        if (i) {
            const e = i.tooltipPosition();
            (s = e.x), (a = e.y);
        }
        return { x: s, y: a };
    },
};
function pushOrConcat(e, t) {
    return t && (isArray(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function splitNewlines(e) {
    return ("string" == typeof e || e instanceof String) && e.indexOf("\n") > -1
        ? e.split("\n")
        : e;
}
function createTooltipItem(e, t) {
    const { element: n, datasetIndex: r, index: i } = t,
        s = e.getDatasetMeta(r).controller,
        { label: a, value: o } = s.getLabelAndValue(i);
    return {
        chart: e,
        label: a,
        parsed: s.getParsed(i),
        raw: e.data.datasets[r].data[i],
        formattedValue: o,
        dataset: s.getDataset(),
        dataIndex: i,
        datasetIndex: r,
        element: n,
    };
}
function getTooltipSize(e, t) {
    const n = e.chart.ctx,
        { body: r, footer: i, title: s } = e,
        { boxWidth: a, boxHeight: o } = t,
        l = toFont(t.bodyFont),
        c = toFont(t.titleFont),
        u = toFont(t.footerFont),
        d = s.length,
        p = i.length,
        h = r.length,
        f = toPadding(t.padding);
    let m = f.height,
        g = 0,
        x = r.reduce(
            (e, t) => e + t.before.length + t.lines.length + t.after.length,
            0
        );
    if (
        ((x += e.beforeBody.length + e.afterBody.length),
        d &&
            (m +=
                d * c.lineHeight +
                (d - 1) * t.titleSpacing +
                t.titleMarginBottom),
        x)
    ) {
        m +=
            h * (t.displayColors ? Math.max(o, l.lineHeight) : l.lineHeight) +
            (x - h) * l.lineHeight +
            (x - 1) * t.bodySpacing;
    }
    p &&
        (m += t.footerMarginTop + p * u.lineHeight + (p - 1) * t.footerSpacing);
    let v = 0;
    const b = function (e) {
        g = Math.max(g, n.measureText(e).width + v);
    };
    return (
        n.save(),
        (n.font = c.string),
        each(e.title, b),
        (n.font = l.string),
        each(e.beforeBody.concat(e.afterBody), b),
        (v = t.displayColors ? a + 2 + t.boxPadding : 0),
        each(r, (e) => {
            each(e.before, b), each(e.lines, b), each(e.after, b);
        }),
        (v = 0),
        (n.font = u.string),
        each(e.footer, b),
        n.restore(),
        (g += f.width),
        { width: g, height: m }
    );
}
function determineYAlign(e, t) {
    const { y: n, height: r } = t;
    return n < r / 2 ? "top" : n > e.height - r / 2 ? "bottom" : "center";
}
function doesNotFitWithAlign(e, t, n, r) {
    const { x: i, width: s } = r,
        a = n.caretSize + n.caretPadding;
    return (
        ("left" === e && i + s + a > t.width) ||
        ("right" === e && i - s - a < 0) ||
        void 0
    );
}
function determineXAlign(e, t, n, r) {
    const { x: i, width: s } = n,
        {
            width: a,
            chartArea: { left: o, right: l },
        } = e;
    let c = "center";
    return (
        "center" === r
            ? (c = i <= (o + l) / 2 ? "left" : "right")
            : i <= s / 2
            ? (c = "left")
            : i >= a - s / 2 && (c = "right"),
        doesNotFitWithAlign(c, e, t, n) && (c = "center"),
        c
    );
}
function determineAlignment(e, t, n) {
    const r = n.yAlign || t.yAlign || determineYAlign(e, n);
    return {
        xAlign: n.xAlign || t.xAlign || determineXAlign(e, t, n, r),
        yAlign: r,
    };
}
function alignX(e, t) {
    let { x: n, width: r } = e;
    return "right" === t ? (n -= r) : "center" === t && (n -= r / 2), n;
}
function alignY(e, t, n) {
    let { y: r, height: i } = e;
    return "top" === t ? (r += n) : (r -= "bottom" === t ? i + n : i / 2), r;
}
function getBackgroundPoint(e, t, n, r) {
    const { caretSize: i, caretPadding: s, cornerRadius: a } = e,
        { xAlign: o, yAlign: l } = n,
        c = i + s,
        {
            topLeft: u,
            topRight: d,
            bottomLeft: p,
            bottomRight: h,
        } = toTRBLCorners(a);
    let f = alignX(t, o);
    const m = alignY(t, l, c);
    return (
        "center" === l
            ? "left" === o
                ? (f += c)
                : "right" === o && (f -= c)
            : "left" === o
            ? (f -= Math.max(u, p) + i)
            : "right" === o && (f += Math.max(d, h) + i),
        {
            x: _limitValue(f, 0, r.width - t.width),
            y: _limitValue(m, 0, r.height - t.height),
        }
    );
}
function getAlignedX(e, t, n) {
    const r = toPadding(n.padding);
    return "center" === t
        ? e.x + e.width / 2
        : "right" === t
        ? e.x + e.width - r.right
        : e.x + r.left;
}
function getBeforeAfterBodyLines(e) {
    return pushOrConcat([], splitNewlines(e));
}
function createTooltipContext(e, t, n) {
    return createContext(e, { tooltip: t, tooltipItems: n, type: "tooltip" });
}
function overrideCallbacks(e, t) {
    const n =
        t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
    return n ? e.override(n) : e;
}
const defaultCallbacks = {
    beforeTitle: noop$1,
    title(e) {
        if (e.length > 0) {
            const t = e[0],
                n = t.chart.data.labels,
                r = n ? n.length : 0;
            if (this && this.options && "dataset" === this.options.mode)
                return t.dataset.label || "";
            if (t.label) return t.label;
            if (r > 0 && t.dataIndex < r) return n[t.dataIndex];
        }
        return "";
    },
    afterTitle: noop$1,
    beforeBody: noop$1,
    beforeLabel: noop$1,
    label(e) {
        if (this && this.options && "dataset" === this.options.mode)
            return e.label + ": " + e.formattedValue || e.formattedValue;
        let t = e.dataset.label || "";
        t && (t += ": ");
        const n = e.formattedValue;
        return isNullOrUndef(n) || (t += n), t;
    },
    labelColor(e) {
        const t = e.chart
            .getDatasetMeta(e.datasetIndex)
            .controller.getStyle(e.dataIndex);
        return {
            borderColor: t.borderColor,
            backgroundColor: t.backgroundColor,
            borderWidth: t.borderWidth,
            borderDash: t.borderDash,
            borderDashOffset: t.borderDashOffset,
            borderRadius: 0,
        };
    },
    labelTextColor() {
        return this.options.bodyColor;
    },
    labelPointStyle(e) {
        const t = e.chart
            .getDatasetMeta(e.datasetIndex)
            .controller.getStyle(e.dataIndex);
        return { pointStyle: t.pointStyle, rotation: t.rotation };
    },
    afterLabel: noop$1,
    afterBody: noop$1,
    beforeFooter: noop$1,
    footer: noop$1,
    afterFooter: noop$1,
};
function invokeCallbackWithFallback(e, t, n, r) {
    const i = e[t].call(n, r);
    return void 0 === i ? defaultCallbacks[t].call(n, r) : i;
}
let Tooltip$1 =
    ((_c = class extends Element$1 {
        constructor(e) {
            super(),
                (this.opacity = 0),
                (this._active = []),
                (this._eventPosition = void 0),
                (this._size = void 0),
                (this._cachedAnimations = void 0),
                (this._tooltipItems = []),
                (this.$animations = void 0),
                (this.$context = void 0),
                (this.chart = e.chart),
                (this.options = e.options),
                (this.dataPoints = void 0),
                (this.title = void 0),
                (this.beforeBody = void 0),
                (this.body = void 0),
                (this.afterBody = void 0),
                (this.footer = void 0),
                (this.xAlign = void 0),
                (this.yAlign = void 0),
                (this.x = void 0),
                (this.y = void 0),
                (this.height = void 0),
                (this.width = void 0),
                (this.caretX = void 0),
                (this.caretY = void 0),
                (this.labelColors = void 0),
                (this.labelPointStyles = void 0),
                (this.labelTextColors = void 0);
        }
        initialize(e) {
            (this.options = e),
                (this._cachedAnimations = void 0),
                (this.$context = void 0);
        }
        _resolveAnimations() {
            const e = this._cachedAnimations;
            if (e) return e;
            const t = this.chart,
                n = this.options.setContext(this.getContext()),
                r = n.enabled && t.options.animation && n.animations,
                i = new Animations(this.chart, r);
            return (
                r._cacheable && (this._cachedAnimations = Object.freeze(i)), i
            );
        }
        getContext() {
            return (
                this.$context ||
                (this.$context = createTooltipContext(
                    this.chart.getContext(),
                    this,
                    this._tooltipItems
                ))
            );
        }
        getTitle(e, t) {
            const { callbacks: n } = t,
                r = invokeCallbackWithFallback(n, "beforeTitle", this, e),
                i = invokeCallbackWithFallback(n, "title", this, e),
                s = invokeCallbackWithFallback(n, "afterTitle", this, e);
            let a = [];
            return (
    ) ^
              charat(e, 2)) <<
              2) ^
              charat(e, 3)
        : 0;
}
function trim(e) {
    return e.trim();
}
function match(e, t) {
    return (e = t.exec(e)) ? e[0] : e;
}
function replace(e, t, n) {
    return e.replace(t, n);
}
function indexof(e, t) {
    return e.indexOf(t);
}
function charat(e, t) {
    return 0 | e.charCodeAt(t);
}
function substr(e, t, n) {
    return e.slice(t, n);
}
function strlen(e) {
    return e.length;
}
function sizeof(e) {
    return e.length;
}
function append(e, t) {
    return t.push(e), e;
}
function combine(e, t) {
    return e.map(t).join("");
}
var line = 1,
    column = 1,
    length = 0,
    position = 0,
    character = 0,
    characters = "";
function node(e, t, n, r, i, s, a) {
    return {
        value: e,
        root: t,
        parent: n,
        type: r,
        props: i,
        children: s,
        line: line,
        column: column,
        length: a,
        return: "",
    };
}
function copy(e, t) {
    return assign(
        node("", null, null, "", null, null, 0),
        e,
        { length: -e.length },
        t
    );
}
function char() {
    return character;
}
function prev() {
    return (
        (character = position > 0 ? charat(characters, --position) : 0),
        column--,
        10 === character && ((column = 1), line--),
        character
    );
}
function next() {
    return (
        (character = position < length ? charat(characters, position++) : 0),
        column++,
        10 === character && ((column = 1), line++),
        character
    );
}
function peek() {
    return charat(characters, position);
}
function caret() {
    return position;
}
function slice(e, t) {
    return substr(characters, e, t);
}
function token(e) {
    switch (e) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1;
    }
    return 0;
}
function alloc(e) {
    return (
        (line = column = 1),
        (length = strlen((characters = e))),
        (position = 0),
        []
    );
}
function dealloc(e) {
    return (characters = ""), e;
}
function delimit(e) {
    return trim(
        slice(position - 1, delimiter(91 === e ? e + 2 : 40 === e ? e + 1 : e))
    );
}
function whitespace(e) {
    for (; (character = peek()) && character < 33; ) next();
    return token(e) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(e, t) {
    for (
        ;
        --t &&
        next() &&
        !(
            character < 48 ||
            character > 102 ||
            (character > 57 && character < 65) ||
            (character > 70 && character < 97)
        );

    );
    return slice(e, caret() + (t < 6 && 32 == peek() && 32 == next()));
}
function delimiter(e) {
    for (; next(); )
        switch (character) {
            case e:
                return position;
            case 34:
            case 39:
                34 !== e && 39 !== e && delimiter(character);
                break;
            case 40:
                41 === e && delimiter(e);
                break;
            case 92:
                next();
        }
    return position;
}
function commenter(e, t) {
    for (
        ;
        next() &&
        e + character !== 57 &&
        (e + character !== 84 || 47 !== peek());

    );
    return "/*" + slice(t, position - 1) + "*" + from(47 === e ? e : next());
}
function identifier(e) {
    for (; !token(peek()); ) next();
    return slice(e, position);
}
function compile(e) {
    return dealloc(
        parse("", null, null, null, [""], (e = alloc(e)), 0, [0], e)
    );
}
function parse(e, t, n, r, i, s, a, o, l) {
    for (
        var c = 0,
            u = 0,
            d = a,
            p = 0,
            h = 0,
            f = 0,
            m = 1,
            g = 1,
            x = 1,
            v = 0,
            b = "",
            y = i,
            _ = s,
            E = r,
            S = b;
        g;

    )
        switch (((f = v), (v = next()))) {
            case 40:
                if (108 != f && 58 == charat(S, d - 1)) {
                    -1 !=
                        indexof(
                            (S += replace(delimit(v), "&", "&\f")),
                            "&\f"
                        ) && (x = -1);
                    break;
                }
            case 34:
            case 39:
            case 91:
                S += delimit(v);
                break;
            case 9:
            case 10:
            case 13:
            case 32:
                S += whitespace(f);
                break;
            case 92:
                S += escaping(caret() - 1, 7);
                continue;
            case 47:
                switch (peek()) {
                    case 42:
                    case 47:
                        append(comment(commenter(next(), caret()), t, n), l);
                        break;
                    default:
                        S += "/";
                }
                break;
            case 123 * m:
                o[c++] = strlen(S) * x;
            case 125 * m:
            case 59:
            case 0:
                switch (v) {
                    case 0:
                    case 125:
                        g = 0;
                    case 59 + u:
                        -1 == x && (S = replace(S, /\f/g, "")),
                            h > 0 &&
                                strlen(S) - d &&
                                append(
                                    h > 32
                                        ? declaration(S + ";", r, n, d - 1)
                                        : declaration(
                                              replace(S, " ", "") + ";",
                                              r,
                                              n,
                                              d - 2
                                          ),
                                    l
                                );
                        break;
                    case 59:
                        S += ";";
                    default:
                        if (
                            (append(
                                (E = ruleset(
                                    S,
                                    t,
                                    n,
                                    c,
                                    u,
                                    i,
                                    o,
                                    b,
                                    (y = []),
                                    (_ = []),
                                    d
                                )),
                                s
                            ),
                            123 === v)
                        )
                            if (0 === u) parse(S, t, E, E, y, s, d, o, _);
                            else
                                switch (
                                    99 === p && 110 === charat(S, 3) ? 100 : p
                                ) {
                                    case 100:
                                    case 108:
                                    case 109:
                                    case 115:
                                        parse(
                                            e,
                                            E,
                                            E,
                                            r &&
                                                append(
                                                    ruleset(
                                                        e,
                                                        E,
                                                        E,
                                                        0,
                                                        0,
                                                        i,
                                                        o,
                                                        b,
                                                        i,
                                                        (y = []),
                                                        d
                                                    ),
                                                    _
                                                ),
                                            i,
                                            _,
                                            d,
                                            o,
                                            r ? y : _
                                        );
                                        break;
                                    default:
                                        parse(S, E, E, E, [""], _, 0, o, _);
                                }
                }
                (c = u = h = 0), (m = x = 1), (b = S = ""), (d = a);
                break;
            case 58:
                (d = 1 + strlen(S)), (h = f);
            default:
                if (m < 1)
                    if (123 == v) --m;
                    else if (125 == v && 0 == m++ && 125 == prev()) continue;
                switch (((S += from(v)), v * m)) {
                    case 38:
                        x = u > 0 ? 1 : ((S += "\f"), -1);
                        break;
                    case 44:
                        (o[c++] = (strlen(S) - 1) * x), (x = 1);
                        break;
                    case 64:
                        45 === peek() && (S += delimit(next())),
                            (p = peek()),
                            (u = d = strlen((b = S += identifier(caret())))),
                            v++;
                        break;
                    case 45:
                        45 === f && 2 == strlen(S) && (m = 0);
                }
        }
    return s;
}
function ruleset(e, t, n, r, i, s, a, o, l, c, u) {
    for (
        var d = i - 1,
            p = 0 === i ? s : [""],
            h = sizeof(p),
            f = 0,
            m = 0,
            g = 0;
        f < r;
        ++f
    )
        for (
            var x = 0, v = substr(e, d + 1, (d = abs((m = a[f])))), b = e;
            x < h;
            ++x
        )
            (b = trim(m > 0 ? p[x] + " " + v : replace(v, /&\f/g, p[x]))) &&
                (l[g++] = b);
    return node(e, t, n, 0 === i ? RULESET : o, l, c, u);
}
function comment(e, t, n) {
    return node(e, t, n, COMMENT, from(char()), substr(e, 2, -2), 0);
}
function declaration(e, t, n, r) {
    return node(e, t, n, DECLARATION, substr(e, 0, r), substr(e, r + 1, -1), r);
}
function serialize(e, t) {
    for (var n = "", r = sizeof(e), i = 0; i < r; i++)
        n += t(e[i], i, e, t) || "";
    return n;
}
function stringify(e, t, n, r) {
    switch (e.type) {
        case LAYER:
            if (e.children.length) break;
        case IMPORT:
        case DECLARATION:
            return (e.return = e.return || e.value);
        case COMMENT:
            return "";
        case KEYFRAMES:
            return (e.return = e.value + "{" + serialize(e.children, r) + "}");
        case RULESET:
            e.value = e.props.join(",");
    }
    return strlen((n = serialize(e.children, r)))
        ? (e.return = e.value + "{" + n + "}")
        : "";
}
function middleware(e) {
    var t = sizeof(e);
    return function (n, r, i, s) {
        for (var a = "", o = 0; o < t; o++) a += e[o](n, r, i, s) || "";
        return a;
    };
}
function rulesheet(e) {
    return function (t) {
        t.root || ((t = t.return) && e(t));
    };
}
var identifierWithPointTracking = function (e, t, n) {
        for (
            var r = 0, i = 0;
            (r = i),
                (i = peek()),
                38 === r && 12 === i && (t[n] = 1),
                !token(i);

        )
            next();
        return slice(e, position);
    },
    toRules = function (e, t) {
        var n = -1,
            r = 44;
        do {
            switch (token(r)) {
                case 0:
                    38 === r && 12 === peek() && (t[n] = 1),
                        (e[n] += identifierWithPointTracking(
                            position - 1,
                            t,
                            n
                        ));
                    break;
                case 2:
                    e[n] += delimit(r);
                    break;
                case 4:
                    if (44 === r) {
                        (e[++n] = 58 === peek() ? "&\f" : ""),
                            (t[n] = e[n].length);
                        break;
                    }
                default:
                    e[n] += from(r);
            }
        } while ((r = next()));
        return e;
    },
    getRules = function (e, t) {
        return dealloc(toRules(alloc(e), t));
    },
    fixedElements = new WeakMap(),
    compat = function (e) {
        if ("rule" === e.type && e.parent && !(e.length < 1)) {
            for (
                var t = e.value,
                    n = e.parent,
                    r = e.column === n.column && e.line === n.line;
                "rule" !== n.type;

            )
                if (!(n = n.parent)) return;
            if (
                (1 !== e.props.length ||
                    58 === t.charCodeAt(0) ||
                    fixedElements.get(n)) &&
                !r
            ) {
                fixedElements.set(e, !0);
                for (
                    var i = [], s = getRules(t, i), a = n.props, o = 0, l = 0;
                    o < s.length;
                    o++
                )
                    for (var c = 0; c < a.length; c++, l++)
                        e.props[l] = i[o]
                            ? s[o].replace(/&\f/g, a[c])
                            : a[c] + " " + s[o];
            }
        }
    },
    removeLabel = function (e) {
        if ("decl" === e.type) {
            var t = e.value;
            108 === t.charCodeAt(0) &&
                98 === t.charCodeAt(2) &&
                ((e.return = ""), (e.value = ""));
        }
    };
function prefix$1(e, t) {
    switch (hash$2(e, t)) {
        case 5103:
            return WEBKIT + "print-" + e + e;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return WEBKIT + e + e;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return WEBKIT + e + MOZ + e + MS + e + e;
        case 6828:
        case 4268:
            return WEBKIT + e + MS + e + e;
        case 6165:
            return WEBKIT + e + MS + "flex-" + e + e;
        case 5187:
            return (
                WEBKIT +
                e +
                replace(
                    e,
                    /(\w+).+(:[^]+)/,
                    WEBKIT + "box-$1$2" + MS + "flex-$1$2"
                ) +
                e
            );
        case 5443:
            return (
                WEBKIT +
                e +
                MS +
                "flex-item-" +
                replace(e, /flex-|-self/, "") +
                e
            );
        case 4675:
            return (
                WEBKIT +
                e +
                MS +
                "flex-line-pack" +
                replace(e, /align-content|flex-|-self/, "") +
                e
            );
        case 5548:
            return WEBKIT + e + MS + replace(e, "shrink", "negative") + e;
        case 5292:
            return WEBKIT + e + MS + replace(e, "basis", "preferred-size") + e;
        case 6060:
            return (
                WEBKIT +
                "box-" +
                replace(e, "-grow", "") +
                WEBKIT +
                e +
                MS +
                replace(e, "grow", "positive") +
                e
            );
        case 4554:
            return (
                WEBKIT +
                replace(e, /([^-])(transform)/g, "$1" + WEBKIT + "$2") +
                e
            );
        case 6187:
            return (
                replace(
                    replace(
                        replace(e, /(zoom-|grab)/, WEBKIT + "$1"),
                        /(image-set)/,
                        WEBKIT + "$1"
                    ),
                    e,
                    ""
                ) + e
            );
        case 5495:
        case 3959:
            return replace(e, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
            return (
                replace(
                    replace(
                        e,
                        /(.+:)(flex-)?(.*)/,
                        WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"
                    ),
                    /s.+-b[^;]+/,
                    "justify"
                ) +
                WEBKIT +
                e +
                e
            );
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return replace(e, /(.+)-inline(.+)/, WEBKIT + "$1$2") + e;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (strlen(e) - 1 - t > 6)
                switch (charat(e, t + 1)) {
                    case 109:
                        if (45 !== charat(e, t + 4)) break;
                    case 102:
                        return (
                            replace(
                                e,
                                /(.+:)(.+)-([^]+)/,
                                "$1" +
                                    WEBKIT +
                                    "$2-$3$1" +
                                    MOZ +
                                    (108 == charat(e, t + 3) ? "$3" : "$2-$3")
                            ) + e
                        );
                    case 115:
                        return ~indexof(e, "stretch")
                            ? prefix$1(
                                  replace(e, "stretch", "fill-available"),
                                  t
                              ) + e
                            : e;
                }
            break;
        case 4949:
            if (115 !== charat(e, t + 1)) break;
        case 6444:
            switch (
                charat(e, strlen(e) - 3 - (~indexof(e, "!important") && 10))
            ) {
                case 107:
                    return replace(e, ":", ":" + WEBKIT) + e;
                case 101:
                    return (
                        replace(
                            e,
                            /(.+:)([^;!]+)(;|!.+)?/,
                            "$1" +
                                WEBKIT +
                                (45 === charat(e, 14) ? "inline-" : "") +
                                "box$3$1" +
                                WEBKIT +
                                "$2$3$1" +
                                MS +
                                "$2box$3"
                        ) + e
                    );
            }
            break;
        case 5936:
            switch (charat(e, t + 11)) {
                case 114:
                    return (
                        WEBKIT +
                        e +
                        MS +
                        replace(e, /[svh]\w+-[tblr]{2}/, "tb") +
                        e
                    );
                case 108:
                    return (
                        WEBKIT +
                        e +
                        MS +
                        replace(e, /[svh]\w+-[tblr]{2}/, "tb-rl") +
                        e
                    );
                case 45:
                    return (
                        WEBKIT +
                        e +
                        MS +
                        replace(e, /[svh]\w+-[tblr]{2}/, "lr") +
                        e
                    );
            }
            return WEBKIT + e + MS + e + e;
    }
    return e;
}
var prefixer = function (e, t, n, r) {
        if (e.length > -1 && !e.return)
            switch (e.type) {
                case DECLARATION:
                    e.return = prefix$1(e.value, e.length);
                    break;
                case KEYFRAMES:
                    return serialize(
                        [
                            copy(e, {
                                value: replace(e.value, "@", "@" + WEBKIT),
                            }),
                        ],
                        r
                    );
                case RULESET:
                    if (e.length)
                        return combine(e.props, function (t) {
                            switch (match(t, /(::plac\w+|:read-\w+)/)) {
                                case ":read-only":
                                case ":read-write":
                                    return serialize(
                                        [
                                            copy(e, {
                                                props: [
                                                    replace(
                                                        t,
                                                        /:(read-\w+)/,
                                                        ":" + MOZ + "$1"
                                                    ),
                                                ],
                                            }),
                                        ],
                                        r
                                    );
                                case "::placeholder":
                                    return serialize(
                                        [
                                            copy(e, {
                                                props: [
                                                    replace(
                                                        t,
                                                        /:(plac\w+)/,
                                                        ":" +
                                                            WEBKIT +
                                                            "input-$1"
                                                    ),
                                                ],
                                            }),
                                            copy(e, {
                                                props: [
                                                    replace(
                                                        t,
                                                        /:(plac\w+)/,
                                                        ":" + MOZ + "$1"
                                                    ),
                                                ],
                                            }),
                                            copy(e, {
                                                props: [
                                                    replace(
                                                        t,
                                                        /:(plac\w+)/,
                                                        MS + "input-$1"
                                                    ),
                                                ],
                                            }),
                                        ],
                                        r
                                    );
                            }
                            return "";
                        });
            }
    },
    defaultStylisPlugins = [prefixer],
    createCache = function (e) {
        var t = e.key;
        if ("css" === t) {
            var n = document.querySelectorAll(
                "style[data-emotion]:not([data-s])"
            );
            Array.prototype.forEach.call(n, function (e) {
                -1 !== e.getAttribute("data-emotion").indexOf(" ") &&
                    (document.head.appendChild(e),
                    e.setAttribute("data-s", ""));
            });
        }
        var r,
            i,
            s = e.stylisPlugins || defaultStylisPlugins,
            a = {},
            o = [];
        (r = e.container || document.head),
            Array.prototype.forEach.call(
                document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
                function (e) {
                    for (
                        var t = e.getAttribute("data-emotion").split(" "),
                            n = 1;
                        n < t.length;
                        n++
                    )
                        a[t[n]] = !0;
                    o.push(e);
                }
            );
        var l,
            c = [compat, removeLabel],
            u = [
                stringify,
                rulesheet(function (e) {
                    l.insert(e);
                }),
            ],
            d = middleware(c.concat(s, u));
        i = function (e, t, n, r) {
            (l = n),
                serialize(compile(e ? e + "{" + t.styles + "}" : t.styles), d),
                r && (p.inserted[t.name] = !0);
        };
        var p = {
            key: t,
            sheet: new StyleSheet({
                key: t,
                container: r,
                nonce: e.nonce,
                speedy: e.speedy,
                prepend: e.prepend,
                insertionPoint: e.insertionPoint,
            }),
            nonce: e.nonce,
            inserted: a,
            registered: {},
            insert: i,
        };
        return p.sheet.hydrate(o), p;
    },
    reactIs$1 = { exports: {} },
    reactIs_production_min$1 = {},
    b$1 = "function" == typeof Symbol && Symbol.for,
    c$1 = b$1 ? Symbol.for("react.element") : 60103,
    d$1 = b$1 ? Symbol.for("react.portal") : 60106,
    e$1 = b$1 ? Symbol.for("react.fragment") : 60107,
    f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108,
    g$1 = b$1 ? Symbol.for("react.profiler") : 60114,
    h$1 = b$1 ? Symbol.for("react.provider") : 60109,
    k$1 = b$1 ? Symbol.for("react.context") : 60110,
    l$1 = b$1 ? Symbol.for("react.async_mode") : 60111,
    m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111,
    n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112,
    p$1 = b$1 ? Symbol.for("react.suspense") : 60113,
    q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120,
    r = b$1 ? Symbol.for("react.memo") : 60115,
    t$1 = b$1 ? Symbol.for("react.lazy") : 60116,
    v$1 = b$1 ? Symbol.for("react.block") : 60121,
    w = b$1 ? Symbol.for("react.fundamental") : 60117,
    x = b$1 ? Symbol.for("react.responder") : 60118,
    y = b$1 ? Symbol.for("react.scope") : 60119;
function z(e) {
    if ("object" == typeof e && null !== e) {
        var t = e.$$typeof;
        switch (t) {
            case c$1:
                switch ((e = e.type)) {
                    case l$1:
                    case m$1:
                    case e$1:
                    case g$1:
                    case f$1:
                    case p$1:
                        return e;
                    default:
                        switch ((e = e && e.$$typeof)) {
                            case k$1:
                            case n$1:
                            case t$1:
                            case r:
                            case h$1:
                                return e;
                            default:
                                return t;
                        }
                }
            case d$1:
                return t;
        }
    }
}
function A(e) {
    return z(e) === m$1;
}
(reactIs_production_min$1.AsyncMode = l$1),
    (reactIs_production_min$1.ConcurrentMode = m$1),
    (reactIs_production_min$1.ContextConsumer = k$1),
    (reactIs_production_min$1.ContextProvider = h$1),
    (reactIs_production_min$1.Element = c$1),
    (reactIs_production_min$1.ForwardRef = n$1),
    (reactIs_production_min$1.Fragment = e$1),
    (reactIs_production_min$1.Lazy = t$1),
    (reactIs_production_min$1.Memo = r),
    (reactIs_production_min$1.Portal = d$1),
    (reactIs_production_min$1.Profiler = g$1),
    (reactIs_production_min$1.StrictMode = f$1),
    (reactIs_production_min$1.Suspense = p$1),
    (reactIs_production_min$1.isAsyncMode = function (e) {
        return A(e) || z(e) === l$1;
    }),
    (reactIs_production_min$1.isConcurrentMode = A),
    (reactIs_production_min$1.isContextConsumer = function (e) {
        return z(e) === k$1;
    }),
    (reactIs_production_min$1.isContextProvider = function (e) {
        return z(e) === h$1;
    }),
    (reactIs_production_min$1.isElement = function (e) {
        return "object" == typeof e && null !== e && e.$$typeof === c$1;
    }),
    (reactIs_production_min$1.isForwardRef = function (e) {
        return z(e) === n$1;
    }),
    (reactIs_production_min$1.isFragment = function (e) {
        return z(e) === e$1;
    }),
    (reactIs_production_min$1.isLazy = function (e) {
        return z(e) === t$1;
    }),
    (reactIs_production_min$1.isMemo = function (e) {
        return z(e) === r;
    }),
    (reactIs_production_min$1.isPortal = function (e) {
        return z(e) === d$1;
    }),
    (reactIs_production_min$1.isProfiler = function (e) {
        return z(e) === g$1;
    }),
    (reactIs_production_min$1.isStrictMode = function (e) {
        return z(e) === f$1;
    }),
    (reactIs_production_min$1.isSuspense = function (e) {
        return z(e) === p$1;
    }),
    (reactIs_production_min$1.isValidElementType = function (e) {
        return (
            "string" == typeof e ||
            "function" == typeof e ||
            e === e$1 ||
            e === m$1 ||
            e === g$1 ||
            e === f$1 ||
            e === p$1 ||
            e === q$1 ||
            ("object" == typeof e &&
                null !== e &&
                (e.$$typeof === t$1 ||
                    e.$$typeof === r ||
                    e.$$typeof === h$1 ||
                    e.$$typeof === k$1 ||
                    e.$$typeof === n$1 ||
                    e.$$typeof === w ||
                    e.$$typeof === x ||
                    e.$$typeof === y ||
                    e.$$typeof === v$1))
        );
    }),
    (reactIs_production_min$1.typeOf = z),
    (reactIs$1.exports = reactIs_production_min$1);
var reactIsExports = reactIs$1.exports,
    reactIs = reactIsExports,
    FORWARD_REF_STATICS = {
        $$typeof: !0,
        render: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
    },
    MEMO_STATICS = {
        $$typeof: !0,
        compare: !0,
        defaultProps: !0,
        displayName: !0,
        propTypes: !0,
        type: !0,
    },
    TYPE_STATICS = {};
(TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS),
    (TYPE_STATICS[reactIs.Memo] = MEMO_STATICS);
var isBrowser = !0;
function getRegisteredStyles(e, t, n) {
    var r = "";
    return (
        n.split(" ").forEach(function (n) {
            void 0 !== e[n] ? t.push(e[n] + ";") : n && (r += n + " ");
        }),
        r
    );
}
var registerStyles = function (e, t, n) {
        var r = e.key + "-" + t.name;
        (!1 !== n && !1 !== isBrowser) ||
            void 0 !== e.registered[r] ||
            (e.registered[r] = t.styles);
    },
    insertStyles = function (e, t, n) {
        registerStyles(e, t, n);
        var r = e.key + "-" + t.name;
        if (void 0 === e.inserted[t.name]) {
            var i = t;
            do {
                e.insert(t === i ? "." + r : "", i, e.sheet, !0), (i = i.next);
            } while (void 0 !== i);
        }
    };
function murmur2(e) {
    for (var t, n = 0, r = 0, i = e.length; i >= 4; ++r, i -= 4)
        (t =
            1540483477 *
                (65535 &
                    (t =
                        (255 & e.charCodeAt(r)) |
                        ((255 & e.charCodeAt(++r)) << 8) |
                        ((255 & e.charCodeAt(++r)) << 16) |
                        ((255 & e.charCodeAt(++r)) << 24))) +
            ((59797 * (t >>> 16)) << 16)),
            (n =
                (1540483477 * (65535 & (t ^= t >>> 24)) +
                    ((59797 * (t >>> 16)) << 16)) ^
                (1540483477 * (65535 & n) + ((59797 * (n >>> 16)) << 16)));
    switch (i) {
        case 3:
            n ^= (255 & e.charCodeAt(r + 2)) << 16;
        case 2:
            n ^= (255 & e.charCodeAt(r + 1)) << 8;
        case 1:
            n =
                1540483477 * (65535 & (n ^= 255 & e.charCodeAt(r))) +
                ((59797 * (n >>> 16)) << 16);
    }
    return (
        ((n =
            1540483477 * (65535 & (n ^= n >>> 13)) +
            ((59797 * (n >>> 16)) << 16)) ^
            (n >>> 15)) >>>
        0
    ).toString(36);
}
var unitlessKeys = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        scale: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1,
    },
    isDevelopment$1 = !1,
    hyphenateRegex = /[A-Z]|^ms/g,
    animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
    isCustomProperty = function (e) {
        return 45 === e.charCodeAt(1);
    },
    isProcessableValue = function (e) {
        return null != e && "boolean" != typeof e;
    },
    processStyleName = memoize$1(function (e) {
        return isCustomProperty(e)
            ? e
            : e.replace(hyphenateRegex, "-$&").toLowerCase();
    }),
    processStyleValue = function (e, t) {
        switch (e) {
            case "animation":
            case "animationName":
                if ("string" == typeof t)
                    return t.replace(animationRegex, function (e, t, n) {
                        return (
                            (cursor = { name: t, styles: n, next: cursor }), t
                        );
                    });
        }
        return 1 === unitlessKeys[e] ||
            isCustomProperty(e) ||
            "number" != typeof t ||
            0 === t
            ? t
            : t + "px";
    },
    noComponentSelectorMessage =
        "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(e, t, n) {
    if (null == n) return "";
    var r = n;
    if (void 0 !== r.__emotion_styles) return r;
    switch (typeof n) {
        case "boolean":
            return "";
        case "object":
            var i = n;
            if (1 === i.anim)
                return (
                    (cursor = { name: i.name, styles: i.styles, next: cursor }),
                    i.name
                );
            var s = n;
            if (void 0 !== s.styles) {
                var a = s.next;
                if (void 0 !== a)
                    for (; void 0 !== a; )
                        (cursor = {
                            name: a.name,
                            styles: a.styles,
                            next: cursor,
                        }),
                            (a = a.next);
                return s.styles + ";";
            }
            return createStringFromObject(e, t, n);
        case "function":
            if (void 0 !== e) {
                var o = cursor,
                    l = n(e);
                return (cursor = o), handleInterpolation(e, t, l);
            }
    }
    var c = n;
    if (null == t) return c;
    var u = t[c];
    return void 0 !== u ? u : c;
}
function createStringFromObject(e, t, n) {
    var r = "";
    if (Array.isArray(n))
        for (var i = 0; i < n.length; i++)
            r += handleInterpolation(e, t, n[i]) + ";";
    else
        for (var s in n) {
            var a = n[s];
            if ("object" != typeof a) {
                var o = a;
                null != t && void 0 !== t[o]
                    ? (r += s + "{" + t[o] + "}")
                    : isProcessableValue(o) &&
                      (r +=
                          processStyleName(s) +
                          ":" +
                          processStyleValue(s, o) +
                          ";");
            } else {
                if ("NO_COMPONENT_SELECTOR" === s && isDevelopment$1)
                    throw new Error(noComponentSelectorMessage);
                if (
                    !Array.isArray(a) ||
                    "string" != typeof a[0] ||
                    (null != t && void 0 !== t[a[0]])
                ) {
                    var l = handleInterpolation(e, t, a);
                    switch (s) {
                        case "animation":
                        case "animationName":
                            r += processStyleName(s) + ":" + l + ";";
                            break;
                        default:
                            r += s + "{" + l + "}";
                    }
                } else
                    for (var c = 0; c < a.length; c++)
                        isProcessableValue(a[c]) &&
                            (r +=
                                processStyleName(s) +
                                ":" +
                                processStyleValue(s, a[c]) +
                                ";");
            }
        }
    return r;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g,
    cursor;
function serializeStyles(e, t, n) {
    if (
        1 === e.length &&
        "object" == typeof e[0] &&
        null !== e[0] &&
        void 0 !== e[0].styles
    )
        return e[0];
    var r = !0,
        i = "";
    cursor = void 0;
    var s = e[0];
    null == s || void 0 === s.raw
        ? ((r = !1), (i += handleInterpolation(n, t, s)))
        : (i += s[0]);
    for (var a = 1; a < e.length; a++) {
        if (((i += handleInterpolation(n, t, e[a])), r)) i += s[a];
    }
    labelPattern.lastIndex = 0;
    for (var o, l = ""; null !== (o = labelPattern.exec(i)); ) l += "-" + o[1];
    return { name: murmur2(i) + l, styles: i, next: cursor };
}
var syncFallback = function (e) {
        return e();
    },
    useInsertionEffect =
        !!React$2.useInsertionEffect && React$2.useInsertionEffect,
    useInsertionEffectAlwaysWithSyncFallback =
        useInsertionEffect || syncFallback,
    useInsertionEffectWithLayoutFallback =
        useInsertionEffect || reactExports.useLayoutEffect,
    EmotionCacheContext = reactExports.createContext(
        "undefined" != typeof HTMLElement ? createCache({ key: "css" }) : null
    );
EmotionCacheContext.Provider;
var withEmotionCache = function (e) {
        return reactExports.forwardRef(function (t, n) {
            var r = reactExports.useContext(EmotionCacheContext);
            return e(t, r, n);
        });
    },
    ThemeContext = reactExports.createContext({}),
    Global = withEmotionCache(function (e, t) {
        var n = serializeStyles(
                [e.styles],
                void 0,
                reactExports.useContext(ThemeContext)
            ),
            r = reactExports.useRef();
        return (
            useInsertionEffectWithLayoutFallback(
                function () {
                    var e = t.key + "-global",
                        i = new t.sheet.constructor({
                            key: e,
                            nonce: t.sheet.nonce,
                            container: t.sheet.container,
                            speedy: t.sheet.isSpeedy,
                        }),
                        s = !1,
                        a = document.querySelector(
                            'style[data-emotion="' + e + " " + n.name + '"]'
                        );
                    return (
                        t.sheet.tags.length && (i.before = t.sheet.tags[0]),
                        null !== a &&
                            ((s = !0),
                            a.setAttribute("data-emotion", e),
                            i.hydrate([a])),
                        (r.current = [i, s]),
                        function () {
                            i.flush();
                        }
                    );
                },
                [t]
            ),
            useInsertionEffectWithLayoutFallback(
                function () {
                    var e = r.current,
                        i = e[0];
                    if (e[1]) e[1] = !1;
                    else {
                        if (
                            (void 0 !== n.next && insertStyles(t, n.next, !0),
                            i.tags.length)
                        ) {
                            var s =
                                i.tags[i.tags.length - 1].nextElementSibling;
                            (i.before = s), i.flush();
                        }
                        t.insert("", n, i, !1);
                    }
                },
                [t, n.name]
            ),
            null
        );
    });
function css() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
    return serializeStyles(t);
}
var keyframes = function () {
        var e = css.apply(void 0, arguments),
            t = "animation-" + e.name;
        return {
            name: t,
            styles: "@keyframes " + t + "{" + e.styles + "}",
            anim: 1,
            toString: function () {
                return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
            },
        };
    },
    testOmitPropsOnStringTag = isPropValid,
    testOmitPropsOnComponent = function (e) {
        return "theme" !== e;
    },
    getDefaultShouldForwardProp = function (e) {
        return "string" == typeof e && e.charCodeAt(0) > 96
            ? testOmitPropsOnStringTag
            : testOmitPropsOnComponent;
    },
    composeShouldForwardProps = function (e, t, n) {
        var r;
        if (t) {
            var i = t.shouldForwardProp;
            r =
                e.__emotion_forwardProp && i
                    ? function (t) {
                          return e.__emotion_forwardProp(t) && i(t);
                      }
                    : i;
        }
        return "function" != typeof r && n && (r = e.__emotion_forwardProp), r;
    },
    isDevelopment = !1,
    Insertion = function (e) {
        var t = e.cache,
            n = e.serialized,
            r = e.isStringTag;
        return (
            registerStyles(t, n, r),
            useInsertionEffectAlwaysWithSyncFallback(function () {
                return insertStyles(t, n, r);
            }),
            null
        );
    },
    createStyled$1 = function e(t, n) {
        var r,
            i,
            s = t.__emotion_real === t,
            a = (s && t.__emotion_base) || t;
        void 0 !== n && ((r = n.label), (i = n.target));
        var o = composeShouldForwardProps(t, n, s),
            l = o || getDefaultShouldForwardProp(a),
            c = !l("as");
        return function () {
            var u = arguments,
                d =
                    s && void 0 !== t.__emotion_styles
                        ? t.__emotion_styles.slice(0)
                        : [];
            if (
                (void 0 !== r && d.push("label:" + r + ";"),
                null == u[0] || void 0 === u[0].raw)
            )
                d.push.apply(d, u);
            else {
                d.push(u[0][0]);
                for (var p = u.length, h = 1; h < p; h++) d.push(u[h], u[0][h]);
            }
            var f = withEmotionCache(function (e, t, n) {
                var r = (c && e.as) || a,
                    s = "",
                    u = [],
                    p = e;
                if (null == e.theme) {
                    for (var h in ((p = {}), e)) p[h] = e[h];
                    p.theme = reactExports.useContext(ThemeContext);
                }
                "string" == typeof e.className
                    ? (s = getRegisteredStyles(t.registered, u, e.className))
                    : null != e.className && (s = e.className + " ");
                var f = serializeStyles(d.concat(u), t.registered, p);
                (s += t.key + "-" + f.name), void 0 !== i && (s += " " + i);
                var m = c && void 0 === o ? getDefaultShouldForwardProp(r) : l,
                    g = {};
                for (var x in e) (c && "as" === x) || (m(x) && (g[x] = e[x]));
                return (
                    (g.className = s),
                    n && (g.ref = n),
                    reactExports.createElement(
                        reactExports.Fragment,
                        null,
                        reactExports.createElement(Insertion, {
                            cache: t,
                            serialized: f,
                            isStringTag: "string" == typeof r,
                        }),
                        reactExports.createElement(r, g)
                    )
                );
            });
            return (
                (f.displayName =
                    void 0 !== r
                        ? r
                        : "Styled(" +
                          ("string" == typeof a
                              ? a
                              : a.displayName || a.name || "Component") +
                          ")"),
                (f.defaultProps = t.defaultProps),
                (f.__emotion_real = f),
                (f.__emotion_base = a),
                (f.__emotion_styles = d),
                (f.__emotion_forwardProp = o),
                Object.defineProperty(f, "toString", {
                    value: function () {
                        return void 0 === i && isDevelopment
                            ? "NO_COMPONENT_SELECTOR"
                            : "." + i;
                    },
                }),
                (f.withComponent = function (t, r) {
                    return e(
                        t,
                        _extends({}, n, r, {
                            shouldForwardProp: composeShouldForwardProps(
                                f,
                                r,
                                !0
                            ),
                        })
                    ).apply(void 0, d);
                }),
                f
            );
        };
    },
    tags = [
        "a",
        "abbr",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "base",
        "bdi",
        "bdo",
        "big",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "keygen",
        "label",
        "legend",
        "li",
        "link",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meta",
        "meter",
        "nav",
        "noscript",
        "object",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "param",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "script",
        "section",
        "select",
        "small",
        "source",
        "span",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "track",
        "u",
        "ul",
        "var",
        "video",
        "wbr",
        "circle",
        "clipPath",
        "defs",
        "ellipse",
        "foreignObject",
        "g",
        "image",
        "line",
        "linearGradient",
        "mask",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "radialGradient",
        "rect",
        "stop",
        "svg",
        "text",
        "tspan",
    ],
    newStyled = createStyled$1.bind();
function isEmpty$2(e) {
    return null == e || 0 === Object.keys(e).length;
}
function GlobalStyles$2(e) {
    const { styles: t, defaultTheme: n = {} } = e,
        r = "function" == typeof t ? (e) => t(isEmpty$2(e) ? n : e) : t;
    return jsxRuntimeExports.jsx(Global, { styles: r });
}
/**
 * @mui/styled-engine v6.1.5
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function styled$2(e, t) {
    return newStyled(e, t);
}
function internal_mutateStyles(e, t) {
    Array.isArray(e.__emotion_styles) &&
        (e.__emotion_styles = t(e.__emotion_styles));
}
tags.forEach(function (e) {
    newStyled[e] = newStyled(e);
});
const wrapper = [];
function internal_serializeStyles(e) {
    return (wrapper[0] = e), serializeStyles(wrapper);
}
function isPlainObject(e) {
    if ("object" != typeof e || null === e) return !1;
    const t = Object.getPrototypeOf(e);
    return !(
        (null !== t &&
            t !== Object.prototype &&
            null !== Object.getPrototypeOf(t)) ||
        Symbol.toStringTag in e ||
        Symbol.iterator in e
    );
}
function deepClone(e) {
    if (!isPlainObject(e)) return e;
    const t = {};
    return (
        Object.keys(e).forEach((n) => {
            t[n] = deepClone(e[n]);
        }),
        t
    );
}
function deepmerge(e, t, n = { clone: !0 }) {
    const r = n.clone ? { ...e } : e;
    return (
        isPlainObject(e) &&
            isPlainObject(t) &&
            Object.keys(t).forEach((i) => {
                isPlainObject(t[i]) &&
                Object.prototype.hasOwnProperty.call(e, i) &&
                isPlainObject(e[i])
                    ? (r[i] = deepmerge(e[i], t[i], n))
                    : n.clone
                    ? (r[i] = isPlainObject(t[i]) ? deepClone(t[i]) : t[i])
                    : (r[i] = t[i]);
            }),
        r
    );
}
const sortBreakpointsValues = (e) => {
    const t = Object.keys(e).map((t) => ({ key: t, val: e[t] })) || [];
    return (
        t.sort((e, t) => e.val - t.val),
        t.reduce((e, t) => ({ ...e, [t.key]: t.val }), {})
    );
};
function createBreakpoints(e) {
    const {
            values: t = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
            unit: n = "px",
            step: r = 5,
            ...i
        } = e,
        s = sortBreakpointsValues(t),
        a = Object.keys(s);
    function o(e) {
        return `@media (min-width:${"number" == typeof t[e] ? t[e] : e}${n})`;
    }
    function l(e) {
        return `@media (max-width:${
            ("number" == typeof t[e] ? t[e] : e) - r / 100
        }${n})`;
    }
    function c(e, i) {
        const s = a.indexOf(i);
        return `@media (min-width:${
            "number" == typeof t[e] ? t[e] : e
        }${n}) and (max-width:${
            (-1 !== s && "number" == typeof t[a[s]] ? t[a[s]] : i) - r / 100
        }${n})`;
    }
    return {
        keys: a,
        values: s,
        up: o,
        down: l,
        between: c,
        only: function (e) {
            return a.indexOf(e) + 1 < a.length
                ? c(e, a[a.indexOf(e) + 1])
                : o(e);
        },
        not: function (e) {
            const t = a.indexOf(e);
            return 0 === t
                ? o(a[1])
                : t === a.length - 1
                ? l(a[t])
                : c(e, a[a.indexOf(e) + 1]).replace(
                      "@media",
                      "@media not all and"
                  );
        },
        unit: n,
        ...i,
    };
}
function sortContainerQueries(e, t) {
    if (!e.containerQueries) return t;
    const n = Object.keys(t)
        .filter((e) => e.startsWith("@container"))
        .sort((e, t) => {
            var n, r;
            const i = /min-width:\s*([0-9.]+)/;
            return (
                +((null == (n = e.match(i)) ? void 0 : n[1]) || 0) -
                +((null == (r = t.match(i)) ? void 0 : r[1]) || 0)
            );
        });
    return n.length
        ? n.reduce(
              (e, n) => {
                  const r = t[n];
                  return delete e[n], (e[n] = r), e;
              },
              { ...t }
          )
        : t;
}
function isCqShorthand(e, t) {
    return (
        "@" === t ||
        (t.startsWith("@") &&
            (e.some((e) => t.startsWith(`@${e}`)) || !!t.match(/^@\d/)))
    );
}
function getContainerQuery(e, t) {
    const n = t.match(/^@([^/]+)?\/?(.+)?$/);
    if (!n) return null;
    const [, r, i] = n,
        s = Number.isNaN(+r) ? r || 0 : +r;
    return e.containerQueries(i).up(s);
}
function cssContainerQueries(e) {
    const t = (e, t) =>
        e.replace("@media", t ? `@container ${t}` : "@container");
    function n(n, r) {
        (n.up = (...n) => t(e.breakpoints.up(...n), r)),
            (n.down = (...n) => t(e.breakpoints.down(...n), r)),
            (n.between = (...n) => t(e.breakpoints.between(...n), r)),
            (n.only = (...n) => t(e.breakpoints.only(...n), r)),
            (n.not = (...n) => {
                const i = t(e.breakpoints.not(...n), r);
                return i.includes("not all and")
                    ? i
                          .replace("not all and ", "")
                          .replace("min-width:", "width<")
                          .replace("max-width:", "width>")
                          .replace("and", "or")
                    : i;
            });
    }
    const r = {},
        i = (e) => (n(r, e), r);
    return n(i), { ...e, containerQueries: i };
}
const shape = { borderRadius: 4 };
function merge(e, t) {
    return t ? deepmerge(e, t, { clone: !1 }) : e;
}
const values$1 = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
    defaultBreakpoints = {
        keys: ["xs", "sm", "md", "lg", "xl"],
        up: (e) => `@media (min-width:${values$1[e]}px)`,
    },
    defaultContainerQueries = {
        containerQueries: (e) => ({
            up: (t) => {
                let n = "number" == typeof t ? t : values$1[t] || t;
                return (
                    "number" == typeof n && (n = `${n}px`),
                    e
                        ? `@container ${e} (min-width:${n})`
                        : `@container (min-width:${n})`
                );
            },
        }),
    };
function handleBreakpoints(e, t, n) {
    const r = e.theme || {};
    if (Array.isArray(t)) {
        const e = r.breakpoints || defaultBreakpoints;
        return t.reduce((r, i, s) => ((r[e.up(e.keys[s])] = n(t[s])), r), {});
    }
    if ("object" == typeof t) {
        const e = r.breakpoints || defaultBreakpoints;
        return Object.keys(t).reduce((i, s) => {
            if (isCqShorthand(e.keys, s)) {
                const e = getContainerQuery(
                    r.containerQueries ? r : defaultContainerQueries,
                    s
                );
                e && (i[e] = n(t[s], s));
            } else if (Object.keys(e.values || values$1).includes(s)) {
                i[e.up(s)] = n(t[s], s);
            } else {
                const e = s;
                i[e] = t[e];
            }
            return i;
        }, {});
    }
    return n(t);
}
function createEmptyBreakpointObject(e = {}) {
    var t;
    return (
        (null == (t = e.keys)
            ? void 0
            : t.reduce((t, n) => ((t[e.up(n)] = {}), t), {})) || {}
    );
}
function removeUnusedBreakpoints(e, t) {
    return e.reduce((e, t) => {
        const n = e[t];
        return (!n || 0 === Object.keys(n).length) && delete e[t], e;
    }, t);
}
function mergeBreakpointsInOrder(e, ...t) {
    const n = createEmptyBreakpointObject(e),
        r = [n, ...t].reduce((e, t) => deepmerge(e, t), {});
    return removeUnusedBreakpoints(Object.keys(n), r);
}
function computeBreakpointsBase(e, t) {
    if ("object" != typeof e) return {};
    const n = {},
        r = Object.keys(t);
    return (
        Array.isArray(e)
            ? r.forEach((t, r) => {
                  r < e.length && (n[t] = !0);
              })
            : r.forEach((t) => {
                  null != e[t] && (n[t] = !0);
              }),
        n
    );
}
function resolveBreakpointValues({ values: e, breakpoints: t, base: n }) {
    const r = n || computeBreakpointsBase(e, t),
        i = Object.keys(r);
    if (0 === i.length) return e;
    let s;
    return i.reduce(
        (t, n, r) => (
            Array.isArray(e)
                ? ((t[n] = null != e[r] ? e[r] : e[s]), (s = r))
                : "object" == typeof e
                ? ((t[n] = null != e[n] ? e[n] : e[s]), (s = n))
                : (t[n] = e),
            t
        ),
        {}
    );
}
function capitalize(e) {
    if ("string" != typeof e) throw new Error(formatMuiErrorMessage(7));
    return e.charAt(0).toUpperCase() + e.slice(1);
}
function getPath(e, t, n = !0) {
    if (!t || "string" != typeof t) return null;
    if (e && e.vars && n) {
        const n = `vars.${t}`
            .split(".")
            .reduce((e, t) => (e && e[t] ? e[t] : null), e);
        if (null != n) return n;
    }
    return t.split(".").reduce((e, t) => (e && null != e[t] ? e[t] : null), e);
}
function getStyleValue$1(e, t, n, r = n) {
    let i;
    return (
        (i =
            "function" == typeof e
                ? e(n)
                : Array.isArray(e)
                ? e[n] || r
                : getPath(e, n) || r),
        t && (i = t(i, r, e)),
        i
    );
}
function style$2(e) {
    const { prop: t, cssProperty: n = e.prop, themeKey: r, transform: i } = e,
        s = (e) => {
            if (null == e[t]) return null;
            const s = e[t],
                a = getPath(e.theme, r) || {};
            return handleBreakpoints(e, s, (e) => {
                let r = getStyleValue$1(a, i, e);
                return (
                    e === r &&
                        "string" == typeof e &&
                        (r = getStyleValue$1(
                            a,
                            i,
                            `${t}${"default" === e ? "" : capitalize(e)}`,
                            e
                        )),
                    !1 === n ? r : { [n]: r }
                );
            });
        };
    return (s.propTypes = {}), (s.filterProps = [t]), s;
}
function memoize(e) {
    const t = {};
    return (n) => (void 0 === t[n] && (t[n] = e(n)), t[n]);
}
const properties = { m: "margin", p: "padding" },
    directions = {
        t: "Top",
        r: "Right",
        b: "Bottom",
        l: "Left",
        x: ["Left", "Right"],
        y: ["Top", "Bottom"],
    },
    aliases = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" },
    getCssProperties = memoize((e) => {
        if (e.length > 2) {
            if (!aliases[e]) return [e];
            e = aliases[e];
        }
        const [t, n] = e.split(""),
            r = properties[t],
            i = directions[n] || "";
        return Array.isArray(i) ? i.map((e) => r + e) : [r + i];
    }),
    marginKeys = [
        "m",
        "mt",
        "mr",
        "mb",
        "ml",
        "mx",
        "my",
        "margin",
        "marginTop",
        "marginRight",
        "marginBottom",
        "marginLeft",
        "marginX",
        "marginY",
        "marginInline",
        "marginInlineStart",
        "marginInlineEnd",
        "marginBlock",
        "marginBlockStart",
        "marginBlockEnd",
    ],
    paddingKeys = [
        "p",
        "pt",
        "pr",
        "pb",
        "pl",
        "px",
        "py",
        "padding",
        "paddingTop",
        "paddingRight",
        "paddingBottom",
        "paddingLeft",
        "paddingX",
        "paddingY",
        "paddingInline",
        "paddingInlineStart",
        "paddingInlineEnd",
        "paddingBlock",
        "paddingBlockStart",
        "paddingBlockEnd",
    ];
function createUnaryUnit(e, t, n, r) {
    const i = getPath(e, t, !0) ?? n;
    return "number" == typeof i || "string" == typeof i
        ? (e) =>
              "string" == typeof e
                  ? e
                  : "string" == typeof i
                  ? `calc(${e} * ${i})`
                  : i * e
        : Array.isArray(i)
        ? (e) => {
              if ("string" == typeof e) return e;
              const t = Math.abs(e),
                  n = i[t];
              return e >= 0 ? n : "number" == typeof n ? -n : `-${n}`;
          }
        : "function" == typeof i
        ? i
        : () => {};
}
function createUnarySpacing(e) {
    return createUnaryUnit(e, "spacing", 8);
}
function getValue(e, t) {
    return "string" == typeof t || null == t ? t : e(t);
}
function getStyleFromPropValue(e, t) {
    return (n) => e.reduce((e, r) => ((e[r] = getValue(t, n)), e), {});
}
function resolveCssProperty(e, t, n, r) {
    if (!t.includes(n)) return null;
    const i = getStyleFromPropValue(getCssProperties(n), r);
    return handleBreakpoints(e, e[n], i);
}
function style$1(e, t) {
    const n = createUnarySpacing(e.tle("borderTopColor"),
    borderRightColor = createBorderStyle("borderRightColor"),
    borderBottomColor = createBorderStyle("borderBottomColor"),
    borderLeftColor = createBorderStyle("borderLeftColor"),
    outline = createBorderStyle("outline", borderTransform),
    outlineColor = createBorderStyle("outlineColor"),
    borderRadius = (e) => {
        if (void 0 !== e.borderRadius && null !== e.borderRadius) {
            const t = createUnaryUnit(e.theme, "shape.borderRadius", 4),
                n = (e) => ({ borderRadius: getValue(t, e) });
            return handleBreakpoints(e, e.borderRadius, n);
        }
        return null;
    };
(borderRadius.propTypes = {}),
    (borderRadius.filterProps = ["borderRadius"]),
    compose(
        border,
        borderTop,
        borderRight,
        borderBottom,
        borderLeft,
        borderColor,
        borderTopColor,
        borderRightColor,
        borderBottomColor,
        borderLeftColor,
        borderRadius,
        outline,
        outlineColor
    );
const gap = (e) => {
    if (void 0 !== e.gap && null !== e.gap) {
        const t = createUnaryUnit(e.theme, "spacing", 8),
            n = (e) => ({ gap: getValue(t, e) });
        return handleBreakpoints(e, e.gap, n);
    }
    return null;
};
(gap.propTypes = {}), (gap.filterProps = ["gap"]);
const columnGap = (e) => {
    if (void 0 !== e.columnGap && null !== e.columnGap) {
        const t = createUnaryUnit(e.theme, "spacing", 8),
            n = (e) => ({ columnGap: getValue(t, e) });
        return handleBreakpoints(e, e.columnGap, n);
    }
    return null;
};
(columnGap.propTypes = {}), (columnGap.filterProps = ["columnGap"]);
const rowGap = (e) => {
    if (void 0 !== e.rowGap && null !== e.rowGap) {
        const t = createUnaryUnit(e.theme, "spacing", 8),
            n = (e) => ({ rowGap: getValue(t, e) });
        return handleBreakpoints(e, e.rowGap, n);
    }
    return null;
};
(rowGap.propTypes = {}), (rowGap.filterProps = ["rowGap"]);
const gridColumn = style$2({ prop: "gridColumn" }),
    gridRow = style$2({ prop: "gridRow" }),
    gridAutoFlow = style$2({ prop: "gridAutoFlow" }),
    gridAutoColumns = style$2({ prop: "gridAutoColumns" }),
    gridAutoRows = style$2({ prop: "gridAutoRows" }),
    gridTemplateColumns = style$2({ prop: "gridTemplateColumns" }),
    gridTemplateRows = style$2({ prop: "gridTemplateRows" }),
    gridTemplateAreas = style$2({ prop: "gridTemplateAreas" }),
    gridArea = style$2({ prop: "gridArea" });
function paletteTransform(e, t) {
    return "grey" === t ? t : e;
}
compose(
    gap,
    columnGap,
    rowGap,
    gridColumn,
    gridRow,
    gridAutoFlow,
    gridAutoColumns,
    gridAutoRows,
    gridTemplateColumns,
    gridTemplateRows,
    gridTemplateAreas,
    gridArea
);
const color = style$2({
        prop: "color",
        themeKey: "palette",
        transform: paletteTransform,
    }),
    bgcolor = style$2({
        prop: "bgcolor",
        cssProperty: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform,
    }),
    backgroundColor = style$2({
        prop: "backgroundColor",
        themeKey: "palette",
        transform: paletteTransform,
    });
function sizingTransform(e) {
    return e <= 1 && 0 !== e ? 100 * e + "%" : e;
}
compose(color, bgcolor, backgroundColor);
const width = style$2({ prop: "width", transform: sizingTransform }),
    maxWidth = (e) => {
        if (void 0 !== e.maxWidth && null !== e.maxWidth) {
            const t = (t) => {
                var n, r, i, s, a;
                const o =
                    (null ==
                    (i =
                        null ==
                        (r = null == (n = e.theme) ? void 0 : n.breakpoints)
                            ? void 0
                            : r.values)
                        ? void 0
                        : i[t]) || values$1[t];
                return o
                    ? "px" !==
                      (null ==
                      (a = null == (s = e.theme) ? void 0 : s.breakpoints)
                          ? void 0
                          : a.unit)
                        ? { maxWidth: `${o}${e.theme.breakpoints.unit}` }
                        : { maxWidth: o }
                    : { maxWidth: sizingTransform(t) };
            };
            return handleBreakpoints(e, e.maxWidth, t);
        }
        return null;
    };
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({ prop: "minWidth", transform: sizingTransform }),
    height = style$2({ prop: "height", transform: sizingTransform }),
    maxHeight = style$2({ prop: "maxHeight", transform: sizingTransform }),
    minHeight = style$2({ prop: "minHeight", transform: sizingTransform });
style$2({ prop: "size", cssProperty: "width", transform: sizingTransform }),
    style$2({
        prop: "size",
        cssProperty: "height",
        transform: sizingTransform,
    });
const boxSizing = style$2({ prop: "boxSizing" });
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    border: { themeKey: "borders", transform: borderTransform },
    borderTop: { themeKey: "borders", transform: borderTransform },
    borderRight: { themeKey: "borders", transform: borderTransform },
    borderBottom: { themeKey: "borders", transform: borderTransform },
    borderLeft: { themeKey: "borders", transform: borderTransform },
    borderColor: { themeKey: "palette" },
    borderTopColor: { themeKey: "palette" },
    borderRightColor: { themeKey: "palette" },
    borderBottomColor: { themeKey: "palette" },
    borderLeftColor: { themeKey: "palette" },
    outline: { themeKey: "borders", transform: borderTransform },
    outlineColor: { themeKey: "palette" },
    borderRadius: { themeKey: "shape.borderRadius", style: borderRadius },
    color: { themeKey: "palette", transform: paletteTransform },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform,
    },
    backgroundColor: { themeKey: "palette", transform: paletteTransform },
    p: { style: padding },
    pt: { style: padding },
    pr: { style: padding },
    pb: { style: padding },
    pl: { style: padding },
    px: { style: padding },
    py: { style: padding },
    padding: { style: padding },
    paddingTop: { style: padding },
    paddingRight: { style: padding },
    paddingBottom: { style: padding },
    paddingLeft: { style: padding },
    paddingX: { style: padding },
    paddingY: { style: padding },
    paddingInline: { style: padding },
    paddingInlineStart: { style: padding },
    paddingInlineEnd: { style: padding },
    paddingBlock: { style: padding },
    paddingBlockStart: { style: padding },
    paddingBlockEnd: { style: padding },
    m: { style: margin },
    mt: { style: margin },
    mr: { style: margin },
    mb: { style: margin },
    ml: { style: margin },
    mx: { style: margin },
    my: { style: margin },
    margin: { style: margin },
    marginTop: { style: margin },
    marginRight: { style: margin },
    marginBottom: { style: margin },
    marginLeft: { style: margin },
    marginX: { style: margin },
    marginY: { style: margin },
    marginInline: { style: margin },
    marginInlineStart: { style: margin },
    marginInlineEnd: { style: margin },
    marginBlock: { style: margin },
    marginBlockStart: { style: margin },
    marginBlockEnd: { style: margin },
    displayPrint: {
        cssProperty: !1,
        transform: (e) => ({ "@media print": { display: e } }),
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: { style: gap },
    rowGap: { style: rowGap },
    columnGap: { style: columnGap },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: { themeKey: "zIndex" },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: { themeKey: "shadows" },
    width: { transform: sizingTransform },
    maxWidth: { style: maxWidth },
    minWidth: { transform: sizingTransform },
    height: { transform: sizingTransform },
    maxHeight: { transform: sizingTransform },
    minHeight: { transform: sizingTransform },
    boxSizing: {},
    font: { themeKey: "font" },
    fontFamily: { themeKey: "typography" },
    fontSize: { themeKey: "typography" },
    fontStyle: { themeKey: "typography" },
    fontWeight: { themeKey: "typography" },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: { cssProperty: !1, themeKey: "typography" },
};
function objectsHaveSameKeys(...e) {
    const t = e.reduce((e, t) => e.concat(Object.keys(t)), []),
        n = new Set(t);
    return e.every((e) => n.size === Object.keys(e).length);
}
function callIfFn(e, t) {
    return "function" == typeof e ? e(t) : e;
}
function unstable_createStyleFunctionSx() {
    function e(e, t, n, r) {
        const i = { [e]: t, theme: n },
            s = r[e];
        if (!s) return { [e]: t };
        const { cssProperty: a = e, themeKey: o, transform: l, style: c } = s;
        if (null == t) return null;
        if ("typography" === o && "inherit" === t) return { [e]: t };
        const u = getPath(n, o) || {};
        if (c) return c(i);
        return handleBreakpoints(i, t, (t) => {
            let n = getStyleValue$1(u, l, t);
            return (
                t === n &&
                    "string" == typeof t &&
                    (n = getStyleValue$1(
                        u,
                        l,
                        `${e}${"default" === t ? "" : capitalize(t)}`,
                        t
                    )),
                !1 === a ? n : { [a]: n }
            );
        });
    }
    return function t(n) {
        const { sx: r, theme: i = {} } = n || {};
        if (!r) return null;
        const s = i.unstable_sxConfig ?? defaultSxConfig;
        function a(n) {
            let r = n;
            if ("function" == typeof n) r = n(i);
            else if ("object" != typeof n) return n;
            if (!r) return null;
            const a = createEmptyBreakpointObject(i.breakpoints),
                o = Object.keys(a);
            let l = a;
            return (
                Object.keys(r).forEach((n) => {
                    const a = callIfFn(r[n], i);
                    if (null != a)
                        if ("object" == typeof a)
                            if (s[n]) l = merge(l, e(n, a, i, s));
                            else {
                                const e = handleBreakpoints(
                                    { theme: i },
                                    a,
                                    (e) => ({ [n]: e })
                                );
                                objectsHaveSameKeys(e, a)
                                    ? (l[n] = t({ sx: a, theme: i }))
                                    : (l = merge(l, e));
                            }
                        else l = merge(l, e(n, a, i, s));
                }),
                sortContainerQueries(i, removeUnusedBreakpoints(o, l))
            );
        }
        return Array.isArray(r) ? r.map(a) : a(r);
    };
}
const styleFunctionSx = unstable_createStyleFunctionSx();
function applyStyles$2(e, t) {
    var n;
    const r = this;
    if (r.vars) {
        if (
            !(null == (n = r.colorSchemes) ? void 0 : n[e]) ||
            "function" != typeof r.getColorSchemeSelector
        )
            return {};
        let i = r.getColorSchemeSelector(e);
        return "&" === i
            ? t
            : ((i.includes("data-") || i.includes(".")) &&
                  (i = `*:where(${i.replace(/\s*&$/, "")}) &`),
              { [i]: t });
    }
    return r.palette.mode === e ? t : {};
}
function createTheme$1(e = {}, ...t) {
    const {
        breakpoints: n = {},
        palette: r = {},
        spacing: i,
        shape: s = {},
        ...a
    } = e;
    let o = deepmerge(
        {
            breakpoints: createBreakpoints(n),
            direction: "ltr",
            components: {},
            palette: { mode: "light", ...r },
            spacing: createSpacing(i),
            shape: { ...shape, ...s },
        },
        a
    );
    return (
        (o = cssContainerQueries(o)),
        (o.applyStyles = applyStyles$2),
        (o = t.reduce((e, t) => deepmerge(e, t), o)),
        (o.unstable_sxConfig = {
            ...defaultSxConfig,
            ...(null == a ? void 0 : a.unstable_sxConfig),
        }),
        (o.unstable_sx = function (e) {
            return styleFunctionSx({ sx: e, theme: this });
        }),
        o
    );
}
function isObjectEmpty$1(e) {
    return 0 === Object.keys(e).length;
}
function useTheme$2(e = null) {
    const t = reactExports.useContext(ThemeContext);
    return !t || isObjectEmpty$1(t) ? e : t;
}
styleFunctionSx.filterProps = ["sx"];
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(e = systemDefaultTheme$1) {
    return useTheme$2(e);
}
function GlobalStyles$1({ styles: e, themeId: t, defaultTheme: n = {} }) {
    const r = useTheme$1(n),
        i = "function" == typeof e ? e((t && r[t]) || r) : e;
    return jsxRuntimeExports.jsx(GlobalStyles$2, { styles: i });
}
const splitProps = (e) => {
    var t;
    const n = { systemProps: {}, otherProps: {} },
        r =
            (null == (t = null == e ? void 0 : e.theme)
                ? void 0
                : t.unstable_sxConfig) ?? defaultSxConfig;
    return (
        Object.keys(e).forEach((t) => {
            r[t] ? (n.systemProps[t] = e[t]) : (n.otherProps[t] = e[t]);
        }),
        n
    );
};
function extendSxProp$1(e) {
    const { sx: t, ...n } = e,
        { systemProps: r, otherProps: i } = splitProps(n);
    let s;
    return (
        (s = Array.isArray(t)
            ? [r, ...t]
            : "function" == typeof t
            ? (...e) => {
                  const n = t(...e);
                  return isPlainObject(n) ? { ...r, ...n } : r;
              }
            : { ...r, ...t }),
        { ...i, sx: s }
    );
}
const defaultGenerator = (e) => e,
    createClassNameGenerator = () => {
        let e = defaultGenerator;
        return {
            configure(t) {
                e = t;
            },
            generate: (t) => e(t),
            reset() {
                e = defaultGenerator;
            },
        };
    },
    ClassNameGenerator = createClassNameGenerator();
function createBox(e = {}) {
    const {
            themeId: t,
            defaultTheme: n,
            defaultClassName: r = "MuiBox-root",
            generateClassName: i,
        } = e,
        s = styled$2("div", {
            shouldForwardProp: (e) => "theme" !== e && "sx" !== e && "as" !== e,
        })(styleFunctionSx);
    return reactExports.forwardRef(function (e, a) {
        const o = useTheme$1(n),
            { className: l, component: c = "div", ...u } = extendSxProp$1(e);
        return jsxRuntimeExports.jsx(s, {
            as: c,
            ref: a,
            className: clsx(l, i ? i(r) : r),
            theme: (t && o[t]) || o,
            ...u,
        });
    });
}
const globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected",
};
function generateUtilityClass(e, t, n = "Mui") {
    const r = globalStateClasses[t];
    return r ? `${n}-${r}` : `${ClassNameGenerator.generate(e)}-${t}`;
}
function generateUtilityClasses(e, t, n = "Mui") {
    const r = {};
    return (
        t.forEach((t) => {
            r[t] = generateUtilityClass(e, t, n);
        }),
        r
    );
}
var reactIs_production_min = {},
    b = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    d = Symbol.for("react.fragment"),
    e = Symbol.for("react.strict_mode"),
    f = Symbol.for("react.profiler"),
    g = Symbol.for("react.provider"),
    h = Symbol.for("react.context"),
    k = Symbol.for("react.server_context"),
    l = Symbol.for("react.forward_ref"),
    m = Symbol.for("react.suspense"),
    n = Symbol.for("react.suspense_list"),
    p = Symbol.for("react.memo"),
    q = Symbol.for("react.lazy"),
    t = Symbol.for("react.offscreen"),
    u;
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ function v(t) {
    if ("object" == typeof t && null !== t) {
        var r = t.$$typeof;
        switch (r) {
            case b:
                switch ((t = t.type)) {
                    case d:
                    case f:
                    case e:
                    case m:
                    case n:
                        return t;
                    default:
                        switch ((t = t && t.$$typeof)) {
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g:
                                return t;
                            default:
                                return r;
                        }
                }
            case c:
                return r;
        }
    }
}
function preprocessStyles(e) {
    const { variants: t, ...n } = e,
        r = {
            variants: t,
            style: internal_serializeStyles(n),
            isProcessed: !0,
        };
    return (
        r.style === n ||
            (t &&
                t.forEach((e) => {
                    "function" != typeof e.style &&
                        (e.style = internal_serializeStyles(e.style));
                })),
        r
    );
}
(u = Symbol.for("react.module.reference")),
    (reactIs_production_min.ContextConsumer = h),
    (reactIs_production_min.ContextProvider = g),
    (reactIs_production_min.Element = b),
    (reactIs_production_min.ForwardRef = l),
    (reactIs_production_min.Fragment = d),
    (reactIs_production_min.Lazy = q),
    (reactIs_production_min.Memo = p),
    (reactIs_production_min.Portal = c),
    (reactIs_production_min.Profiler = f),
    (reactIs_production_min.StrictMode = e),
    (reactIs_production_min.Suspense = m),
    (reactIs_production_min.SuspenseList = n),
    (reactIs_production_min.isAsyncMode = function () {
        return !1;
    }),
    (reactIs_production_min.isConcurrentMode = function () {
        return !1;
    }),
    (reactIs_production_min.isContextConsumer = function (e) {
        return v(e) === h;
    }),
    (reactIs_production_min.isContextProvider = function (e) {
        return v(e) === g;
    }),
    (reactIs_production_min.isElement = function (e) {
        return "object" == typeof e && null !== e && e.$$typeof === b;
    }),
    (reactIs_production_min.isForwardRef = function (e) {
        return v(e) === l;
    }),
    (reactIs_production_min.isFragment = function (e) {
        return v(e) === d;
    }),
    (reactIs_production_min.isLazy = function (e) {
        return v(e) === q;
    }),
    (reactIs_production_min.isMemo = function (e) {
        return v(e) === p;
    }),
    (reactIs_production_min.isPortal = function (e) {
        return v(e) === c;
    }),
    (reactIs_production_min.isProfiler = function (e) {
        return v(e) === f;
    }),
    (reactIs_production_min.isStrictMode = function (t) {
        return v(t) === e;
    }),
    (reactIs_production_min.isSuspense = function (e) {
        return v(e) === m;
    }),
    (reactIs_production_min.isSuspenseList = function (e) {
        return v(e) === n;
    }),
    (reactIs_production_min.isValidElementType = function (r) {
        return (
            "string" == typeof r ||
            "function" == typeof r ||
            r === d ||
            r === f ||
            r === e ||
            r === m ||
            r === n ||
            r === t ||
            ("object" == typeof r &&
                null !== r &&
                (r.$$typeof === q ||
                    r.$$typeof === p ||
                    r.$$typeof === g ||
                    r.$$typeof === h ||
                    r.$$typeof === l ||
                    r.$$typeof === u ||
                    void 0 !== r.getModuleId))
        );
    }),
    (reactIs_production_min.typeOf = v);
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(e) {
    return "ownerState" !== e && "theme" !== e && "sx" !== e && "as" !== e;
}
function defaultOverridesResolver(e) {
    return e ? (t, n) => n[e] : null;
}
function attachTheme(e, t, n) {
    e.theme = isObjectEmpty(e.theme) ? n : e.theme[t] || e.theme;
}
function processStyle(e, t) {
    const n = "function" == typeof t ? t(e) : t;
    if (Array.isArray(n)) return n.flatMap((t) => processStyle(e, t));
    if (Array.isArray(null == n ? void 0 : n.variants)) {
        let t;
        if (n.isProcessed) t = n.style;
        else {
            const { variants: e, ...r } = n;
            t = r;
        }
        return processStyleVariants(e, n.variants, [t]);
    }
    return (null == n ? void 0 : n.isProcessed) ? n.style : n;
}
function processStyleVariants(e, t, n = []) {
    var r;
    let i;
    e: for (let s = 0; s < t.length; s += 1) {
        const a = t[s];
        if ("function" == typeof a.props) {
            if (
                (i ?? (i = { ...e, ...e.ownerState, ownerState: e.ownerState }),
                !a.props(i))
            )
                continue;
        } else
            for (const t in a.props)
                if (
                    e[t] !== a.props[t] &&
                    (null == (r = e.ownerState) ? void 0 : r[t]) !== a.props[t]
                )
                    continue e;
        "function" == typeof a.style
            ? (i ?? (i = { ...e, ...e.ownerState, ownerState: e.ownerState }),
              n.push(a.style(i)))
            : n.push(a.style);
    }
    return n;
}
function createStyled(e = {}) {
    const {
        themeId: t,
        defaultTheme: n = systemDefaultTheme,
        rootShouldForwardProp: r = shouldForwardProp,
        slotShouldForwardProp: i = shouldForwardProp,
    } = e;
    function s(e) {
        attachTheme(e, t, n);
    }
    return (e, t = {}) => {
        internal_mutateStyles(e, (e) => e.filter((e) => e !== styleFunctionSx));
        const {
                name: n,
                slot: a,
                skipVariantsResolver: o,
                skipSx: l,
                overridesResolver: c = defaultOverridesResolver(
                    lowercaseFirstLetter(a)
                ),
                ...u
            } = t,
            d = void 0 !== o ? o : (a && "Root" !== a && "root" !== a) || !1,
            p = l || !1;
        let h = shouldForwardProp;
        "Root" === a || "root" === a
            ? (h = r)
            : a
            ? (h = i)
            : isStringTag(e) && (h = void 0);
        const f = styled$2(e, {
                shouldForwardProp: h,
                label: generateStyledLabel(),
                ...u,
            }),
            m = (e) => {
                if ("function" == typeof e && e.__emotion_real !== e)
                    return function (t) {
                        return processStyle(t, e);
                    };
                if (isPlainObject(e)) {
                    const t = preprocessStyles(e);
                    return t.variants
                        ? function (e) {
                              return processStyle(e, t);
                          }
                        : t.style;
                }
                return e;
            },
            g = (...t) => {
                const r = [],
                    i = t.map(m),
                    a = [];
                if (
                    (r.push(s),
                    n &&
                        c &&
                        a.push(function (e) {
                            var t, r;
                            const i =
                                null ==
                                (r =
                                    null == (t = e.theme.components)
                                        ? void 0
                                        : t[n])
                                    ? void 0
                                    : r.styleOverrides;
                            if (!i) return null;
                            const s = {};
                            for (const n in i) s[n] = processStyle(e, i[n]);
                            return c(e, s);
                        }),
                    n &&
                        !d &&
                        a.push(function (e) {
                            var t, r;
                            const i = e.theme,
                                s =
                                    null ==
                                    (r =
                                        null ==
                                        (t = null == i ? void 0 : i.components)
                                            ? void 0
                                            : t[n])
                                        ? void 0
                                        : r.variants;
                            return s ? processStyleVariants(e, s) : null;
                        }),
                    p || a.push(styleFunctionSx),
                    Array.isArray(i[0]))
                ) {
                    const e = i.shift(),
                        t = new Array(r.length).fill(""),
                        n = new Array(a.length).fill("");
                    let s;
                    (s = [...t, ...e, ...n]),
                        (s.raw = [...t, ...e.raw, ...n]),
                        r.unshift(s);
                }
                const o = [...r, ...i, ...a],
                    l = f(...o);
                return e.muiName && (l.muiName = e.muiName), l;
            };
        return f.withConfig && (g.withConfig = f.withConfig), g;
    };
}
function generateStyledLabel(e, t) {}
function isObjectEmpty(e) {
    for (const t in e) return !1;
    return !0;
}
function isStringTag(e) {
    return "string" == typeof e && e.charCodeAt(0) > 96;
}
function lowercaseFirstLetter(e) {
    return e ? e.charAt(0).toLowerCase() + e.slice(1) : e;
}
const styled$1 = createStyled();
function resolveProps(e, t) {
    const n = { ...t };
    for (const r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
            const i = r;
            if ("components" === i || "slots" === i)
                n[i] = { ...e[i], ...n[i] };
            else if ("componentsProps" === i || "slotProps" === i) {
                const r = e[i],
                    s = t[i];
                if (s)
                    if (r) {
                        n[i] = { ...s };
                        for (const e in r)
                            if (Object.prototype.hasOwnProperty.call(r, e)) {
                                const t = e;
                                n[i][t] = resolveProps(r[t], s[t]);
                            }
                    } else n[i] = s;
                else n[i] = r || {};
            } else void 0 === n[i] && (n[i] = e[i]);
        }
    return n;
}
function getThemeProps$1(e) {
    const { theme: t, name: n, props: r } = e;
    return t && t.components && t.components[n] && t.components[n].defaultProps
        ? resolveProps(t.components[n].defaultProps, r)
        : r;
}
function useThemeProps$1({ props: e, name: t, defaultTheme: n, themeId: r }) {
    let i = useTheme$1(n);
    return (
        r && (i = i[r] || i), getThemeProps$1({ theme: i, name: t, props: e })
    );
}
const useEnhancedEffect =
    "undefined" != typeof window
        ? reactExports.useLayoutEffect
        : reactExports.useEffect;
function clamp(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n));
}
function clampWrapper(e, t = 0, n = 1) {
    return clamp(e, t, n);
}
function hexToRgb(e) {
    e = e.slice(1);
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
    let n = e.match(t);
    return (
        n && 1 === n[0].length && (n = n.map((e) => e + e)),
        n
            ? `rgb${4 === n.length ? "a" : ""}(${n
                  .map((e, t) =>
                      t < 3
                          ? parseInt(e, 16)
                          : Math.round((parseInt(e, 16) / 255) * 1e3) / 1e3
                  )
                  .join(", ")})`
            : ""
    );
}
function decomposeColor(e) {
    if (e.type) return e;
    if ("#" === e.charAt(0)) return decomposeColor(hexToRgb(e));
    const t = e.indexOf("("),
        n = e.substring(0, t);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
        throw new Error(formatMuiErrorMessage(9, e));
    let r,
        i = e.substring(t + 1, e.length - 1);
    if ("color" === n) {
        if (
            ((i = i.split(" ")),
            (r = i.shift()),
            4 === i.length && "/" === i[3].charAt(0) && (i[3] = i[3].slice(1)),
            ![
                "srgb",
                "display-p3",
                "a98-rgb",
                "prophoto-rgb",
                "rec-2020",
            ].includes(r))
        )
            throw new Error(formatMuiErrorMessage(10, r));
    } else i = i.split(",");
    return (
        (i = i.map((e) => parseFloat(e))), { type: n, values: i, colorSpace: r }
    );
}
const colorChannel = (e) => {
        const t = decomposeColor(e);
        return t.values
            .slice(0, 3)
            .map((e, n) => (t.type.includes("hsl") && 0 !== n ? `${e}%` : e))
            .join(" ");
    },
    private_safeColorChannel = (e, t) => {
        try {
            return colorChannel(e);
        } catch (n) {
            return e;
        }
    };
function recomposeColor(e) {
    const { type: t, colorSpace: n } = e;
    let { values: r } = e;
    return (
        t.includes("rgb")
            ? (r = r.map((e, t) => (t < 3 ? parseInt(e, 10) : e)))
            : t.includes("hsl") && ((r[1] = `${r[1]}%`), (r[2] = `${r[2]}%`)),
        (r = t.includes("color") ? `${n} ${r.join(" ")}` : `${r.join(", ")}`),
        `${t}(${r})`
    );
}
function hslToRgb(e) {
    e = decomposeColor(e);
    const { values: t } = e,
        n = t[0],
        r = t[1] / 100,
        i = t[2] / 100,
        s = r * Math.min(i, 1 - i),
        a = (e, t = (e + n / 30) % 12) =>
            i - s * Math.max(Math.min(t - 3, 9 - t, 1), -1);
    let o = "rgb";
    const l = [
        Math.round(255 * a(0)),
        Math.round(255 * a(8)),
        Math.round(255 * a(4)),
    ];
    return (
        "hsla" === e.type && ((o += "a"), l.push(t[3])),
        recomposeColor({ type: o, values: l })
    );
}
function getLuminance(e) {
    let t =
        "hsl" === (e = decomposeColor(e)).type || "hsla" === e.type
            ? decomposeColor(hslToRgb(e)).values
            : e.values;
    return (
        (t = t.map(
            (t) => (
                "color" !== e.type && (t /= 255),
                t <= 0.03928 ? t / 12.92 : ((t + 0.055) / 1.055) ** 2.4
            )
        )),
        Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3))
    );
}
function getContrastRatio(e, t) {
    const n = getLuminance(e),
        r = getLuminance(t);
    return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function alpha(e, t) {
    return (
        (e = decomposeColor(e)),
        (t = clampWrapper(t)),
        ("rgb" !== e.type && "hsl" !== e.type) || (e.type += "a"),
        "color" === e.type ? (e.values[3] = `/${t}`) : (e.values[3] = t),
        recomposeColor(e)
    );
}
function private_safeAlpha(e, t, n) {
    try {
        return alpha(e, t);
    } catch (r) {
        return e;
    }
}
function darken(e, t) {
    if (
        ((e = decomposeColor(e)), (t = clampWrapper(t)), e.type.includes("hsl"))
    )
        e.values[2] *= 1 - t;
    else if (e.type.includes("rgb") || e.type.includes("color"))
        for (let n = 0; n < 3; n += 1) e.values[n] *= 1 - t;
    return recomposeColor(e);
}
function private_safeDarken(e, t, n) {
    try {
        return darken(e, t);
    } catch (r) {
        return e;
    }
}
function lighten(e, t) {
    if (
        ((e = decomposeColor(e)), (t = clampWrapper(t)), e.type.includes("hsl"))
    )
        e.values[2] += (100 - e.values[2]) * t;
    else if (e.type.includes("rgb"))
        for (let n = 0; n < 3; n += 1) e.values[n] += (255 - e.values[n]) * t;
    else if (e.type.includes("color"))
        for (let n = 0; n < 3; n += 1) e.values[n] += (1 - e.values[n]) * t;
    return recomposeColor(e);
}
function private_safeLighten(e, t, n) {
    try {
        return lighten(e, t);
    } catch (r) {
        return e;
    }
}
function emphasize(e, t = 0.15) {
    return getLuminance(e) > 0.5 ? darken(e, t) : lighten(e, t);
}
function private_safeEmphasize(e, t, n) {
    try {
        return emphasize(e, t);
    } catch (r) {
        return e;
    }
}
function createChainedFunction(...e) {
    return e.reduce(
        (e, t) =>
            null == t
                ? e
                : function (...n) {
                      e.apply(this, n), t.apply(this, n);
                  },
        () => {}
    );
}
function debounce$1(e, t = 166) {
    let n;
    function r(...r) {
        clearTimeout(n),
            (n = setTimeout(() => {
                e.apply(this, r);
            }, t));
    }
    return (
        (r.clear = () => {
            clearTimeout(n);
        }),
        r
    );
}
function ownerDocument(e) {
    return (e && e.ownerDocument) || document;
}
function ownerWindow(e) {
    return ownerDocument(e).defaultView || window;
}
function setRef(e, t) {
    "function" == typeof e ? e(t) : e && (e.current = t);
}
let globalId = 0;
function useGlobalId(e) {
    const [t, n] = reactExports.useState(e),
        r = e || t;
    return (
        reactExports.useEffect(() => {
            null == t && ((globalId += 1), n(`mui-${globalId}`));
        }, [t]),
        r
    );
}
const safeReact = { ...React$2 },
    maybeReactUseId = safeReact.useId;
function useId(e) {
    if (void 0 !== maybeReactUseId) {
        const t = maybeReactUseId();
        return e ?? t;
    }
    return useGlobalId(e);
}
function useControlled({
    controlled: e,
    default: t,
    name: n,
    state: r = "value",
}) {
    const { current: i } = reactExports.useRef(void 0 !== e),
        [s, a] = reactExports.useState(t);
    return [
        i ? e : s,
        reactExports.useCallback((e) => {
            i || a(e);
        }, []),
    ];
}
function useEventCallback(e) {
    const t = reactExports.useRef(e);
    return (
        useEnhancedEffect(() => {
            t.current = e;
        }),
        reactExports.useRef((...e) => (0, t.current)(...e)).current
    );
}
function useForkRef(...e) {
    return reactExports.useMemo(
        () =>
            e.every((e) => null == e)
                ? null
                : (t) => {
                      e.forEach((e) => {
                          setRef(e, t);
                      });
                  },
        e
    );
}
const UNINITIALIZED = {};
function useLazyRef(e, t) {
    const n = reactExports.useRef(UNINITIALIZED);
    return n.current === UNINITIALIZED && (n.current = e(t)), n;
}
const EMPTY = [];
function useOnMount(e) {
    reactExports.useEffect(e, EMPTY);
}
class Timeout {
    constructor() {
        __publicField(this, "currentId", null),
            __publicField(this, "clear", () => {
                null !== this.currentId &&
                    (clearTimeout(this.currentId), (this.currentId = null));
            }),
            __publicField(this, "disposeEffect", () => this.clear);
    }
    static create() {
        return new Timeout();
    }
    start(e, t) {
        this.clear(),
            (this.currentId = setTimeout(() => {
                (this.currentId = null), t();
            }, e));
    }
}
function useTimeout() {
    const e = useLazyRef(Timeout.create).current;
    return useOnMount(e.disposeEffect), e;
}
function isFocusVisible(e) {
    try {
        return e.matches(":focus-visible");
    } catch (t) {}
    return !1;
}
function getScrollbarSize(e = window) {
    const t = e.document.documentElement.clientWidth;
    return e.innerWidth - t;
}
function composeClasses(e, t, n = void 0) {
    const r = {};
    for (const i in e) {
        const s = e[i];
        let a = "",
            o = !0;
        for (let e = 0; e < s.length; e += 1) {
            const r = s[e];
            r &&
                ((a += (!0 === o ? "" : " ") + t(r)),
                (o = !1),
                n && n[r] && (a += " " + n[r]));
        }
        r[i] = a;
    }
    return r;
}
function isHostComponent$1(e) {
    return "string" == typeof e;
}
function appendOwnerState(e, t, n) {
    return void 0 === e || isHostComponent$1(e)
        ? t
        : { ...t, ownerState: { ...t.ownerState, ...n } };
}
function extractEventHandlers(e, t = []) {
    if (void 0 === e) return {};
    const n = {};
    return (
        Object.keys(e)
            .filter(
                (n) =>
                    n.match(/^on[A-Z]/) &&
                    "function" == typeof e[n] &&
                    !t.includes(n)
            )
            .forEach((t) => {
                n[t] = e[t];
            }),
        n
    );
}
function omitEventHandlers(e) {
    if (void 0 === e) return {};
    const t = {};
    return (
        Object.keys(e)
            .filter((t) => !(t.match(/^on[A-Z]/) && "function" == typeof e[t]))
            .forEach((n) => {
                t[n] = e[n];
            }),
        t
    );
}
function mergeSlotProps(e) {
    const {
        getSlotProps: t,
        additionalProps: n,
        externalSlotProps: r,
        externalForwardedProps: i,
        className: s,
    } = e;
    if (!t) {
        const e = clsx(
                null == n ? void 0 : n.className,
                s,
                null == i ? void 0 : i.className,
                null == r ? void 0 : r.className
            ),
            t = {
                ...(null == n ? void 0 : n.style),
                ...(null == i ? void 0 : i.style),
                ...(null == r ? void 0 : r.style),
            },
            a = { ...n, ...i, ...r };
        return (
            e.length > 0 && (a.className = e),
            Object.keys(t).length > 0 && (a.style = t),
            { props: a, internalRef: void 0 }
        );
    }
    const a = extractEventHandlers({ ...i, ...r }),
        o = omitEventHandlers(r),
        l = omitEventHandlers(i),
        c = t(a),
        u = clsx(
            null == c ? void 0 : c.className,
            null == n ? void 0 : n.className,
            s,
            null == i ? void 0 : i.className,
            null == r ? void 0 : r.className
        ),
        d = {
            ...(null == c ? void 0 : c.style),
            ...(null == n ? void 0 : n.style),
            ...(null == i ? void 0 : i.style),
            ...(null == r ? void 0 : r.style),
        },
        p = { ...c, ...n, ...l, ...o };
    return (
        u.length > 0 && (p.className = u),
        Object.keys(d).length > 0 && (p.style = d),
        { props: p, internalRef: c.ref }
    );
}
function resolveComponentProps(e, t, n) {
    return "function" == typeof e ? e(t, n) : e;
}
function useSlotProps(e) {
    var t;
    const {
            elementType: n,
            externalSlotProps: r,
            ownerState: i,
            skipResolvingSlotProps: s = !1,
            ...a
        } = e,
        o = s ? {} : resolveComponentProps(r, i),
        { props: l, internalRef: c } = mergeSlotProps({
            ...a,
            externalSlotProps: o,
        });
    return appendOwnerState(
        n,
        {
            ...l,
            ref: useForkRef(
                c,
                null == o ? void 0 : o.ref,
                null == (t = e.additionalProps) ? void 0 : t.ref
            ),
        },
        i
    );
}
function getReactElementRef(e) {
    var t;
    return parseInt(reactExports.version, 10) >= 19
        ? (null == (t = null == e ? void 0 : e.props) ? void 0 : t.ref) || null
        : (null == e ? void 0 : e.ref) || null;
}
const RtlContext = reactExports.createContext(),
    useRtl = () => reactExports.useContext(RtlContext) ?? !1,
    PropsContext = reactExports.createContext(void 0);
function getThemeProps(e) {
    const { theme: t, name: n, props: r } = e;
    if (!t || !t.components || !t.components[n]) return r;
    const i = t.components[n];
    return i.defaultProps
        ? resolveProps(i.defaultProps, r)
        : i.styleOverrides || i.variants
        ? r
        : resolveProps(i, r);
}
function useDefaultProps$1({ props: e, name: t }) {
    return getThemeProps({
        props: e,
        name: t,
        theme: { components: reactExports.useContext(PropsContext) },
    });
}
const arg = { theme: void 0 };
function unstable_memoTheme(e) {
    let t, n;
    return function (r) {
        let i = t;
        return (
            (void 0 !== i && r.theme === n) ||
                ((arg.theme = r.theme),
                (i = preprocessStyles(e(arg))),
                (t = i),
                (n = r.theme)),
            i
        );
    };
}
function createGetCssVar$1(e = "") {
    function t(...n) {
        if (!n.length) return "";
        const r = n[0];
        return "string" != typeof r ||
            r.match(
                /(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/
            )
            ? `, ${r}`
            : `, var(--${e ? `${e}-` : ""}${r}${t(...n.slice(1))})`;
    }
    return (n, ...r) => `var(--${e ? `${e}-` : ""}${n}${t(...r)})`;
}
const assignNestedKeys = (e, t, n, r = []) => {
        let i = e;
        t.forEach((e, s) => {
            s === t.length - 1
                ? Array.isArray(i)
                    ? (i[Number(e)] = n)
                    : i && "object" == typeof i && (i[e] = n)
                : i &&
                  "object" == typeof i &&
                  (i[e] || (i[e] = r.includes(e) ? [] : {}), (i = i[e]));
        });
    },
    walkObjectDeep = (e, t, n) => {
        !(function e(r, i = [], s = []) {
            Object.entries(r).forEach(([r, a]) => {
                (!n || (n && !n([...i, r]))) &&
                    null != a &&
                    ("object" == typeof a && Object.keys(a).length > 0
                        ? e(a, [...i, r], Array.isArray(a) ? [...s, r] : s)
                        : t([...i, r], a, s));
            });
        })(e);
    },
    getCssValue = (e, t) => {
        if ("number" == typeof t) {
            if (
                ["lineHeight", "fontWeight", "opacity", "zIndex"].some((t) =>
                    e.includes(t)
                )
            )
                return t;
            return e[e.length - 1].toLowerCase().includes("opacity")
                ? t
                : `${t}px`;
        }
        return t;
    };
function cssVarsParser(e, t) {
    const { prefix: n, shouldSkipGeneratingVar: r } = t || {},
        i = {},
        s = {},
        a = {};
    return (
        walkObjectDeep(
            e,
            (e, t, o) => {
                if (
                    !(
                        ("string" != typeof t && "number" != typeof t) ||
                        (r && r(e, t))
                    )
                ) {
                    const r = `--${n ? `${n}-` : ""}${e.join("-")}`,
                        l = getCssValue(e, t);
                    Object.assign(i, { [r]: l }),
                        assignNestedKeys(s, e, `var(${r})`, o),
                        assignNestedKeys(a, e, `var(${r}, ${l})`, o);
                }
            },
            (e) => "vars" === e[0]
        ),
        { css: i, vars: s, varsWithDefaults: a }
    );
}
function prepareCssVars(e, t = {}) {
    const {
            getSelector: n = g,
            disableCssColorScheme: r,
            colorSchemeSelector: i,
        } = t,
        {
            colorSchemes: s = {},
            components: a,
            defaultColorScheme: o = "light",
            ...l
        } = e,
        { vars: c, css: u, varsWithDefaults: d } = cssVarsParser(l, t);
    let p = d;
    const h = {},
        { [o]: f, ...m } = s;
    if (
        (Object.entries(m || {}).forEach(([e, n]) => {
            const {
                vars: r,
                css: i,
                varsWithDefaults: s,
            } = cssVarsParser(n, t);
            (p = deepmerge(p, s)), (h[e] = { css: i, vars: r });
        }),
        f)
    ) {
        const { css: e, vars: n, varsWithDefaults: r } = cssVarsParser(f, t);
        (p = deepmerge(p, r)), (h[o] = { css: e, vars: n });
    }
    function g(t, n) {
        var r, a;
        let o = i;
        if (
            ("class" === i && (o = ".%s"),
            "data" === i && (o = "[data-%s]"),
            (null == i ? void 0 : i.startsWith("data-")) &&
                !i.includes("%s") &&
                (o = `[${i}="%s"]`),
            t)
        ) {
            if ("media" === o) {
                if (e.defaultColorScheme === t) return ":root";
                const i =
                    (null == (a = null == (r = s[t]) ? void 0 : r.palette)
                        ? void 0
                        : a.mode) || t;
                return {
                    [`@media (prefers-color-scheme: ${i})`]: { ":root": n },
                };
            }
            if (o)
                return e.defaultColorScheme === t
                    ? `:root, ${o.replace("%s", String(t))}`
                    : o.replace("%s", String(t));
        }
        return ":root";
    }
    return {
        vars: p,
        generateThemeVars: () => {
            let e = { ...c };
            return (
                Object.entries(h).forEach(([, { vars: t }]) => {
                    e = deepmerge(e, t);
                }),
                e
            );
        },
        generateStyleSheets: () => {
            var t, i;
            const a = [],
                o = e.defaultColorScheme || "light";
            function l(e, t) {
                Object.keys(t).length &&
                    a.push("string" == typeof e ? { [e]: { ...t } } : e);
            }
            l(n(void 0, { ...u }), u);
            const { [o]: c, ...d } = h;
            if (c) {
                const { css: e } = c,
                    a =
                        null == (i = null == (t = s[o]) ? void 0 : t.palette)
                            ? void 0
                            : i.mode,
                    u = !r && a ? { colorScheme: a, ...e } : { ...e };
                l(n(o, { ...u }), u);
            }
            return (
                Object.entries(d).forEach(([e, { css: t }]) => {
                    var i, a;
                    const o =
                            null ==
                            (a = null == (i = s[e]) ? void 0 : i.palette)
                                ? void 0
                                : a.mode,
                        c = !r && o ? { colorScheme: o, ...t } : { ...t };
                    l(n(e, { ...c }), c);
                }),
                a
            );
        },
    };
}
function createGetColorSchemeSelector(e) {
    return function (t) {
        return "media" === e
            ? `@media (prefers-color-scheme: ${t})`
            : e
            ? e.startsWith("data-") && !e.includes("%s")
                ? `[${e}="${t}"] &`
                : "class" === e
                ? `.${t} &`
                : "data" === e
                ? `[data-${t}] &`
                : `${e.replace("%s", t)} &`
            : "&";
    };
}
const defaultTheme$2 = createTheme$1(),
    defaultCreateStyledComponent = styled$1("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (e, t) => t.root,
    });
function useThemePropsDefault(e) {
    return useThemeProps$1({
        props: e,
        name: "MuiStack",
        defaultTheme: defaultTheme$2,
    });
}
function joinChildren(e, t) {
    const n = reactExports.Children.toArray(e).filter(Boolean);
    return n.reduce(
        (e, r, i) => (
            e.push(r),
            i < n.length - 1 &&
                e.push(reactExports.cloneElement(t, { key: `separator-${i}` })),
            e
        ),
        []
    );
}
const getSideFromDirection = (e) =>
        ({
            row: "Left",
            "row-reverse": "Right",
            column: "Top",
            "column-reverse": "Bottom",
        }[e]),
    style = ({ ownerState: e, theme: t }) => {
        let n = {
            display: "flex",
            flexDirection: "column",
            ...handleBreakpoints(
                { theme: t },
                resolveBreakpointValues({
                    values: e.direction,
                    breakpoints: t.breakpoints.values,
                }),
                (e) => ({ flexDirection: e })
            ),
        };
        if (e.spacing) {
            const r = createUnarySpacing(t),
                i = Object.keys(t.breakpoints.values).reduce(
                    (t, n) => (
                        (("object" == typeof e.spacing &&
                            null != e.spacing[n]) ||
                            ("object" == typeof e.direction &&
                                null != e.direction[n])) &&
                            (t[n] = !0),
                        t
                    ),
                    {}
                ),
                s = resolveBreakpointValues({ values: e.direction, base: i }),
                a = resolveBreakpointValues({ values: e.spacing, base: i });
            "object" == typeof s &&
                Object.keys(s).forEach((e, t, n) => {
                    if (!s[e]) {
                        const r = t > 0 ? s[n[t - 1]] : "column";
                        s[e] = r;
                    }
                });
            n = deepmerge(
                n,
                handleBreakpoints({ theme: t }, a, (t, n) =>
                    e.useFlexGap
                        ? { gap: getValue(r, t) }
                        : {
                              "& > :not(style):not(style)": { margin: 0 },
                              "& > :not(style) ~ :not(style)": {
                                  [`margin${getSideFromDirection(
                                      n ? s[n] : e.direction
                                  )}`]: getValue(r, t),
                              },
                          }
                )
            );
        }
        return (n = mergeBreakpointsInOrder(t.breakpoints, n)), n;
    };
function createStack(e = {}) {
    const {
            createStyledComponent: t = defaultCreateStyledComponent,
            useThemeProps: n = useThemePropsDefault,
            componentName: r = "MuiStack",
        } = e,
        i = t(style);
    return reactExports.forwardRef(function (e, t) {
        const s = extendSxProp$1(n(e)),
            {
                component: a = "div",
                direction: o = "column",
                spacing: l = 0,
                divider: c,
                children: u,
                className: d,
                useFlexGap: p = !1,
                ...h
            } = s,
            f = { direction: o, spacing: l, useFlexGap: p },
            m = composeClasses(
                { root: ["root"] },
                (e) => generateUtilityClass(r, e),
                {}
            );
        return jsxRuntimeExports.jsx(i, {
            as: a,
            ownerState: f,
            ref: t,
            className: clsx(m.root, d),
            ...h,
            children: c ? joinChildren(u, c) : u,
        });
    });
}
const common = { black: "#000", white: "#fff" },
    grey = {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#eeeeee",
        300: "#e0e0e0",
        400: "#bdbdbd",
        500: "#9e9e9e",
        600: "#757575",
        700: "#616161",
        800: "#424242",
        900: "#212121",
        A100: "#f5f5f5",
        A200: "#eeeeee",
        A400: "#bdbdbd",
        A700: "#616161",
    },
    purple = {
        50: "#f3e5f5",
        100: "#e1bee7",
        200: "#ce93d8",
        300: "#ba68c8",
        400: "#ab47bc",
        500: "#9c27b0",
        600: "#8e24aa",
        700: "#7b1fa2",
        800: "#6a1b9a",
        900: "#4a148c",
        A100: "#ea80fc",
        A200: "#e040fb",
        A400: "#d500f9",
        A700: "#aa00ff",
    },
    red = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000",
    },
    orange = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00",
    },
    blue = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff",
    },
    lightBlue = {
        50: "#e1f5fe",
        100: "#b3e5fc",
        200: "#81d4fa",
        300: "#4fc3f7",
        400: "#29b6f6",
        500: "#03a9f4",
        600: "#039be5",
        700: "#0288d1",
        800: "#0277bd",
        900: "#01579b",
        A100: "#80d8ff",
        A200: "#40c4ff",
        A400: "#00b0ff",
        A700: "#0091ea",
    },
    green = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853",
    };
function getLight() {
    return {
        text: {
            primary: "rgba(0, 0, 0, 0.87)",
            secondary: "rgba(0, 0, 0, 0.6)",
            disabled: "rgba(0, 0, 0, 0.38)",
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: { paper: common.white, default: common.white },
        action: {
            active: "rgba(0, 0, 0, 0.54)",
            hover: "rgba(0, 0, 0, 0.04)",
            hoverOpacity: 0.04,
            selected: "rgba(0, 0, 0, 0.08)",
            selectedOpacity: 0.08,
            disabled: "rgba(0, 0, 0, 0.26)",
            disabledBackground: "rgba(0, 0, 0, 0.12)",
            disabledOpacity: 0.38,
            focus: "rgba(0, 0, 0, 0.12)",
            focusOpacity: 0.12,
            activatedOpacity: 0.12,
        },
    };
}
const light = getLight();
function getDark() {
    return {
        text: {
            primary: common.white,
            secondary: "rgba(255, 255, 255, 0.7)",
            disabled: "rgba(255, 255, 255, 0.5)",
            icon: "rgba(255, 255, 255, 0.5)",
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: { paper: "#121212", default: "#121212" },
        action: {
            active: common.white,
            hover: "rgba(255, 255, 255, 0.08)",
            hoverOpacity: 0.08,
            selected: "rgba(255, 255, 255, 0.16)",
            selectedOpacity: 0.16,
            disabled: "rgba(255, 255, 255, 0.3)",
            disabledBackground: "rgba(255, 255, 255, 0.12)",
            disabledOpacity: 0.38,
            focus: "rgba(255, 255, 255, 0.12)",
            focusOpacity: 0.12,
            activatedOpacity: 0.24,
        },
    };
}
const dark = getDark();
function addLightOrDark(e, t, n, r) {
    const i = r.light || r,
        s = r.dark || 1.5 * r;
    e[t] ||
        (e.hasOwnProperty(n)
            ? (e[t] = e[n])
            : "light" === t
            ? (e.light = lighten(e.main, i))
            : "dark" === t && (e.dark = darken(e.main, s)));
}
function getDefaultPrimary(e = "light") {
    return "dark" === e
        ? { main: blue[200], light: blue[50], dark: blue[400] }
        : { main: blue[700], light: blue[400], dark: blue[800] };
}
function getDefaultSecondary(e = "light") {
    return "dark" === e
        ? { main: purple[200], light: purple[50], dark: purple[400] }
        : { main: purple[500], light: purple[300], dark: purple[700] };
}
function getDefaultError(e = "light") {
    return "dark" === e
        ? { main: red[500], light: red[300], dark: red[700] }
        : { main: red[700], light: red[400], dark: red[800] };
}
function getDefaultInfo(e = "light") {
    return "dark" === e
        ? { main: lightBlue[400], light: lightBlue[300], dark: lightBlue[700] }
        : { main: lightBlue[700], light: lightBlue[500], dark: lightBlue[900] };
}
function getDefaultSuccess(e = "light") {
    return "dark" === e
        ? { main: green[400], light: green[300], dark: green[700] }
        : { main: green[800], light: green[500], dark: green[900] };
}
function getDefaultWarning(e = "light") {
    return "dark" === e
        ? { main: orange[400], light: orange[300], dark: orange[700] }
        : { main: "#ed6c02", light: orange[500], dark: orange[900] };
}
function createPalette(e) {
    const {
            mode: t = "light",
            contrastThreshold: n = 3,
            tonalOffset: r = 0.2,
            ...i
        } = e,
        s = e.primary || getDefaultPrimary(t),
        a = e.secondary || getDefaultSecondary(t),
        o = e.error || getDefaultError(t),
        l = e.info || getDefaultInfo(t),
        c = e.success || getDefaultSuccess(t),
        u = e.warning || getDefaultWarning(t);
    function d(e) {
        return getContrastRatio(e, dark.text.primary) >= n
            ? dark.text.primary
            : light.text.primary;
    }
    const p = ({
        color: e,
        name: t,
        mainShade: n = 500,
        lightShade: i = 300,
        darkShade: s = 700,
    }) => {
        if (
            (!(e = { ...e }).main && e[n] && (e.main = e[n]),
            !e.hasOwnProperty("main"))
        )
            throw new Error(formatMuiErrorMessage(11, t ? ` (${t})` : "", n));
        if ("string" != typeof e.main)
            throw new Error(
                formatMuiErrorMessage(
                    12,
                    t ? ` (${t})` : "",
                    JSON.stringify(e.main)
                )
            );
        return (
            addLightOrDark(e, "light", i, r),
            addLightOrDark(e, "dark", s, r),
            e.contrastText || (e.contrastText = d(e.main)),
            e
        );
    };
    let h;
    "light" === t ? (h = getLight()) : "dark" === t && (h = getDark());
    return deepmerge(
        {
            common: { ...common },
            mode: t,
            primary: p({ color: s, name: "primary" }),
            secondary: p({
                color: a,
                name: "secondary",
                mainShade: "A400",
                lightShade: "A200",
                darkShade: "A700",
            }),
            error: p({ color: o, name: "error" }),
            warning: p({ color: u, name: "warning" }),
            info: p({ color: l, name: "info" }),
            success: p({ color: c, name: "success" }),
            grey: grey,
            contrastThreshold: n,
            getContrastText: d,
            augmentColor: p,
            tonalOffset: r,
            ...h,
        },
        i
    );
}
function prepareTypographyVars(e) {
    const t = {};
    return (
        Object.entries(e).forEach((e) => {
            const [n, r] = e;
            "object" == typeof r &&
                (t[n] = `${r.fontStyle ? `${r.fontStyle} ` : ""}${
                    r.fontVariant ? `${r.fontVariant} ` : ""
                }${r.fontWeight ? `${r.fontWeight} ` : ""}${
                    r.fontStretch ? `${r.fontStretch} ` : ""
                }${r.fontSize || ""}${r.lineHeight ? `/${r.lineHeight} ` : ""}${
                    r.fontFamily || ""
                }`);
        }),
        t
    );
}
function createMixins(e, t) {
    return {
        toolbar: {
            minHeight: 56,
            [e.up("xs")]: {
                "@media (orientation: landscape)": { minHeight: 48 },
            },
            [e.up("sm")]: { minHeight: 64 },
        },
        ...t,
    };
}
function round$2(e) {
    return Math.round(1e5 * e) / 1e5;
}
const caseAllCaps = { textTransform: "uppercase" },
    defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(e, t) {
    const {
            fontFamily: n = defaultFontFamily,
            fontSize: r = 14,
            fontWeightLight: i = 300,
            fontWeightRegular: s = 400,
            fontWeightMedium: a = 500,
            fontWeightBold: o = 700,
            htmlFontSize: l = 16,
            allVariants: c,
            pxToRem: u,
            ...d
        } = "function" == typeof t ? t(e) : t,
        p = r / 14,
        h = u || ((e) => (e / l) * p + "rem"),
        f = (e, t, r, i, s) => ({
            fontFamily: n,
            fontWeight: e,
            fontSize: h(t),
            lineHeight: r,
            ...(n === defaultFontFamily
                ? { letterSpacing: `${round$2(i / t)}em` }
                : {}),
            ...s,
            ...c,
        }),
        m = {
            h1: f(i, 96, 1.167, -1.5),
            h2: f(i, 60, 1.2, -0.5),
            h3: f(s, 48, 1.167, 0),
            h4: f(s, 34, 1.235, 0.25),
            h5: f(s, 24, 1.334, 0),
            h6: f(a, 20, 1.6, 0.15),
            subtitle1: f(s, 16, 1.75, 0.15),
            subtitle2: f(a, 14, 1.57, 0.1),
            body1: f(s, 16, 1.5, 0.15),
            body2: f(sx(p.root, i),
                ref: t,
                ownerState: d,
                ...c,
                children: [l, r],
            }),
        });
    });
function getSvgIconUtilityClass(e) {
    return generateUtilityClass("MuiSvgIcon", e);
}
generateUtilityClasses("MuiSvgIcon", [
    "root",
    "colorPrimary",
    "colorSecondary",
    "colorAction",
    "colorError",
    "colorDisabled",
    "fontSizeInherit",
    "fontSizeSmall",
    "fontSizeMedium",
    "fontSizeLarge",
]);
const useUtilityClasses$o = (e) => {
        const { color: t, fontSize: n, classes: r } = e;
        return composeClasses(
            {
                root: [
                    "root",
                    "inherit" !== t && `color${capitalize(t)}`,
                    `fontSize${capitalize(n)}`,
                ],
            },
            getSvgIconUtilityClass,
            r
        );
    },
    SvgIconRoot = styled("svg", {
        name: "MuiSvgIcon",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                t.root,
                "inherit" !== n.color && t[`color${capitalize(n.color)}`],
                t[`fontSize${capitalize(n.fontSize)}`],
            ];
        },
    })(
        memoTheme(({ theme: e }) => {
            var t, n, r, i, s, a, o, l, c, u, d, p, h, f;
            return {
                userSelect: "none",
                width: "1em",
                height: "1em",
                display: "inline-block",
                flexShrink: 0,
                transition:
                    null ==
                    (i = null == (t = e.transitions) ? void 0 : t.create)
                        ? void 0
                        : i.call(t, "fill", {
                              duration:
                                  null ==
                                  (r =
                                      null == (n = (e.vars ?? e).transitions)
                                          ? void 0
                                          : n.duration)
                                      ? void 0
                                      : r.shorter,
                          }),
                variants: [
                    {
                        props: (e) => !e.hasSvgAsChild,
                        style: { fill: "currentColor" },
                    },
                    {
                        props: { fontSize: "inherit" },
                        style: { fontSize: "inherit" },
                    },
                    {
                        props: { fontSize: "small" },
                        style: {
                            fontSize:
                                (null ==
                                (a =
                                    null == (s = e.typography)
                                        ? void 0
                                        : s.pxToRem)
                                    ? void 0
                                    : a.call(s, 20)) || "1.25rem",
                        },
                    },
                    {
                        props: { fontSize: "medium" },
                        style: {
                            fontSize:
                                (null ==
                                (l =
                                    null == (o = e.typography)
                                        ? void 0
                                        : o.pxToRem)
                                    ? void 0
                                    : l.call(o, 24)) || "1.5rem",
                        },
                    },
                    {
                        props: { fontSize: "large" },
                        style: {
                            fontSize:
                                (null ==
                                (u =
                                    null == (c = e.typography)
                                        ? void 0
                                        : c.pxToRem)
                                    ? void 0
                                    : u.call(c, 35)) || "2.1875rem",
                        },
                    },
                    ...Object.entries((e.vars ?? e).palette)
                        .filter(([, e]) => e && e.main)
                        .map(([t]) => {
                            var n, r;
                            return {
                                props: { color: t },
                                style: {
                                    color:
                                        null ==
                                        (r =
                                            null == (n = (e.vars ?? e).palette)
                                                ? void 0
                                                : n[t])
                                            ? void 0
                                            : r.main,
                                },
                            };
                        }),
                    {
                        props: { color: "action" },
                        style: {
                            color:
                                null ==
                                (p =
                                    null == (d = (e.vars ?? e).palette)
                                        ? void 0
                                        : d.action)
                                    ? void 0
                                    : p.active,
                        },
                    },
                    {
                        props: { color: "disabled" },
                        style: {
                            color:
                                null ==
                                (f =
                                    null == (h = (e.vars ?? e).palette)
                                        ? void 0
                                        : h.action)
                                    ? void 0
                                    : f.disabled,
                        },
                    },
                    { props: { color: "inherit" }, style: { color: void 0 } },
                ],
            };
        })
    ),
    SvgIcon = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiSvgIcon" }),
            {
                children: r,
                className: i,
                color: s = "inherit",
                component: a = "svg",
                fontSize: o = "medium",
                htmlColor: l,
                inheritViewBox: c = !1,
                titleAccess: u,
                viewBox: d = "0 0 24 24",
                ...p
            } = n,
            h = reactExports.isValidElement(r) && "svg" === r.type,
            f = {
                ...n,
                color: s,
                component: a,
                fontSize: o,
                instanceFontSize: e.fontSize,
                inheritViewBox: c,
                viewBox: d,
                hasSvgAsChild: h,
            },
            m = {};
        c || (m.viewBox = d);
        const g = useUtilityClasses$o(f);
        return jsxRuntimeExports.jsxs(SvgIconRoot, {
            as: a,
            className: clsx(g.root, i),
            focusable: "false",
            color: l,
            "aria-hidden": !u || void 0,
            role: u ? "img" : void 0,
            ref: t,
            ...m,
            ...p,
            ...(h && r.props),
            ownerState: f,
            children: [
                h ? r.props.children : r,
                u ? jsxRuntimeExports.jsx("title", { children: u }) : null,
            ],
        });
    });
function createSvgIcon(e, t) {
    function n(n, r) {
        return jsxRuntimeExports.jsx(SvgIcon, {
            "data-testid": `${t}Icon`,
            ref: r,
            ...n,
            children: e,
        });
    }
    return (
        (n.muiName = SvgIcon.muiName),
        reactExports.memo(reactExports.forwardRef(n))
    );
}
function nextItem(e, t, n) {
    return e === t
        ? e.firstChild
        : t && t.nextElementSibling
        ? t.nextElementSibling
        : n
        ? null
        : e.firstChild;
}
function previousItem(e, t, n) {
    return e === t
        ? n
            ? e.firstChild
            : e.lastChild
        : t && t.previousElementSibling
        ? t.previousElementSibling
        : n
        ? null
        : e.lastChild;
}
function textCriteriaMatches(e, t) {
    if (void 0 === t) return !0;
    let n = e.innerText;
    return (
        void 0 === n && (n = e.textContent),
        (n = n.trim().toLowerCase()),
        0 !== n.length &&
            (t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join("")))
    );
}
function moveFocus(e, t, n, r, i, s) {
    let a = !1,
        o = i(e, t, !!t && n);
    for (; o; ) {
        if (o === e.firstChild) {
            if (a) return !1;
            a = !0;
        }
        const t =
            !r && (o.disabled || "true" === o.getAttribute("aria-disabled"));
        if (o.hasAttribute("tabindex") && textCriteriaMatches(o, s) && !t)
            return o.focus(), !0;
        o = i(e, o, n);
    }
    return !1;
}
SvgIcon && (SvgIcon.muiName = "SvgIcon");
const MenuList = reactExports.forwardRef(function (e, t) {
        const {
                actions: n,
                autoFocus: r = !1,
                autoFocusItem: i = !1,
                children: s,
                className: a,
                disabledItemsFocusable: o = !1,
                disableListWrap: l = !1,
                onKeyDown: c,
                variant: u = "selectedMenu",
                ...d
            } = e,
            p = reactExports.useRef(null),
            h = reactExports.useRef({
                keys: [],
                repeating: !0,
                previousKeyMatched: !0,
                lastTime: null,
            });
        useEnhancedEffect(() => {
            r && p.current.focus();
        }, [r]),
            reactExports.useImperativeHandle(
                n,
                () => ({
                    adjustStyleForScrollbar: (e, { direction: t }) => {
                        const n = !p.current.style.width;
                        if (e.clientHeight < p.current.clientHeight && n) {
                            const n = `${getScrollbarSize(ownerWindow(e))}px`;
                            (p.current.style[
                                "rtl" === t ? "paddingLeft" : "paddingRight"
                            ] = n),
                                (p.current.style.width = `calc(100% + ${n})`);
                        }
                        return p.current;
                    },
                }),
                []
            );
        const f = useForkRef(p, t);
        let m = -1;
        reactExports.Children.forEach(s, (e, t) => {
            reactExports.isValidElement(e)
                ? (e.props.disabled ||
                      ((("selectedMenu" === u && e.props.selected) ||
                          -1 === m) &&
                          (m = t)),
                  m === t &&
                      (e.props.disabled ||
                          e.props.muiSkipListHighlight ||
                          e.type.muiSkipListHighlight) &&
                      ((m += 1), m >= s.length && (m = -1)))
                : m === t && ((m += 1), m >= s.length && (m = -1));
        });
        const g = reactExports.Children.map(s, (e, t) => {
            if (t === m) {
                const t = {};
                return (
                    i && (t.autoFocus = !0),
                    void 0 === e.props.tabIndex &&
                        "selectedMenu" === u &&
                        (t.tabIndex = 0),
                    reactExports.cloneElement(e, t)
                );
            }
            return e;
        });
        return jsxRuntimeExports.jsx(List, {
            role: "menu",
            ref: f,
            className: a,
            onKeyDown: (e) => {
                const t = p.current,
                    n = e.key;
                if (e.ctrlKey || e.metaKey || e.altKey) return void (c && c(e));
                const r = ownerDocument(t).activeElement;
                if ("ArrowDown" === n)
                    e.preventDefault(), moveFocus(t, r, l, o, nextItem);
                else if ("ArrowUp" === n)
                    e.preventDefault(), moveFocus(t, r, l, o, previousItem);
                else if ("Home" === n)
                    e.preventDefault(), moveFocus(t, null, l, o, nextItem);
                else if ("End" === n)
                    e.preventDefault(), moveFocus(t, null, l, o, previousItem);
                else if (1 === n.length) {
                    const i = h.current,
                        s = n.toLowerCase(),
                        a = performance.now();
                    i.keys.length > 0 &&
                        (a - i.lastTime > 500
                            ? ((i.keys = []),
                              (i.repeating = !0),
                              (i.previousKeyMatched = !0))
                            : i.repeating &&
                              s !== i.keys[0] &&
                              (i.repeating = !1)),
                        (i.lastTime = a),
                        i.keys.push(s);
                    const l = r && !i.repeating && textCriteriaMatches(r, i);
                    i.previousKeyMatched &&
                    (l || moveFocus(t, r, !1, o, nextItem, i))
                        ? e.preventDefault()
                        : (i.previousKeyMatched = !1);
                }
                c && c(e);
            },
            tabIndex: r ? 0 : -1,
            ...d,
            children: g,
        });
    }),
    reflow = (e) => e.scrollTop;
function getTransitionProps(e, t) {
    const { timeout: n, easing: r, style: i = {} } = e;
    return {
        duration:
            i.transitionDuration ?? ("number" == typeof n ? n : n[t.mode] || 0),
        easing:
            i.transitionTimingFunction ??
            ("object" == typeof r ? r[t.mode] : r),
        delay: i.transitionDelay,
    };
}
function getScale(e) {
    return `scale(${e}, ${e ** 2})`;
}
const styles$1 = {
        entering: { opacity: 1, transform: getScale(1) },
        entered: { opacity: 1, transform: "none" },
    },
    isWebKit154 =
        "undefined" != typeof navigator &&
        /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
        /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
    Grow = reactExports.forwardRef(function (e, t) {
        const {
                addEndListener: n,
                appear: r = !0,
                children: i,
                easing: s,
                in: a,
                onEnter: o,
                onEntered: l,
                onEntering: c,
                onExit: u,
                onExited: d,
                onExiting: p,
                style: h,
                timeout: f = "auto",
                TransitionComponent: m = Transition,
                ...g
            } = e,
            x = useTimeout(),
            v = reactExports.useRef(),
            b = useTheme(),
            y = reactExports.useRef(null),
            _ = useForkRef(y, getReactElementRef(i), t),
            E = (e) => (t) => {
                if (e) {
                    const n = y.current;
                    void 0 === t ? e(n) : e(n, t);
                }
            },
            S = E(c),
            w = E((e, t) => {
                reflow(e);
                const {
                    duration: n,
                    delay: r,
                    easing: i,
                } = getTransitionProps(
                    { style: h, timeout: f, easing: s },
                    { mode: "enter" }
                );
                let a;
                "auto" === f
                    ? ((a = b.transitions.getAutoHeightDuration(
                          e.clientHeight
                      )),
                      (v.current = a))
                    : (a = n),
                    (e.style.transition = [
                        b.transitions.create("opacity", {
                            duration: a,
                            delay: r,
                        }),
                        b.transitions.create("transform", {
                            duration: isWebKit154 ? a : 0.666 * a,
                            delay: r,
                            easing: i,
                        }),
                    ].join(",")),
                    o && o(e, t);
            }),
            A = E(l),
            R = E(p),
            C = E((e) => {
                const {
                    duration: t,
                    delay: n,
                    easing: r,
                } = getTransitionProps(
                    { style: h, timeout: f, easing: s },
                    { mode: "exit" }
                );
                let i;
                "auto" === f
                    ? ((i = b.transitions.getAutoHeightDuration(
                          e.clientHeight
                      )),
                      (v.current = i))
                    : (i = t),
                    (e.style.transition = [
                        b.transitions.create("opacity", {
                            duration: i,
                            delay: n,
                        }),
                        b.transitions.create("transform", {
                            duration: isWebKit154 ? i : 0.666 * i,
                            delay: isWebKit154 ? n : n || 0.333 * i,
                            easing: r,
                        }),
                    ].join(",")),
                    (e.style.opacity = 0),
                    (e.style.transform = getScale(0.75)),
                    u && u(e);
            }),
            j = E(d);
        return jsxRuntimeExports.jsx(m, {
            appear: r,
            in: a,
            nodeRef: y,
            onEnter: w,
            onEntered: A,
            onEntering: S,
            onExit: C,
            onExited: j,
            onExiting: R,
            addEndListener: (e) => {
                "auto" === f && x.start(v.current || 0, e),
                    n && n(y.current, e);
            },
            timeout: "auto" === f ? null : f,
            ...g,
            children: (e, t) =>
                reactExports.cloneElement(i, {
                    style: {
                        opacity: 0,
                        transform: getScale(0.75),
                        visibility: "exited" !== e || a ? void 0 : "hidden",
                        ...styles$1[e],
                        ...h,
                        ...i.props.style,
                    },
                    ref: _,
                    ...t,
                }),
        });
    });
function isOverflowing(e) {
    const t = ownerDocument(e);
    return t.body === e
        ? ownerWindow(e).innerWidth > t.documentElement.clientWidth
        : e.scrollHeight > e.clientHeight;
}
function ariaHidden(e, t) {
    t
        ? e.setAttribute("aria-hidden", "true")
        : e.removeAttribute("aria-hidden");
}
function getPaddingRight(e) {
    return parseInt(ownerWindow(e).getComputedStyle(e).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(e) {
    const t = [
            "TEMPLATE",
            "SCRIPT",
            "STYLE",
            "LINK",
            "MAP",
            "META",
            "NOSCRIPT",
            "PICTURE",
            "COL",
            "COLGROUP",
            "PARAM",
            "SLOT",
            "SOURCE",
            "TRACK",
        ].includes(e.tagName),
        n = "INPUT" === e.tagName && "hidden" === e.getAttribute("type");
    return t || n;
}
function ariaHiddenSiblings(e, t, n, r, i) {
    const s = [t, n, ...r];
    [].forEach.call(e.children, (e) => {
        const t = !s.includes(e),
            n = !isAriaHiddenForbiddenOnElement(e);
        t && n && ariaHidden(e, i);
    });
}
function findIndexOf(e, t) {
    let n = -1;
    return e.some((e, r) => !!t(e) && ((n = r), !0)), n;
}
function handleContainer(e, t) {
    const n = [],
        r = e.container;
    if (!t.disableScrollLock) {
        if (isOverflowing(r)) {
            const e = getScrollbarSize(ownerWindow(r));
            n.push({
                value: r.style.paddingRight,
                property: "padding-right",
                el: r,
            }),
                (r.style.paddingRight = `${getPaddingRight(r) + e}px`);
            const t = ownerDocument(r).querySelectorAll(".mui-fixed");
            [].forEach.call(t, (t) => {
                n.push({
                    value: t.style.paddingRight,
                    property: "padding-right",
                    el: t,
                }),
                    (t.style.paddingRight = `${getPaddingRight(t) + e}px`);
            });
        }
        let e;
        if (r.parentNode instanceof DocumentFragment) e = ownerDocument(r).body;
        else {
            const t = r.parentElement,
                n = ownerWindow(r);
            e =
                "HTML" === (null == t ? void 0 : t.nodeName) &&
                "scroll" === n.getComputedStyle(t).overflowY
                    ? t
                    : r;
        }
        n.push(
            { value: e.style.overflow, property: "overflow", el: e },
            { value: e.style.overflowX, property: "overflow-x", el: e },
            { value: e.style.overflowY, property: "overflow-y", el: e }
        ),
            (e.style.overflow = "hidden");
    }
    return () => {
        n.forEach(({ value: e, el: t, property: n }) => {
            e ? t.style.setProperty(n, e) : t.style.removeProperty(n);
        });
    };
}
function getHiddenSiblings(e) {
    const t = [];
    return (
        [].forEach.call(e.children, (e) => {
            "true" === e.getAttribute("aria-hidden") && t.push(e);
        }),
        t
    );
}
Grow && (Grow.muiSupportAuto = !0);
class ModalManager {
    constructor() {
        (this.modals = []), (this.containers = []);
    }
    add(e, t) {
        let n = this.modals.indexOf(e);
        if (-1 !== n) return n;
        (n = this.modals.length),
            this.modals.push(e),
            e.modalRef && ariaHidden(e.modalRef, !1);
        const r = getHiddenSiblings(t);
        ariaHiddenSiblings(t, e.mount, e.modalRef, r, !0);
        const i = findIndexOf(this.containers, (e) => e.container === t);
        return -1 !== i
            ? (this.containers[i].modals.push(e), n)
            : (this.containers.push({
                  modals: [e],
                  container: t,
                  restore: null,
                  hiddenSiblings: r,
              }),
              n);
    }
    mount(e, t) {
        const n = findIndexOf(this.containers, (t) => t.modals.includes(e)),
            r = this.containers[n];
        r.restore || (r.restore = handleContainer(r, t));
    }
    remove(e, t = !0) {
        const n = this.modals.indexOf(e);
        if (-1 === n) return n;
        const r = findIndexOf(this.containers, (t) => t.modals.includes(e)),
            i = this.containers[r];
        if (
            (i.modals.splice(i.modals.indexOf(e), 1),
            this.modals.splice(n, 1),
            0 === i.modals.length)
        )
            i.restore && i.restore(),
                e.modalRef && ariaHidden(e.modalRef, t),
                ariaHiddenSiblings(
                    i.container,
                    e.mount,
                    e.modalRef,
                    i.hiddenSiblings,
                    !1
                ),
                this.containers.splice(r, 1);
        else {
            const e = i.modals[i.modals.length - 1];
            e.modalRef && ariaHidden(e.modalRef, !1);
        }
        return n;
    }
    isTopModal(e) {
        return (
            this.modals.length > 0 && this.modals[this.modals.length - 1] === e
        );
    }
}
const candidatesSelector = [
    "input",
    "select",
    "textarea",
    "a[href]",
    "button",
    "[tabindex]",
    "audio[controls]",
    "video[controls]",
    '[contenteditable]:not([contenteditable="false"])',
].join(",");
function getTabIndex(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t)
        ? "true" === e.contentEditable ||
          (("AUDIO" === e.nodeName ||
              "VIDEO" === e.nodeName ||
              "DETAILS" === e.nodeName) &&
              null === e.getAttribute("tabindex"))
            ? 0
            : e.tabIndex
        : t;
}
function isNonTabbableRadio(e) {
    if ("INPUT" !== e.tagName || "radio" !== e.type) return !1;
    if (!e.name) return !1;
    const t = (t) => e.ownerDocument.querySelector(`input[type="radio"]${t}`);
    let n = t(`[name="${e.name}"]:checked`);
    return n || (n = t(`[name="${e.name}"]`)), n !== e;
}
function isNodeMatchingSelectorFocusable(e) {
    return !(
        e.disabled ||
        ("INPUT" === e.tagName && "hidden" === e.type) ||
        isNonTabbableRadio(e)
    );
}
function defaultGetTabbable(e) {
    const t = [],
        n = [];
    return (
        Array.from(e.querySelectorAll(candidatesSelector)).forEach((e, r) => {
            const i = getTabIndex(e);
            -1 !== i &&
                isNodeMatchingSelectorFocusable(e) &&
                (0 === i
                    ? t.push(e)
                    : n.push({ documentOrder: r, tabIndex: i, node: e }));
        }),
        n
            .sort((e, t) =>
                e.tabIndex === t.tabIndex
                    ? e.documentOrder - t.documentOrder
                    : e.tabIndex - t.tabIndex
            )
            .map((e) => e.node)
            .concat(t)
    );
}
function defaultIsEnabled() {
    return !0;
}
function FocusTrap(e) {
    const {
            children: t,
            disableAutoFocus: n = !1,
            disableEnforceFocus: r = !1,
            disableRestoreFocus: i = !1,
            getTabbable: s = defaultGetTabbable,
            isEnabled: a = defaultIsEnabled,
            open: o,
        } = e,
        l = reactExports.useRef(!1),
        c = reactExports.useRef(null),
        u = reactExports.useRef(null),
        d = reactExports.useRef(null),
        p = reactExports.useRef(null),
        h = reactExports.useRef(!1),
        f = reactExports.useRef(null),
        m = useForkRef(getReactElementRef(t), f),
        g = reactExports.useRef(null);
    reactExports.useEffect(() => {
        o && f.current && (h.current = !n);
    }, [n, o]),
        reactExports.useEffect(() => {
            if (!o || !f.current) return;
            const e = ownerDocument(f.current);
            return (
                f.current.contains(e.activeElement) ||
                    (f.current.hasAttribute("tabIndex") ||
                        f.current.setAttribute("tabIndex", "-1"),
                    h.current && f.current.focus()),
                () => {
                    i ||
                        (d.current &&
                            d.current.focus &&
                            ((l.current = !0), d.current.focus()),
                        (d.current = null));
                }
            );
        }, [o]),
        reactExports.useEffect(() => {
            if (!o || !f.current) return;
            const e = ownerDocument(f.current),
                t = (t) => {
                    (g.current = t),
                        !r &&
                            a() &&
                            "Tab" === t.key &&
                            e.activeElement === f.current &&
                            t.shiftKey &&
                            ((l.current = !0), u.current && u.current.focus());
                },
                n = () => {
                    var t, n;
                    const i = f.current;
                    if (null === i) return;
                    if (!e.hasFocus() || !a() || l.current)
                        return void (l.current = !1);
                    if (i.contains(e.activeElement)) return;
                    if (
                        r &&
                        e.activeElement !== c.current &&
                        e.activeElement !== u.current
                    )
                        return;
                    if (e.activeElement !== p.current) p.current = null;
                    else if (null !== p.current) return;
                    if (!h.current) return;
                    let o = [];
                    if (
                        ((e.activeElement !== c.current &&
                            e.activeElement !== u.current) ||
                            (o = s(f.current)),
                        o.length > 0)
                    ) {
                        const e = Boolean(
                                (null == (t = g.current)
                                    ? void 0
                                    : t.shiftKey) &&
                                    "Tab" ===
                                        (null == (n = g.current)
                                            ? void 0
                                            : n.key)
                            ),
                            r = o[0],
                            i = o[o.length - 1];
                        "string" != typeof r &&
                            "string" != typeof i &&
                            (e ? i.focus() : r.focus());
                    } else i.focus();
                };
            e.addEventListener("focusin", n),
                e.addEventListener("keydown", t, !0);
            const i = setInterval(() => {
                e.activeElement && "BODY" === e.activeElement.tagName && n();
            }, 50);
            return () => {
                clearInterval(i),
                    e.removeEventListener("focusin", n),
                    e.removeEventListener("keydown", t, !0);
            };
        }, [n, r, i, a, o, s]);
    const x = (e) => {
        null === d.current && (d.current = e.relatedTarget), (h.current = !0);
    };
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
            jsxRuntimeExports.jsx("div", {
                tabIndex: o ? 0 : -1,
                onFocus: x,
                ref: c,
                "data-testid": "sentinelStart",
            }),
            reactExports.cloneElement(t, {
                ref: m,
                onFocus: (e) => {
                    null === d.current && (d.current = e.relatedTarget),
                        (h.current = !0),
                        (p.current = e.target);
                    const n = t.props.onFocus;
                    n && n(e);
                },
            }),
            jsxRuntimeExports.jsx("div", {
                tabIndex: o ? 0 : -1,
                onFocus: x,
                ref: u,
                "data-testid": "sentinelEnd",
            }),
        ],
    });
}
function getContainer$1(e) {
    return "function" == typeof e ? e() : e;
}
const Portal = reactExports.forwardRef(function (e, t) {
    const { children: n, container: r, disablePortal: i = !1 } = e,
        [s, a] = reactExports.useState(null),
        o = useForkRef(
            reactExports.isValidElement(n) ? getReactElementRef(n) : null,
            t
        );
    if (
        (useEnhancedEffect(() => {
            i || a(getContainer$1(r) || document.body);
        }, [r, i]),
        useEnhancedEffect(() => {
            if (s && !i)
                return (
                    setRef(t, s),
                    () => {
                        setRef(t, null);
                    }
                );
        }, [t, s, i]),
        i)
    ) {
        if (reactExports.isValidElement(n)) {
            const e = { ref: o };
            return reactExports.cloneElement(n, e);
        }
        return jsxRuntimeExports.jsx(reactExports.Fragment, { children: n });
    }
    return jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: s ? reactDomExports.createPortal(n, s) : s,
    });
});
function useSlot(e, t) {
    const {
            className: n,
            elementType: r,
            ownerState: i,
            externalForwardedProps: s,
            getSlotOwnerState: a,
            internalForwardedProps: o,
            ...l
        } = t,
        {
            component: c,
            slots: u = { [e]: void 0 },
            slotProps: d = { [e]: void 0 },
            ...p
        } = s,
        h = u[e] || r,
        f = resolveComponentProps(d[e], i),
        {
            props: { component: m, ...g },
            internalRef: x,
        } = mergeSlotProps({
            className: n,
            ...l,
            externalForwardedProps: "root" === e ? p : void 0,
            externalSlotProps: f,
        }),
        v = useForkRef(x, null == f ? void 0 : f.ref, t.ref),
        b = a ? a(g) : {},
        y = { ...i, ...b },
        _ = "root" === e ? m || c : m,
        E = appendOwnerState(
            h,
            {
                ...("root" === e && !c && !u[e] && o),
                ...("root" !== e && !u[e] && o),
                ...g,
                ...(_ && { as: _ }),
                ref: v,
            },
            y
        );
    return (
        Object.keys(b).forEach((e) => {
            delete E[e];
        }),
        [h, E]
    );
}
const styles = { entering: { opacity: 1 }, entered: { opacity: 1 } },
    Fade = reactExports.forwardRef(function (e, t) {
        const n = useTheme(),
            r = {
                enter: n.transitions.duration.enteringScreen,
                exit: n.transitions.duration.leavingScreen,
            },
            {
                addEndListener: i,
                appear: s = !0,
                children: a,
                easing: o,
                in: l,
                onEnter: c,
                onEntered: u,
                onEntering: d,
                onExit: p,
                onExited: h,
                onExiting: f,
                style: m,
                timeout: g = r,
                TransitionComponent: x = Transition,
                ...v
            } = e,
            b = reactExports.useRef(null),
            y = useForkRef(b, getReactElementRef(a), t),
            _ = (e) => (t) => {
                if (e) {
                    const n = b.current;
                    void 0 === t ? e(n) : e(n, t);
                }
            },
            E = _(d),
            S = _((e, t) => {
                reflow(e);
                const r = getTransitionProps(
                    { style: m, timeout: g, easing: o },
                    { mode: "enter" }
                );
                (e.style.webkitTransition = n.transitions.create("opacity", r)),
                    (e.style.transition = n.transitions.create("opacity", r)),
                    c && c(e, t);
            }),
            w = _(u),
            A = _(f),
            R = _((e) => {
                const t = getTransitionProps(
                    { style: m, timeout: g, easing: o },
                    { mode: "exit" }
                );
                (e.style.webkitTransition = n.transitions.create("opacity", t)),
                    (e.style.transition = n.transitions.create("opacity", t)),
                    p && p(e);
            }),
            C = _(h);
        return jsxRuntimeExports.jsx(x, {
            appear: s,
            in: l,
            nodeRef: b,
            onEnter: S,
            onEntered: w,
            onEntering: E,
            onExit: R,
            onExited: C,
            onExiting: A,
            addEndListener: (e) => {
                i && i(b.current, e);
            },
            timeout: g,
            ...v,
            children: (e, t) =>
                reactExports.cloneElement(a, {
                    style: {
                        opacity: 0,
                        visibility: "exited" !== e || l ? void 0 : "hidden",
                        ...styles[e],
                        ...m,
                        ...a.props.style,
                    },
                    ref: y,
                    ...t,
                }),
        });
    });
function getBackdropUtilityClass(e) {
    return generateUtilityClass("MuiBackdrop", e);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const removeOwnerState = (e) => {
        const { ownerState: t, ...n } = e;
        return n;
    },
    useUtilityClasses$n = (e) => {
        const { classes: t, invisible: n } = e;
        return composeClasses(
            { root: ["root", n && "invisible"] },
            getBackdropUtilityClass,
            t
        );
    },
    BackdropRoot = styled("div", {
        name: "MuiBackdrop",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [t.root, n.invisible && t.invisible];
        },
    })({
        position: "fixed",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        WebkitTapHighlightColor: "transparent",
        variants: [
            {
                props: { invisible: !0 },
                style: { backgroundColor: "transparent" },
            },
        ],
    }),
    Backdrop = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiBackdrop" }),
            {
                children: r,
                className: i,
                component: s = "div",
                invisible: a = !1,
                open: o,
                components: l = {},
                componentsProps: c = {},
                slotProps: u = {},
                slots: d = {},
                TransitionComponent: p,
                transitionDuration: h,
                ...f
            } = n,
            m = { ...n, component: s, invisible: a },
            g = useUtilityClasses$n(m),
            x = {
                slots: { transition: p, root: l.Root, ...d },
                slotProps: { ...c, ...u },
            },
            [v, b] = useSlot("root", {
                elementType: BackdropRoot,
                externalForwardedProps: x,
                className: clsx(g.root, i),
                ownerState: m,
            }),
            [y, _] = useSlot("transition", {
                elementType: Fade,
                externalForwardedProps: x,
                ownerState: m,
            }),
            E = removeOwnerState(_);
        return jsxRuntimeExports.jsx(y, {
            in: o,
            timeout: h,
            ...f,
            ...E,
            children: jsxRuntimeExports.jsx(v, {
                "aria-hidden": !0,
                ...b,
                classes: g,
                ref: t,
                children: r,
            }),
        });
    });
function getContainer(e) {
    return "function" == typeof e ? e() : e;
}
function getHasTransition(e) {
    return !!e && e.props.hasOwnProperty("in");
}
const manager = new ModalManager();
function useModal(e) {
    const {
            container: t,
            disableEscapeKeyDown: n = !1,
            disableScrollLock: r = !1,
            closeAfterTransition: i = !1,
            onTransitionEnter: s,
            onTransitionExited: a,
            children: o,
            onClose: l,
            open: c,
            rootRef: u,
        } = e,
        d = reactExports.useRef({}),
        p = reactExports.useRef(null),
        h = reactExports.useRef(null),
        f = useForkRef(h, u),
        [m, g] = reactExports.useState(!c),
        x = getHasTransition(o);
    let v = !0;
    ("false" !== e["aria-hidden"] && !1 !== e["aria-hidden"]) || (v = !1);
    const b = () => (
            (d.current.modalRef = h.current),
            (d.current.mount = p.current),
            d.current
        ),
        y = () => {
            manager.mount(b(), { disableScrollLock: r }),
                h.current && (h.current.scrollTop = 0);
        },
        _ = useEventCallback(() => {
            const e = getContainer(t) || ownerDocument(p.current).body;
            manager.add(b(), e), h.current && y();
        }),
        E = () => manager.isTopModal(b()),
        S = useEventCallback((e) => {
            (p.current = e),
                e && (c && E() ? y() : h.current && ariaHidden(h.current, v));
        }),
        w = reactExports.useCallback(() => {
            manager.remove(b(), v);
        }, [v]);
    reactExports.useEffect(
        () => () => {
            w();
        },
        [w]
    ),
        reactExports.useEffect(() => {
            c ? _() : (x && i) || w();
        }, [c, w, x, i, _]);
    const A = (e) => (t) => {
            var r;
            null == (r = e.onKeyDown) || r.call(e, t),
                "Escape" === t.key &&
                    229 !== t.which &&
                    E() &&
                    (n || (t.stopPropagation(), l && l(t, "escapeKeyDown")));
        },
        R = (e) => (t) => {
            var n;
            null == (n = e.onClick) || n.call(e, t),
                t.target === t.currentTarget && l && l(t, "backdropClick");
        };
    return {
        getRootProps: (t = {}) => {
            const n = extractEventHandlers(e);
            delete n.onTransitionEnter, delete n.onTransitionExited;
            const r = { ...n, ...t };
            return { role: "presentation", ...r, onKeyDown: A(r), ref: f };
        },
        getBackdropProps: (e = {}) => {
            const t = e;
            return { "aria-hidden": !0, ...t, onClick: R(t), open: c };
        },
        getTransitionProps: () => ({
            onEnter: createChainedFunction(
                () => {
                    g(!1), s && s();
                },
                null == o ? void 0 : o.props.onEnter
            ),
            onExited: createChainedFunction(
                () => {
                    g(!0), a && a(), i && w();
                },
                null == o ? void 0 : o.props.onExited
            ),
        }),
        rootRef: f,
        portalRef: S,
        isTopModal: E,
        exited: m,
        hasTransition: x,
    };
}
function getModalUtilityClass(e) {
    return generateUtilityClass("MuiModal", e);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$m = (e) => {
        const { open: t, exited: n, classes: r } = e;
        return composeClasses(
            { root: ["root", !t && n && "hidden"], backdrop: ["backdrop"] },
            getModalUtilityClass,
            r
        );
    },
    ModalRoot = styled("div", {
        name: "MuiModal",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [t.root, !n.open && n.exited && t.hidden];
        },
    })(
        memoTheme(({ theme: e }) => ({
            position: "fixed",
            zIndex: (e.vars || e).zIndex.modal,
            right: 0,
            bottom: 0,
            top: 0,
            left: 0,
            variants: [
                {
                    props: ({ ownerState: e }) => !e.open && e.exited,
                    style: { visibility: "hidden" },
                },
            ],
        }))
    ),
    ModalBackdrop = styled(Backdrop, {
        name: "MuiModal",
        slot: "Backdrop",
        overridesResolver: (e, t) => t.backdrop,
    })({ zIndex: -1 }),
    Modal = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ name: "MuiModal", props: e }),
            {
                BackdropComponent: r = ModalBackdrop,
                BackdropProps: i,
                classes: s,
                className: a,
                closeAfterTransition: o = !1,
                children: l,
                container: c,
                component: u,
                components: d = {},
                componentsProps: p = {},
                disableAutoFocus: h = !1,
                disableEnforceFocus: f = !1,
                disableEscapeKeyDown: m = !1,
                disablePortal: g = !1,
                disableRestoreFocus: x = !1,
                disableScrollLock: v = !1,
                hideBackdrop: b = !1,
                keepMounted: y = !1,
                onBackdropClick: _,
                onClose: E,
                onTransitionEnter: S,
                onTransitionExited: w,
                open: A,
                slotProps: R = {},
                slots: C = {},
                theme: j,
                ...k
            } = n,
            P = {
                ...n,
                closeAfterTransition: o,
                disableAutoFocus: h,
                disableEnforceFocus: f,
                disableEscapeKeyDown: m,
                disablePortal: g,
                disableRestoreFocus: x,
                disableScrollLock: v,
                hideBackdrop: b,
                keepMounted: y,
            },
            {
                getRootProps: T,
                getBackdropProps: M,
                getTransitionProps: $,
                portalRef: O,
                isTopModal: I,
                exited: D,
                hasTransition: N,
            } = useModal({ ...P, rootRef: t }),
            F = { ...P, exited: D },
            L = useUtilityClasses$m(F),
            B = {};
        if ((void 0 === l.props.tabIndex && (B.tabIndex = "-1"), N)) {
            const { onEnter: e, onExited: t } = $();
            (B.onEnter = e), (B.onExited = t);
        }
        const U = {
                ...k,
                slots: { root: d.Root, backdrop: d.Backdrop, ...C },
                slotProps: { ...p, ...R },
            },
            [z, W] = useSlot("root", {
                elementType: ModalRoot,
                externalForwardedProps: U,
                getSlotProps: T,
                additionalProps: { ref: t, as: u },
                ownerState: F,
                className: clsx(
                    a,
                    null == L ? void 0 : L.root,
                    !F.open && F.exited && (null == L ? void 0 : L.hidden)
                ),
            }),
            [G, V] = useSlot("backdrop", {
                elementType: r,
                externalForwardedProps: U,
                additionalProps: i,
                getSlotProps: (e) =>
                    M({
                        ...e,
                        onClick: (t) => {
                            _ && _(t),
                                (null == e ? void 0 : e.onClick) &&
                                    e.onClick(t);
                        },
                    }),
                className: clsx(
                    null == i ? void 0 : i.className,
                    null == L ? void 0 : L.backdrop
                ),
                ownerState: F,
            }),
            H = useForkRef(null == i ? void 0 : i.ref, V.ref);
        return y || A || (N && !D)
            ? jsxRuntimeExports.jsx(Portal, {
                  ref: O,
                  container: c,
                  disablePortal: g,
                  children: jsxRuntimeExports.jsxs(z, {
                      ...W,
                      children: [
                          !b && r
                              ? jsxRuntimeExports.jsx(G, { ...V, ref: H })
                              : null,
                          jsxRuntimeExports.jsx(FocusTrap, {
                              disableEnforceFocus: f,
                              disableAutoFocus: h,
                              disableRestoreFocus: x,
                              isEnabled: I,
                              open: A,
                              children: reactExports.cloneElement(l, B),
                          }),
                      ],
                  }),
              })
            : null;
    });
function getPaperUtilityClass(e) {
    return generateUtilityClass("MuiPaper", e);
}
generateUtilityClasses("MuiPaper", [
    "root",
    "rounded",
    "outlined",
    "elevation",
    "elevation0",
    "elevation1",
    "elevation2",
    "elevation3",
    "elevation4",
    "elevation5",
    "elevation6",
    "elevation7",
    "elevation8",
    "elevation9",
    "elevation10",
    "elevation11",
    "elevation12",
    "elevation13",
    "elevation14",
    "elevation15",
    "elevation16",
    "elevation17",
    "elevation18",
    "elevation19",
    "elevation20",
    "elevation21",
    "elevation22",
    "elevation23",
    "elevation24",
]);
const useUtilityClasses$l = (e) => {
        const { square: t, elevation: n, variant: r, classes: i } = e;
        return composeClasses(
            {
                root: [
                    "root",
                    r,
                    !t && "rounded",
                    "elevation" === r && `elevation${n}`,
                ],
            },
            getPaperUtilityClass,
            i
        );
    },
    PaperRoot = styled("div", {
        name: "MuiPaper",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                t.root,
                t[n.variant],
                !n.square && t.rounded,
                "elevation" === n.variant && t[`elevation${n.elevation}`],
            ];
        },
    })(
        memoTheme(({ theme: e }) => ({
            backgroundColor: (e.vars || e).palette.background.paper,
            color: (e.vars || e).palette.text.primary,
            transition: e.transitions.create("box-shadow"),
            variants: [
                {
                    props: ({ ownerState: e }) => !e.square,
                    style: { borderRadius: e.shape.borderRadius },
                },
                {
                    props: { variant: "outlined" },
                    style: {
                        border: `1px solid ${(e.vars || e).palette.divider}`,
                    },
                },
                {
                    props: { variant: "elevation" },
                    style: {
                        boxShadow: "var(--Paper-shadow)",
                        backgroundImage: "var(--Paper-overlay)",
                    },
                },
            ],
        }))
    ),
    Paper = reactExports.forwardRef(function (e, t) {
        var n;
        const r = useDefaultProps({ props: e, name: "MuiPaper" }),
            i = useTheme(),
            {
                className: s,
                component: a = "div",
                elevation: o = 1,
                square: l = !1,
                variant: c = "elevation",
                ...u
            } = r,
            d = { ...r, component: a, elevation: o, square: l, variant: c },
            p = useUtilityClasses$l(d);
        return jsxRuntimeExports.jsx(PaperRoot, {
            as: a,
            ownerState: d,
            className: clsx(p.root, s),
            ref: t,
            ...u,
            style: {
                ...("elevation" === c && {
                    "--Paper-shadow": (i.vars || i).shadows[o],
                    ...(i.vars && {
                        "--Paper-overlay":
                            null == (n = i.vars.overlays) ? void 0 : n[o],
                    }),
                    ...(!i.vars &&
                        "dark" === i.palette.mode && {
                            "--Paper-overlay": `linear-gradient(${alpha(
                                "#fff",
                                getOverlayAlpha(o)
                            )}, ${alpha("#fff", getOverlayAlpha(o))})`,
                        }),
                }),
                ...u.style,
            },
        });
    });
function getPopoverUtilityClass(e) {
    return generateUtilityClass("MuiPopover", e);
}
function getOffsetTop(e, t) {
    let n = 0;
    return (
        "number" == typeof t
            ? (n = t)
            : "center" === t
            ? (n = e.height / 2)
            : "bottom" === t && (n = e.height),
        n
    );
}
function getOffsetLeft(e, t) {
    let n = 0;
    return (
        "number" == typeof t
            ? (n = t)
            : "center" === t
            ? (n = e.width / 2)
            : "right" === t && (n = e.width),
        n
    );
}
function getTransformOriginValue(e) {
    return [e.horizontal, e.vertical]
        .map((e) => ("number" == typeof e ? `${e}px` : e))
        .join(" ");
}
function resolveAnchorEl$1(e) {
    return "function" == typeof e ? e() : e;
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const useUtilityClasses$k = (e) => {
        const { classes: t } = e;
        return composeClasses(
            { root: ["root"], paper: ["paper"] },
            getPopoverUtilityClass,
            t
        );
    },
    PopoverRoot = styled(Modal, {
        name: "MuiPopover",
        slot: "Root",
        overridesResolver: (e, t) => t.root,
    })({}),
    PopoverPaper = styled(Paper, {
        name: "MuiPopover",
        slot: "Paper",
        overridesResolver: (e, t) => t.paper,
    })({
        position: "absolute",
        overflowY: "auto",
        overflowX: "hidden",
        minWidth: 16,
        minHeight: 16,
        maxWidth: "calc(100% - 32px)",
        maxHeight: "calc(100% - 32px)",
        outline: 0,
    }),
    Popover = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiPopover" }),
            {
                action: r,
                anchorEl: i,
                anchorOrigin: s = { vertical: "top", horizontal: "left" },
                anchorPosition: a,
                anchorReference: o = "anchorEl",
                children: l,
                className: c,
                container: u,
                elevation: d = 8,
                marginThreshold: p = 16,
                open: h,
                PaperProps: f = {},
                slots: m = {},
                slotProps: g = {},
                transformOrigin: x = { vertical: "top", horizontal: "left" },
                TransitionComponent: v = Grow,
                transitionDuration: b = "auto",
                TransitionProps: { onEntering: y, ..._ } = {},
                disableScrollLock: E = !1,
                ...S
            } = n,
            w = (null == g ? void 0 : g.paper) ?? f,
            A = reactExports.useRef(),
            R = {
                ...n,
                anchorOrigin: s,
                anchorReference: o,
                elevation: d,
                marginThreshold: p,
                externalPaperSlotProps: w,
                transformOrigin: x,
                TransitionComponent: v,
                transitionDuration: b,
                TransitionProps: _,
            },
            C = useUtilityClasses$k(R),
            j = reactExports.useCallback(() => {
                if ("anchorPosition" === o) return a;
                const e = resolveAnchorEl$1(i),
                    t = (
                        e && 1 === e.nodeType
                            ? e
                            : ownerDocument(A.current).body
                    ).getBoundingClientRect();
                return {
                    top: t.top + getOffsetTop(t, s.vertical),
                    left: t.left + getOffsetLeft(t, s.horizontal),
                };
            }, [i, s.horizontal, s.vertical, a, o]),
            k = reactExports.useCallback(
                (e) => ({
                    vertical: getOffsetTop(e, x.vertical),
                    horizontal: getOffsetLeft(e, x.horizontal),
                }),
                [x.horizontal, x.vertical]
            ),
            P = reactExports.useCallback(
                (e) => {
                    const t = { width: e.offsetWidth, height: e.offsetHeight },
                        n = k(t);
                    if ("none" === o)
                        return {
                            top: null,
                            left: null,
                            transformOrigin: getTransformOriginValue(n),
                        };
                    const r = j();
                    let s = r.top - n.vertical,
                        a = r.left - n.horizontal;
                    const l = s + t.height,
                        c = a + t.width,
                        u = ownerWindow(resolveAnchorEl$1(i)),
                        d = u.innerHeight - p,
                        h = u.innerWidth - p;
                    if (null !== p && s < p) {
                        const e = s - p;
                        (s -= e), (n.vertical += e);
                    } else if (null !== p && l > d) {
                        const e = l - d;
                        (s -= e), (n.vertical += e);
                    }
                    if (null !== p && a < p) {
                        const e = a - p;
                        (a -= e), (n.horizontal += e);
                    } else if (c > h) {
                        const e = c - h;
                        (a -= e), (n.horizontal += e);
                    }
                    return {
                        top: `${Math.round(s)}px`,
                        left: `${Math.round(a)}px`,
                        transformOrigin: getTransformOriginValue(n),
                    };
                },
                [i, o, j, k, p]
            ),
            [T, M] = reactExports.useState(h),
            $ = reactExports.useCallback(() => {
                const e = A.current;
                if (!e) return;
                const t = P(e);
                null !== t.top && e.style.setProperty("top", t.top),
                    null !== t.left && (e.style.left = t.left),
                    (e.style.transformOrigin = t.transformOrigin),
                    M(!0);
            }, [P]);
        reactExports.useEffect(
            () => (
                E && window.addEventListener("scroll", $),
                () => window.removeEventListener("scroll", $)
            ),
            [i, E, $]
        );
        reactExports.useEffect(() => {
            h && $();
        }),
            reactExports.useImperativeHandle(
                r,
                () =>
                    h
                        ? {
                              updatePosition: () => {
                                  $();
                              },
                          }
                        : null,
                [h, $]
            ),
            reactExports.useEffect(() => {
                if (!h) return;
                const e = debounce$1(() => {
                        $();
                    }),
                    t = ownerWindow(i);
                return (
                    t.addEventListener("resize", e),
                    () => {
                        e.clear(), t.removeEventListener("resize", e);
                    }
                );
            }, [i, h, $]);
        let O = b;
        "auto" !== b || v.muiSupportAuto || (O = void 0);
        const I = u || (i ? ownerDocument(resolveAnchorEl$1(i)).body : void 0),
            D = { slots: m, slotProps: { ...g, paper: w } },
            [N, F] = useSlot("paper", {
                elementType: PopoverPaper,
                externalForwardedProps: D,
                additionalProps: {
                    elevation: d,
                    className: clsx(C.paper, null == w ? void 0 : w.className),
                    style: T ? w.style : { ...w.style, opacity: 0 },
                },
                ownerState: R,
            }),
            [L, { slotProps: B, ...U }] = useSlot("root", {
                elementType: PopoverRoot,
                externalForwardedProps: D,
                additionalProps: {
                    slotProps: { backdrop: { invisible: !0 } },
                    container: I,
                    open: h,
                },
                ownerState: R,
                className: clsx(C.root, c),
            }),
            z = useForkRef(A, F.ref);
        return jsxRuntimeExports.jsx(L, {
            ...U,
            ...(!isHostComponent(L) && { slotProps: B, disableScrollLock: E }),
            ...S,
            ref: t,
            children: jsxRuntimeExports.jsx(v, {
                appear: !0,
                in: h,
                onEntering: (e, t) => {
                    y && y(e, t), $();
                },
                onExited: () => {
                    M(!1);
                },
                timeout: O,
                ..._,
                children: jsxRuntimeExports.jsx(N, {
                    ...F,
                    ref: z,
                    children: l,
                }),
            }),
        });
    });
function getMenuUtilityClass(e) {
    return generateUtilityClass("MuiMenu", e);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = { vertical: "top", horizontal: "right" },
    LTR_ORIGIN = { vertical: "top", horizontal: "left" },
    useUtilityClasses$j = (e) => {
        const { classes: t } = e;
        return composeClasses(
            { root: ["root"], paper: ["paper"], list: ["list"] },
            getMenuUtilityClass,
            t
        );
    },
    MenuRoot = styled(Popover, {
        shouldForwardProp: (e) => rootShouldForwardProp(e) || "classes" === e,
        name: "MuiMenu",
        slot: "Root",
        overridesResolver: (e, t) => t.root,
    })({}),
    MenuPaper = styled(PopoverPaper, {
        name: "MuiMenu",
        slot: "Paper",
        overridesResolver: (e, t) => t.paper,
    })({ maxHeight: "calc(100% - 96px)", WebkitOverflowScrolling: "touch" }),
    MenuMenuList = styled(MenuList, {
        name: "MuiMenu",
        slot: "List",
        overridesResolver: (e, t) => t.list,
    })({ outline: 0 }),
    Menu = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiMenu" }),
            {
                autoFocus: r = !0,
                children: i,
                className: s,
                disableAutoFocusItem: a = !1,
                MenuListProps: o = {},
                onClose: l,
                open: c,
                PaperProps: u = {},
                PopoverClasses: d,
                transitionDuration: p = "auto",
                TransitionProps: { onEntering: h, ...f } = {},
                variant: m = "selectedMenu",
                slots: g = {},
                slotProps: x = {},
                ...v
            } = n,
            b = useRtl(),
            y = {
                ...n,
                autoFocus: r,
                disableAutoFocusItem: a,
                MenuListProps: o,
                onEntering: h,
                PaperProps: u,
                transitionDuration: p,
                TransitionProps: f,
                variant: m,
            },
            _ = useUtilityClasses$j(y),
            E = r && !a && c,
            S = reactExports.useRef(null);
        let w = -1;
        reactExports.Children.map(i, (e, t) => {
            reactExports.isValidElement(e) &&
                (e.props.disabled ||
                    ((("selectedMenu" === m && e.props.selected) || -1 === w) &&
                        (w = t)));
        });
        const A = g.paper ?? MenuPaper,
            R = x.paper ?? u,
            C = useSlotProps({
                elementType: g.root,
                externalSlotProps: x.root,
                ownerState: y,
                className: [_.root, s],
            }),
            j = useSlotProps({
                elementType: A,
                externalSlotProps: R,
                ownerState: y,
                className: _.paper,
            });
        return jsxRuntimeExports.jsx(MenuRoot, {
            onClose: l,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: b ? "right" : "left",
            },
            transformOrigin: b ? RTL_ORIGIN : LTR_ORIGIN,
            slots: { paper: A, root: g.root },
            slotProps: { root: C, paper: j },
            open: c,
            ref: t,
            transitionDuration: p,
            TransitionProps: {
                onEntering: (e, t) => {
                    S.current &&
                        S.current.adjustStyleForScrollbar(e, {
                            direction: b ? "rtl" : "ltr",
                        }),
                        h && h(e, t);
                },
                ...f,
            },
            ownerState: y,
            ...v,
            classes: d,
            children: jsxRuntimeExports.jsx(MenuMenuList, {
                onKeyDown: (e) => {
                    "Tab" === e.key &&
                        (e.preventDefault(), l && l(e, "tabKeyDown"));
                },
                actions: S,
                autoFocus: r && (-1 === w || a),
                autoFocusItem: E,
                variant: m,
                ...o,
                className: clsx(_.list, o.className),
                children: i,
            }),
        });
    });
function getNativeSelectUtilityClasses(e) {
    return generateUtilityClass("MuiNativeSelect", e);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", [
        "root",
        "select",
        "multiple",
        "filled",
        "outlined",
        "standard",
        "disabled",
        "icon",
        "iconOpen",
 Input",
        "error",
    ]),
    useUtilityClasses$i = (e) => {
        const {
            classes: t,
            variant: n,
            disabled: r,
            multiple: i,
            open: s,
            error: a,
        } = e;
        return composeClasses(
            {
                select: [
                    "select",
                    n,
                    r && "disabled",
                    i && "multiple",
                    a && "error",
                ],
                icon: [
                    "icon",
                    `icon${capitalize(n)}`,
                    s && "iconOpen",
                    r && "disabled",
                ],
            },
            getNativeSelectUtilityClasses,
            t
        );
    },
    StyledSelectSelect = styled("select")(({ theme: e }) => ({
        MozAppearance: "none",
        WebkitAppearance: "none",
        userSelect: "none",
        borderRadius: 0,
        cursor: "pointer",
        "&:focus": { borderRadius: 0 },
        [`&.${nativeSelectClasses.disabled}`]: { cursor: "default" },
        "&[multiple]": { height: "auto" },
        "&:not([multiple]) option, &:not([multiple]) optgroup": {
            backgroundColor: (e.vars || e).palette.background.paper,
        },
        variants: [
            {
                props: ({ ownerState: e }) =>
                    "filled" !== e.variant && "outlined" !== e.variant,
                style: { "&&&": { paddingRight: 24, minWidth: 16 } },
            },
            {
                props: { variant: "filled" },
                style: { "&&&": { paddingRight: 32 } },
            },
            {
                props: { variant: "outlined" },
                style: {
                    borderRadius: (e.vars || e).shape.borderRadius,
                    "&:focus": {
                        borderRadius: (e.vars || e).shape.borderRadius,
                    },
                    "&&&": { paddingRight: 32 },
                },
            },
        ],
    })),
    NativeSelectSelect = styled(StyledSelectSelect, {
        name: "MuiNativeSelect",
        slot: "Select",
        shouldForwardProp: rootShouldForwardProp,
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                t.select,
                t[n.variant],
                n.error && t.error,
                { [`&.${nativeSelectClasses.multiple}`]: t.multiple },
            ];
        },
    })({}),
    StyledSelectIcon = styled("svg")(({ theme: e }) => ({
        position: "absolute",
        right: 0,
        top: "calc(50% - .5em)",
        pointerEvents: "none",
        color: (e.vars || e).palette.action.active,
        [`&.${nativeSelectClasses.disabled}`]: {
            color: (e.vars || e).palette.action.disabled,
        },
        variants: [
            {
                props: ({ ownerState: e }) => e.open,
                style: { transform: "rotate(180deg)" },
            },
            { props: { variant: "filled" }, style: { right: 7 } },
            { props: { variant: "outlined" }, style: { right: 7 } },
        ],
    })),
    NativeSelectIcon = styled(StyledSelectIcon, {
        name: "MuiNativeSelect",
        slot: "Icon",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                t.icon,
                n.variant && t[`icon${capitalize(n.variant)}`],
                n.open && t.iconOpen,
            ];
        },
    })({}),
    NativeSelectInput = reactExports.forwardRef(function (e, t) {
        const {
                className: n,
                disabled: r,
                error: i,
                IconComponent: s,
                inputRef: a,
                variant: o = "standard",
                ...l
            } = e,
            c = { ...e, disabled: r, variant: o, error: i },
            u = useUtilityClasses$i(c);
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx(NativeSelectSelect, {
                    ownerState: c,
                    className: clsx(u.select, n),
                    disabled: r,
                    ref: a || t,
                    ...l,
                }),
                e.multiple
                    ? null
                    : jsxRuntimeExports.jsx(NativeSelectIcon, {
                          as: s,
                          ownerState: c,
                          className: u.icon,
                      }),
            ],
        });
    });
function getSelectUtilityClasses(e) {
    return generateUtilityClass("MuiSelect", e);
}
const selectClasses = generateUtilityClasses("MuiSelect", [
    "root",
    "select",
    "multiple",
    "filled",
    "outlined",
    "standard",
    "disabled",
    "focused",
    "icon",
    "iconOpen",
    "iconFilled",
    "iconOutlined",
    "iconStandard",
    "nativeInput",
    "error",
]);
var _span$1;
const SelectSelect = styled(StyledSelectSelect, {
        name: "MuiSelect",
        slot: "Select",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                { [`&.${selectClasses.select}`]: t.select },
                { [`&.${selectClasses.select}`]: t[n.variant] },
                { [`&.${selectClasses.error}`]: t.error },
                { [`&.${selectClasses.multiple}`]: t.multiple },
            ];
        },
    })({
        [`&.${selectClasses.select}`]: {
            height: "auto",
            minHeight: "1.4375em",
            textOverflow: "ellipsis",
            whiteSpace: "nowrap",
            overflow: "hidden",
        },
    }),
    SelectIcon = styled(StyledSelectIcon, {
        name: "MuiSelect",
        slot: "Icon",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                t.icon,
                n.variant && t[`icon${capitalize(n.variant)}`],
                n.open && t.iconOpen,
            ];
        },
    })({}),
    SelectNativeInput = styled("input", {
        shouldForwardProp: (e) => slotShouldForwardProp(e) && "classes" !== e,
        name: "MuiSelect",
        slot: "NativeInput",
        overridesResolver: (e, t) => t.nativeInput,
    })({
        bottom: 0,
        left: 0,
        position: "absolute",
        opacity: 0,
        pointerEvents: "none",
        width: "100%",
        boxSizing: "border-box",
    });
function areEqualValues(e, t) {
    return "object" == typeof t && null !== t
        ? e === t
        : String(e) === String(t);
}
function isEmpty(e) {
    return null == e || ("string" == typeof e && !e.trim());
}
const useUtilityClasses$h = (e) => {
        const {
            classes: t,
            variant: n,
            disabled: r,
            multiple: i,
            open: s,
            error: a,
        } = e;
        return composeClasses(
            {
                select: [
                    "select",
                    n,
                    r && "disabled",
                    i && "multiple",
                    a && "error",
                ],
                icon: [
                    "icon",
                    `icon${capitalize(n)}`,
                    s && "iconOpen",
                    r && "disabled",
                ],
                nativeInput: ["nativeInput"],
            },
            getSelectUtilityClasses,
            t
        );
    },
    SelectInput = reactExports.forwardRef(function (e, t) {
        var n;
        const {
                "aria-describedby": r,
                "aria-label": i,
                autoFocus: s,
                autoWidth: a,
                children: o,
                className: l,
                defaultOpen: c,
                defaultValue: u,
                disabled: d,
                displayEmpty: p,
                error: h = !1,
                IconComponent: f,
                inputRef: m,
                labelId: g,
                MenuProps: x = {},
                multiple: v,
                name: b,
                onBlur: y,
                onChange: _,
                onClose: E,
                onFocus: S,
                onOpen: w,
                open: A,
                readOnly: R,
                renderValue: C,
                SelectDisplayProps: j = {},
                tabIndex: k,
                type: P,
                value: T,
                variant: M = "standard",
                ...$
            } = e,
            [O, I] = useControlled({
                controlled: T,
                default: u,
                name: "Select",
            }),
            [D, N] = useControlled({
                controlled: A,
                default: c,
                name: "Select",
            }),
            F = reactExports.useRef(null),
            L = reactExports.useRef(null),
            [B, U] = reactExports.useState(null),
            { current: z } = reactExports.useRef(null != A),
            [W, G] = reactExports.useState(),
            V = useForkRef(t, m),
            H = reactExports.useCallback((e) => {
                (L.current = e), e && U(e);
            }, []),
            q = null == B ? void 0 : B.parentNode;
        reactExports.useImperativeHandle(
            V,
            () => ({
                focus: () => {
                    L.current.focus();
                },
                node: F.current,
                value: O,
            }),
            [O]
        ),
            reactExports.useEffect(() => {
                c &&
                    D &&
                    B &&
                    !z &&
                    (G(a ? null : q.clientWidth), L.current.focus());
            }, [B, a]),
            reactExports.useEffect(() => {
                s && L.current.focus();
            }, [s]),
            reactExports.useEffect(() => {
                if (!g) return;
                const e = ownerDocument(L.current).getElementById(g);
                if (e) {
                    const t = () => {
                        getSelection().isCollapsed && L.current.focus();
                    };
                    return (
                        e.addEventListener("click", t),
                        () => {
                            e.removeEventListener("click", t);
                        }
                    );
                }
            }, [g]);
        const K = (e, t) => {
                e ? w && w(t) : E && E(t),
                    z || (G(a ? null : q.clientWidth), N(e));
            },
            Y = reactExports.Children.toArray(o),
            X = (e) => (t) => {
                let n;
                if (t.currentTarget.hasAttribute("tabindex")) {
                    if (v) {
                        n = Array.isArray(O) ? O.slice() : [];
                        const t = O.indexOf(e.props.value);
                        -1 === t ? n.push(e.props.value) : n.splice(t, 1);
                    } else n = e.props.value;
                    if (
                        (e.props.onClick && e.props.onClick(t),
                        O !== n && (I(n), _))
                    ) {
                        const r = t.nativeEvent || t,
                            i = new r.constructor(r.type, r);
                        Object.defineProperty(i, "target", {
                            writable: !0,
                            value: { value: n, name: b },
                        }),
                            _(i, e);
                    }
                    v || K(!1, t);
                }
            },
            Q = null !== B && D;
        let J, Z;
        delete $["aria-invalid"];
        const ee = [];
        let te = !1;
        (isFilled({ value: O }) || p) && (C ? (J = C(O)) : (te = !0));
        const ne = Y.map((e) => {
            if (!reactExports.isValidElement(e)) return null;
            let t;
            if (v) {
                if (!Array.isArray(O))
                    throw new Error(formatMuiErrorMessage(2));
                (t = O.some((t) => areEqualValues(t, e.props.value))),
                    t && te && ee.push(e.props.children);
            } else
                (t = areEqualValues(O, e.props.value)),
                    t && te && (Z = e.props.children);
            return reactExports.cloneElement(e, {
                "aria-selected": t ? "true" : "false",
                onClick: X(e),
                onKeyUp: (t) => {
                    " " === t.key && t.preventDefault(),
                        e.props.onKeyUp && e.props.onKeyUp(t);
                },
                role: "option",
                selected: t,
                value: void 0,
                "data-value": e.props.value,
            });
        });
        te &&
            (J = v
                ? 0 === ee.length
                    ? null
                    : ee.reduce(
                          (e, t, n) => (
                              e.push(t), n < ee.length - 1 && e.push(", "), e
                          ),
                          []
                      )
                : Z);
        let re,
            ie = W;
        !a && z && B && (ie = q.clientWidth),
            (re = void 0 !== k ? k : d ? null : 0);
        const se = j.id || (b ? `mui-component-select-${b}` : void 0),
            ae = { ...e, variant: M, value: O, open: Q, error: h },
            oe = useUtilityClasses$h(ae),
            le = {
                ...x.PaperProps,
                ...(null == (n = x.slotProps) ? void 0 : n.paper),
            },
            ce = useId();
        return jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx(SelectSelect, {
                    as: "div",
                    ref: H,
                    tabIndex: re,
                    role: "combobox",
                    "aria-controls": ce,
                    "aria-disabled": d ? "true" : void 0,
                    "aria-expanded": Q ? "true" : "false",
                    "aria-haspopup": "listbox",
                    "aria-label": i,
                    "aria-labelledby":
                        [g, se].filter(Boolean).join(" ") || void 0,
                    "aria-describedby": r,
                    onKeyDown: (e) => {
                        if (!R) {
                            [" ", "ArrowUp", "ArrowDown", "Enter"].includes(
                                e.key
                            ) && (e.preventDefault(), K(!0, e));
                        }
                    },
                    onMouseDown:
                        d || R
                            ? null
                            : (e) => {
                                  0 === e.button &&
                                      (e.preventDefault(),
                                      L.current.focus(),
                                      K(!0, e));
                              },
                    onBlur: (e) => {
                        !Q &&
                            y &&
                            (Object.defineProperty(e, "target", {
                                writable: !0,
                                value: { value: O, name: b },
                            }),
                            y(e));
                    },
                    onFocus: S,
                    ...j,
                    ownerState: ae,
                    className: clsx(j.className, oe.select, l),
                    id: se,
                    children: isEmpty(J)
                        ? _span$1 ||
                          (_span$1 = jsxRuntimeExports.jsx("span", {
                              className: "notranslate",
                              children: "​",
                          }))
                        : J,
                }),
                jsxRuntimeExports.jsx(SelectNativeInput, {
                    "aria-invalid": h,
                    value: Array.isArray(O) ? O.join(",") : O,
                    name: b,
                    ref: F,
                    "aria-hidden": !0,
                    onChange: (e) => {
                        const t = Y.find(
                            (t) => t.props.value === e.target.value
                        );
                        void 0 !== t && (I(t.props.value), _ && _(e, t));
                    },
                    tabIndex: -1,
                    disabled: d,
                    className: oe.nativeInput,
                    autoFocus: s,
                    ...$,
                    ownerState: ae,
                }),
                jsxRuntimeExports.jsx(SelectIcon, {
                    as: f,
                    className: oe.icon,
                    ownerState: ae,
                }),
                jsxRuntimeExports.jsx(Menu, {
                    id: `menu-${b || ""}`,
                    anchorEl: q,
                    open: Q,
                    onClose: (e) => {
                        K(!1, e);
                    },
                    anchorOrigin: { vertical: "bottom", horizontal: "center" },
                    transformOrigin: { vertical: "top", horizontal: "center" },
                    ...x,
                    MenuListProps: {
                        "aria-labelledby": g,
                        role: "listbox",
                        "aria-multiselectable": v ? "true" : void 0,
                        disableListWrap: !0,
                        id: ce,
                        ...x.MenuListProps,
                    },
                    slotProps: {
                        ...x.slotProps,
                        paper: {
                            ...le,
                            style: {
                                minWidth: ie,
                                ...(null != le ? le.style : null),
                            },
                        },
                    },
                    children: ne,
                }),
            ],
        });
    }),
    ArrowDropDownIcon = createSvgIcon(
        jsxRuntimeExports.jsx("path", { d: "M7 10l5 5 5-5z" }),
        "ArrowDropDown"
    );
function getInputUtilityClass(e) {
    return generateUtilityClass("MuiInput", e);
}
const inputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses("MuiInput", ["root", "underline", "input"]),
    },
    useUtilityClasses$g = (e) => {
        const { classes: t, disableUnderline: n } = e,
            r = composeClasses(
                { root: ["root", !n && "underline"], input: ["input"] },
                getInputUtilityClass,
                t
            );
        return { ...t, ...r };
    },
    InputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (e) => rootShouldForwardProp(e) || "classes" === e,
        name: "MuiInput",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                ...rootOverridesResolver(e, t),
                !n.disableUnderline && t.underline,
            ];
        },
    })(
        memoTheme(({ theme: e }) => {
            let t =
                "light" === e.palette.mode
                    ? "rgba(0, 0, 0, 0.42)"
                    : "rgba(255, 255, 255, 0.7)";
            return (
                e.vars &&
                    (t = `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`),
                {
                    position: "relative",
                    variants: [
                        {
                            props: ({ ownerState: e }) => e.formControl,
                            style: { "label + &": { marginTop: 16 } },
                        },
                        {
                            props: ({ ownerState: e }) => !e.disableUnderline,
                            style: {
                                "&::after": {
                                    left: 0,
                                    bottom: 0,
                                    content: '""',
                                    position: "absolute",
                                    right: 0,
                                    transform: "scaleX(0)",
                                    transition: e.transitions.create(
                                        "transform",
                                        {
                                            duration:
                                                e.transitions.duration.shorter,
                                            easing: e.transitions.easing
                                                .easeOut,
                                        }
                                    ),
                                    pointerEvents: "none",
                                },
                                [`&.${inputClasses.focused}:after`]: {
                                    transform: "scaleX(1) translateX(0)",
                                },
                                [`&.${inputClasses.error}`]: {
                                    "&::before, &::after": {
                                        borderBottomColor: (e.vars || e).palette
                                            .error.main,
                                    },
                                },
                                "&::before": {
                                    borderBottom: `1px solid ${t}`,
                                    left: 0,
                                    bottom: 0,
                                    content: '"\\00a0"',
                                    position: "absolute",
                                    right: 0,
                                    transition: e.transitions.create(
                                        "border-bottom-color",
                                        {
                                            duration:
                                                e.transitions.duration.shorter,
                                        }
                                    ),
                                    pointerEvents: "none",
                                },
                                [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]:
                                    {
                                        borderBottom: `2px solid ${
                                            (e.vars || e).palette.text.primary
                                        }`,
                                        "@media (hover: none)": {
                                            borderBottom: `1px solid ${t}`,
                                        },
                                    },
                                [`&.${inputClasses.disabled}:before`]: {
                                    borderBottomStyle: "dotted",
                                },
                            },
                        },
                        ...Object.entries(e.palette)
                            .filter(createSimplePaletteValueFilter())
                            .map(([t]) => ({
                                props: { color: t, disableUnderline: !1 },
                                style: {
                                    "&::after": {
                                        borderBottom: `2px solid ${
                                            (e.vars || e).palette[t].main
                                        }`,
                                    },
                                },
                            })),
                    ],
                }
            );
        })
    ),
    InputInput = styled(InputBaseInput, {
        name: "MuiInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver,
    })({}),
    Input$1 = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiInput" }),
            {
                disableUnderline: r = !1,
                components: i = {},
                componentsProps: s,
                fullWidth: a = !1,
                inputComponent: o = "input",
                multiline: l = !1,
                slotProps: c,
                slots: u = {},
                type: d = "text",
                ...p
            } = n,
            h = useUtilityClasses$g(n),
            f = { root: { ownerState: { disableUnderline: r } } },
            m = c ?? s ? deepmerge(c ?? s, f) : f,
            g = u.root ?? i.Root ?? InputRoot,
            x = u.input ?? i.Input ?? InputInput;
        return jsxRuntimeExports.jsx(InputBase, {
            slots: { root: g, input: x },
            slotProps: m,
            fullWidth: a,
            inputComponent: o,
            multiline: l,
            ref: t,
            type: d,
            ...p,
            classes: h,
        });
    });
function getFilledInputUtilityClass(e) {
    return generateUtilityClass("MuiFilledInput", e);
}
Input$1 && (Input$1.muiName = "Input");
const filledInputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses("MuiFilledInput", [
            "root",
            "underline",
            "input",
            "adornedStart",
            "adornedEnd",
            "sizeSmall",
            "multiline",
            "hiddenLabel",
        ]),
    },
    useUtilityClasses$f = (e) => {
        const {
                classes: t,
                disableUnderline: n,
                startAdornment: r,
                endAdornment: i,
                size: s,
                hiddenLabel: a,
                multiline: o,
            } = e,
            l = composeClasses(
                {
                    root: [
                        "root",
                        !n && "underline",
                        r && "adornedStart",
                        i && "adornedEnd",
                        "small" === s && `size${capitalize(s)}`,
                        a && "hiddenLabel",
                        o && "multiline",
                    ],
                    input: ["input"],
                },
                getFilledInputUtilityClass,
                t
            );
        return { ...t, ...l };
    },
    FilledInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (e) => rootShouldForwardProp(e) || "classes" === e,
        name: "MuiFilledInput",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [
                ...rootOverridesResolver(e, t),
                !n.disableUnderline && t.underline,
            ];
        },
    })(
        memoTheme(({ theme: e }) => {
            const t = "light" === e.palette.mode,
                n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)",
                r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)",
                i = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)",
                s = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
            return {
                position: "relative",
                backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
                borderTopLeftRadius: (e.vars || e).shape.borderRadius,
                borderTopRightRadius: (e.vars || e).shape.borderRadius,
                transition: e.transitions.create("background-color", {
                    duration: e.transitions.duration.shorter,
                    easing: e.transitions.easing.easeOut,
                }),
                "&:hover": {
                    backgroundColor: e.vars
                        ? e.vars.palette.FilledInput.hoverBg
                        : i,
                    "@media (hover: none)": {
                        backgroundColor: e.vars
                            ? e.vars.palette.FilledInput.bg
                            : r,
                    },
                },
                [`&.${filledInputClasses.focused}`]: {
                    backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
                },
                [`&.${filledInputClasses.disabled}`]: {
                    backgroundColor: e.vars
                        ? e.vars.palette.FilledInput.disabledBg
                        : s,
                },
                variants: [
                    {
                        props: ({ ownerState: e }) => !e.disableUnderline,
                        style: {
                            "&::after": {
                                left: 0,
                                bottom: 0,
                                content: '""',
                                position: "absolute",
                                right: 0,
                                transform: "scaleX(0)",
                                transition: e.transitions.create("transform", {
                                    duration: e.transitions.duration.shorter,
                                    easing: e.transitions.easing.easeOut,
                                }),
                                pointerEvents: "none",
                            },
                            [`&.${filledInputClasses.focused}:after`]: {
                                transform: "scaleX(1) translateX(0)",
                            },
                            [`&.${filledInputClasses.error}`]: {
                                "&::before, &::after": {
                                    borderBottomColor: (e.vars || e).palette
                                        .error.main,
                                },
                            },
                            "&::before": {
                                borderBottom: `1px solid ${
                                    e.vars
                                        ? `rgba(${e.vars.palette.common.onBackgroundChannel} / ${e.vars.opacity.inputUnderline})`
                                        : n
                                }`,
                                left: 0,
                                bottom: 0,
                                content: '"\\00a0"',
                                position: "absolute",
                                right: 0,
                                transition: e.transitions.create(
                                    "border-bottom-color",
                                    { duration: e.transitions.duration.shorter }
                                ),
                                pointerEvents: "none",
                            },
                            [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]:
                                {
                                    borderBottom: `1px solid ${
                                        (e.vars || e).palette.text.primary
                                    }`,
                                },
                            [`&.${filledInputClasses.disabled}:before`]: {
                                borderBottomStyle: "dotted",
                            },
                        },
                    },
                    ...Object.entries(e.palette)
                        .filter(createSimplePaletteValueFilter())
                        .map(([t]) => {
                            var n;
                            return {
                                props: { disableUnderline: !1, color: t },
                                style: {
                                    "&::after": {
                                        borderBottom: `2px solid ${
                                            null ==
                                            (n = (e.vars || e).palette[t])
                                                ? void 0
                                                : n.main
                                        }`,
                                    },
                                },
                            };
                        }),
                    {
                        props: ({ ownerState: e }) => e.startAdornment,
                        style: { paddingLeft: 12 },
                    },
                    {
                        props: ({ ownerState: e }) => e.endAdornment,
                        style: { paddingRight: 12 },
                    },
                    {
                        props: ({ ownerState: e }) => e.multiline,
                        style: { padding: "25px 12px 8px" },
                    },
                    {
                        props: ({ ownerState: e, size: t }) =>
                            e.multiline && "small" === t,
                        style: { paddingTop: 21, paddingBottom: 4 },
                    },
                    {
                        props: ({ ownerState: e }) =>
                            e.multiline && e.hiddenLabel,
                        style: { paddingTop: 16, paddingBottom: 17 },
                    },
                    {
                        props: ({ ownerState: e }) =>
                            e.multiline && e.hiddenLabel && "small" === e.size,
                        style: { paddingTop: 8, paddingBottom: 9 },
                    },
                ],
            };
        })
    ),
    FilledInputInput = styled(InputBaseInput, {
        name: "MuiFilledInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver,
    })(
        memoTheme(({ theme: e }) => ({
            paddingTop: 25,
            paddingRight: 12,
            paddingBottom: 8,
            paddingLeft: 12,
            ...(!e.vars && {
                "&:-webkit-autofill": {
                    WebkitBoxShadow:
                        "light" === e.palette.mode
                            ? null
                            : "0 0 0 100px #266798 inset",
                    WebkitTextFillColor:
                        "light" === e.palette.mode ? null : "#fff",
                    caretColor: "light" === e.palette.mode ? null : "#fff",
                    borderTopLeftRadius: "inherit",
                    borderTopRightRadius: "inherit",
                },
            }),
            ...(e.vars && {
                "&:-webkit-autofill": {
                    borderTopLeftRadius: "inherit",
                    borderTopRightRadius: "inherit",
                },
                [e.getColorSchemeSelector("dark")]: {
                    "&:-webkit-autofill": {
                        WebkitBoxShadow: "0 0 0 100px #266798 inset",
                        WebkitTextFillColor: "#fff",
                        caretColor: "#fff",
                    },
                },
            }),
            variants: [
                {
                    props: { size: "small" },
                    style: { paddingTop: 21, paddingBottom: 4 },
                },
                {
                    props: ({ ownerState: e }) => e.hiddenLabel,
                    style: { paddingTop: 16, paddingBottom: 17 },
                },
                {
                    props: ({ ownerState: e }) => e.startAdornment,
                    style: { paddingLeft: 0 },
                },
                {
                    props: ({ ownerState: e }) => e.endAdornment,
                    style: { paddingRight: 0 },
                },
                {
                    props: ({ ownerState: e }) =>
                        e.hiddenLabel && "small" === e.size,
                    style: { paddingTop: 8, paddingBottom: 9 },
                },
                {
                    props: ({ ownerState: e }) => e.multiline,
                    style: {
                        paddingTop: 0,
                        paddingBottom: 0,
                        paddingLeft: 0,
                        paddingRight: 0,
                    },
                },
            ],
        }))
    ),
    FilledInput = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiFilledInput" }),
            {
                disableUnderline: r = !1,
                components: i = {},
                componentsProps: s,
                fullWidth: a = !1,
                hiddenLabel: o,
                inputComponent: l = "input",
                multiline: c = !1,
                slotProps: u,
                slots: d = {},
                type: p = "text",
                ...h
            } = n,
            f = {
                ...n,
                disableUnderline: r,
                fullWidth: a,
                inputComponent: l,
                multiline: c,
                type: p,
            },
            m = useUtilityClasses$f(n),
            g = { root: { ownerState: f }, input: { ownerState: f } },
            x = u ?? s ? deepmerge(g, u ?? s) : g,
            v = d.root ?? i.Root ?? FilledInputRoot,
            b = d.input ?? i.Input ?? FilledInputInput;
        return jsxRuntimeExports.jsx(InputBase, {
            slots: { root: v, input: b },
            componentsProps: x,
            fullWidth: a,
            inputComponent: l,
            multiline: c,
            ref: t,
            type: p,
            ...h,
            classes: m,
        });
    });
var _span;
FilledInput && (FilledInput.muiName = "Input");
const NotchedOutlineRoot$1 = styled("fieldset", {
        shouldForwardProp: rootShouldForwardProp,
    })({
        textAlign: "left",
        position: "absolute",
        bottom: 0,
        right: 0,
        top: -5,
        left: 0,
        margin: 0,
        padding: "0 8px",
        pointerEvents: "none",
        borderRadius: "inherit",
        borderStyle: "solid",
        borderWidth: 1,
        overflow: "hidden",
        minWidth: "0%",
    }),
    NotchedOutlineLegend = styled("legend", {
        shouldForwardProp: rootShouldForwardProp,
    })(
        memoTheme(({ theme: e }) => ({
            float: "unset",
            width: "auto",
            overflow: "hidden",
            variants: [
                {
                    props: ({ ownerState: e }) => !e.withLabel,
                    style: {
                        padding: 0,
                        lineHeight: "11px",
                        transition: e.transitions.create("width", {
                            duration: 150,
                            easing: e.transitions.easing.easeOut,
                        }),
                    },
                },
                {
                    props: ({ ownerState: e }) => e.withLabel,
                    style: {
                        display: "block",
                        padding: 0,
                        height: 11,
                        fontSize: "0.75em",
                        visibility: "hidden",
                        maxWidth: 0.01,
                        transition: e.transitions.create("max-width", {
                            duration: 50,
                            easing: e.transitions.easing.easeOut,
                        }),
                        whiteSpace: "nowrap",
                        "& > span": {
                            paddingLeft: 5,
                            paddingRight: 5,
                            display: "inline-block",
                            opacity: 0,
                            visibility: "visible",
                        },
                    },
                },
                {
                    props: ({ ownerState: e }) => e.withLabel && e.notched,
                    style: {
                        maxWidth: "100%",
                        transition: e.transitions.create("max-width", {
                            duration: 100,
                            easing: e.transitions.easing.easeOut,
                            delay: 50,
                        }),
                    },
                },
            ],
        }))
    );
function NotchedOutline(e) {
    const {
            children: t,
            classes: n,
            className: r,
            label: i,
            notched: s,
            ...a
        } = e,
        o = null != i && "" !== i,
        l = { ...e, notched: s, withLabel: o };
    return jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
        "aria-hidden": !0,
        className: r,
        ownerState: l,
        ...a,
        children: jsxRuntimeExports.jsx(NotchedOutlineLegend, {
            ownerState: l,
            children: o
                ? jsxRuntimeExports.jsx("span", { children: i })
                : _span ||
                  (_span = jsxRuntimeExports.jsx("span", {
                      className: "notranslate",
                      children: "​",
                  })),
        }),
    });
}
function getOutlinedInputUtilityClass(e) {
    return generateUtilityClass("MuiOutlinedInput", e);
}
const outlinedInputClasses = {
        ...inputBaseClasses,
        ...generateUtilityClasses("MuiOutlinedInput", [
            "root",
            "notchedOutline",
            "input",
        ]),
    },
    useUtilityClasses$e = (e) => {
        const { classes: t } = e,
            n = composeClasses(
                {
                    root: ["root"],
                    notchedOutline: ["notchedOutline"],
                    input: ["input"],
                },
                getOutlinedInputUtilityClass,
                t
            );
        return { ...t, ...n };
    },
    OutlinedInputRoot = styled(InputBaseRoot, {
        shouldForwardProp: (e) => rootShouldForwardProp(e) || "classes" === e,
        name: "MuiOutlinedInput",
        slot: "Root",
        overridesResolver: rootOverridesResolver,
    })(
        memoTheme(({ theme: e }) => {
            const t =
                "light" === e.palette.mode
                    ? "rgba(0, 0, 0, 0.23)"
                    : "rgba(255, 255, 255, 0.23)";
            return {
                position: "relative",
                borderRadius: (e.vars || e).shape.borderRadius,
                [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: (e.vars || e).palette.text.primary,
                },
                "@media (hover: none)": {
                    [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                        borderColor: e.vars
                            ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)`
                            : t,
                    },
                },
                [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]:
                    { borderWidth: 2 },
                variants: [
                    ...Object.entries(e.palette)
                        .filter(createSimplePaletteValueFilter())
                        .map(([t]) => ({
                            props: { color: t },
                            style: {
                                [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]:
                                    {
                                        borderColor: (e.vars || e).palette[t]
                                            .main,
                                    },
                            },
                        })),
                    {
                        props: {},
                        style: {
                            [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]:
                                {
                                    borderColor: (e.vars || e).palette.error
                                        .main,
                                },
                            [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]:
                                {
                                    borderColor: (e.vars || e).palette.action
                                        .disabled,
                                },
                        },
                    },
                    {
                        props: ({ ownerState: e }) => e.startAdornment,
                        style: { paddingLeft: 14 },
                    },
                    {
                        props: ({ ownerState: e }) => e.endAdornment,
                        style: { paddingRight: 14 },
                    },
                    {
                        props: ({ ownerState: e }) => e.multiline,
                        style: { padding: "16.5px 14px" },
                    },
                    {
                        props: ({ ownerState: e, size: t }) =>
                            e.multiline && "small" === t,
                        style: { padding: "8.5px 14px" },
                    },
                ],
            };
        })
    ),
    NotchedOutlineRoot = styled(NotchedOutline, {
        name: "MuiOutlinedInput",
        slot: "NotchedOutline",
        overridesResolver: (e, t) => t.notchedOutline,
    })(
        memoTheme(({ theme: e }) => {
            const t =
                "light" === e.palette.mode
                    ? "rgba(0, 0, 0, 0.23)"
                    : "rgba(255, 255, 255, 0.23)";
            return {
                borderColor: e.vars
                    ? `rgba(${e.vars.palette.common.onBackgroundChannel} / 0.23)`
                    : t,
            };
        })
    ),
    OutlinedInputInput = styled(InputBaseInput, {
        name: "MuiOutlinedInput",
        slot: "Input",
        overridesResolver: inputOverridesResolver,
    })(
        memoTheme(({ theme: e }) => ({
            padding: "16.5px 14px",
            ...(!e.vars && {
                "&:-webkit-autofill": {
                    WebkitBoxShadow:
                        "light" === e.palette.mode
                            ? null
                            : "0 0 0 100px #266798 inset",
                    WebkitTextFillColor:
                        "light" === e.palette.mode ? null : "#fff",
                    caretColor: "light" === e.palette.mode ? null : "#fff",
                    borderRadius: "inherit",
                },
            }),
            ...(e.vars && {
                "&:-webkit-autofill": { borderRadius: "inherit" },
                [e.getColorSchemeSelector("dark")]: {
                    "&:-webkit-autofill": {
                        WebkitBoxShadow: "0 0 0 100px #266798 inset",
                        WebkitTextFillColor: "#fff",
                        caretColor: "#fff",
                    },
                },
            }),
            variants: [
                { props: { size: "small" }, style: { padding: "8.5px 14px" } },
                {
                    props: ({ ownerState: e }) => e.multiline,
                    style: { padding: 0 },
                },
                {
                    props: ({ ownerState: e }) => e.startAdornment,
                    style: { paddingLeft: 0 },
                },
                {
                    props: ({ ownerState: e }) => e.endAdornment,
                    style: { paddingRight: 0 },
                },
            ],
        }))
    ),
    OutlinedInput = reactExports.forwardRef(function (e, t) {
        var n;
        const r = useDefaultProps({ props: e, name: "MuiOutlinedInput" }),
            {
                components: i = {},
                fullWidth: s = !1,
                inputComponent: a = "input",
                label: o,
                multiline: l = !1,
                notched: c,
                slots: u = {},
                type: d = "text",
                ...p
            } = r,
            h = useUtilityClasses$e(r),
            f = useFormControl(),
            m = formControlState({
                props: r,
                muiFormControl: f,
                states: [
                    "color",
                    "disabled",
                    "error",
                    "focused",
                    "hiddenLabel",
                    "size",
                    "required",
                ],
            }),
            g = {
                ...r,
                color: m.color || "primary",
                disabled: m.disabled,
                error: m.error,
                focused: m.focused,
                formControl: f,
                fullWidth: s,
                hiddenLabel: m.hiddenLabel,
                multiline: l,
                size: m.size,
                type: d,
            },
            x = u.root ?? i.Root ?? OutlinedInputRoot,
            v = u.input ?? i.Input ?? OutlinedInputInput;
        return jsxRuntimeExports.jsx(InputBase, {
            slots: { root: x, input: v },
            renderSuffix: (e) =>
                jsxRuntimeExports.jsx(NotchedOutlineRoot, {
                    ownerState: g,
                    className: h.notchedOutline,
                    label:
                        null != o && "" !== o && m.required
                            ? n ||
                              (n = jsxRuntimeExports.jsxs(
                                  reactExports.Fragment,
                                  { children: [o, " ", "*"] }
                              ))
                            : o,
                    notched:
                        void 0 !== c
                            ? c
                            : Boolean(
                                  e.startAdornment || e.filled || e.focused
                              ),
                }),
            fullWidth: s,
            inputComponent: a,
            multiline: l,
            ref: t,
            type: d,
            ...p,
            classes: { ...h, notchedOutline: null },
        });
    });
OutlinedInput && (OutlinedInput.muiName = "Input");
const useUtilityClasses$d = (e) => {
        const { classes: t } = e;
        return t;
    },
    styledRootConfig = {
        name: "MuiSelect",
        overridesResolver: (e, t) => t.root,
        shouldForwardProp: (e) => rootShouldForwardProp(e) && "variant" !== e,
        slot: "Root",
    },
    StyledInput = styled(Input$1, styledRootConfig)(""),
    StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)(""),
    StyledFilledInput = styled(FilledInput, styledRootConfig)(""),
    Select = reactExports.forwardRef(function (e, t) {
        const n = useThemeProps({ name: "MuiSelect", props: e }),
            {
                autoWidth: r = !1,
                children: i,
                classes: s = {},
                className: a,
                defaultOpen: o = !1,
                displayEmpty: l = !1,
                IconComponent: c = ArrowDropDownIcon,
                id: u,
                input: d,
                inputProps: p,
                label: h,
                labelId: f,
                MenuProps: m,
                multiple: g = !1,
                native: x = !1,
                onClose: v,
                onOpen: b,
                open: y,
                renderValue: _,
                SelectDisplayProps: E,
                variant: S = "outlined",
                ...w
            } = n,
            A = x ? NativeSelectInput : SelectInput,
            R = formControlState({
                props: n,
                muiFormControl: useFormControl(),
                states: ["variant", "error"],
            }),
            C = R.variant || S,
            j = { ...n, variant: C, classes: s },
            k = useUtilityClasses$d(j),
            { root: P, ...T } = k,
            M =
                d ||
                {
                    standard: jsxRuntimeExports.jsx(StyledInput, {
                        ownerState: j,
                    }),
                    outlined: jsxRuntimeExports.jsx(StyledOutlinedInput, {
                        label: h,
                        ownerState: j,
                    }),
                    filled: jsxRuntimeExports.jsx(StyledFilledInput, {
                        ownerState: j,
                    }),
                }[C],
            $ = useForkRef(t, getReactElementRef(M));
        return jsxRuntimeExports.jsx(reactExports.Fragment, {
            children: reactExports.cloneElement(M, {
                inputComponent: A,
                inputProps: {
                    children: i,
                    error: R.error,
                    IconComponent: c,
                    variant: C,
                    type: void 0,
                    multiple: g,
                    ...(x
                        ? { id: u }
                        : {
                              autoWidth: r,
                              defaultOpen: o,
                              displayEmpty: l,
                              labelId: f,
                              MenuProps: m,
                              onClose: v,
                              onOpen: b,
                              open: y,
                              renderValue: _,
                              SelectDisplayProps: { id: u, ...E },
                          }),
                    ...p,
                    classes: p ? deepmerge(T, p.classes) : T,
                    ...(d ? d.props.inputProps : {}),
                },
                ...(((g && x) || l) && "outlined" === C ? { notched: !0 } : {}),
                ref: $,
                className: clsx(M.props.className, a, k.root),
                ...(!d && { variant: C }),
                ...w,
            }),
        });
    });
function getToolbarUtilityClass(e) {
    return generateUtilityClass("MuiToolbar", e);
}
(Select.muiName = "Select"),
    generateUtilityClasses("MuiToolbar", [
        "root",
        "gutters",
        "regular",
        "dense",
    ]);
const useUtilityClasses$c = (e) => {
        const { classes: t, disableGutters: n, variant: r } = e;
        return composeClasses(
            { root: ["root", !n && "gutters", r] },
            getToolbarUtilityClass,
            t
        );
    },
    ToolbarRoot = styled("div", {
        name: "MuiToolbar",
        slot: "Root",
        overridesResolver: (e, t) => {
            const { ownerState: n } = e;
            return [t.root, !n.disableGutters && t.gutters, t[n.variant]];
        },
    })(
        memoTheme(({ theme: e }) => ({
            position: "relative",
            display: "flex",
            alignItems: "center",
            variants: [
                {
                    props: ({ ownerState: e }) => !e.disableGutters,
                    style: {
                        paddingLeft: e.spacing(2),
                        paddingRight: e.spacing(2),
                        [e.breakpoints.up("sm")]: {
                            paddingLeft: e.spacing(3),
                            paddingRight: e.spacing(3),
                        },
                    },
                },
                { props: { variant: "dense" }, style: { minHeight: 48 } },
                { props: { variant: "regular" }, style: e.mixins.toolbar },
            ],
        }))
    ),
    Toolbar = reactExports.forwardRef(function (e, t) {
        const n = useDefaultProps({ props: e, name: "MuiToolbar" }),
            {
                className: r,
                component: i = "div",
                disableGutters: s = !1,
                variant: a = "regular",
                ...o
            } = n,
            l = { ...n, component: i, disableGutters: s, variant: a },
            c = useUtilityClasses$c(l);
        return jsxRuntimeExports.jsx(ToolbarRoot, {
            as: i,
            className: clsx(c.root, r),
            ref: t,
            ownerState: l,
            ...o,
        });
    }),
    KeyboardArrowLeft$1 = createSvgIcon(
        jsxRuntimeExports.jsx("path", {
            d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z",
        }),
        "KeyboardArrowLeft"
    ),
    KeyboardArrowRight$1 = createSvgIcon(
        jsxRuntimeExports.jsx("path", {
            d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z",
        }),
        "KeyboardArrowRight"
    );
function getIcon                                  __privateAdd(this, Z),
                                        __privateAdd(this, te),
                                        __privateAdd(this, re),
                                        __privateAdd(this, se),
                                        __privateAdd(this, oe),
                                        __privateAdd(this, ce),
                                        __privateAdd(this, de),
                                        __privateAdd(this, he),
                                        __privateAdd(this, me),
                                        __privateAdd(this, xe),
                                        __privateAdd(this, be),
                                        __privateAdd(this, m, null),
                                        __privateAdd(this, g, new Map()),
                                        __privateAdd(this, x, new Map()),
                                        __privateAdd(this, v, null),
                                        __privateAdd(this, b, null),
                                        __privateAdd(this, y, new Re()),
                                        __privateAdd(this, _, 0),
                                        __privateAdd(this, E, new Set()),
                                        __privateAdd(this, S, null),
                                        __privateAdd(this, w, null),
                                        __privateAdd(this, A, new Set()),
                                        __privateAdd(this, R, null),
                                        __privateAdd(this, C, new Se()),
                                        __privateAdd(this, j, !1),
                                        __privateAdd(this, k, !1),
                                        __privateAdd(this, P, null),
                                        __privateAdd(
                                            this,
                                            T,
                                            _e.AnnotationEditorType.NONE
                                        ),
                                        __privateAdd(this, M, new Set()),
                                        __privateAdd(this, $, null),
                                        __privateAdd(
                                            this,
                                            O,
                                            this.blur.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            I,
                                            this.focus.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            D,
                                            this.copy.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            N,
                                            this.cut.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            F,
                                            this.paste.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            L,
                                            this.keydown.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            B,
                                            this.onEditingAction.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            U,
                                            this.onPageChanging.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            z,
                                            this.onScaleChanging.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            W,
                                            this.onRotationChanging.bind(this)
                                        ),
                                        __privateAdd(this, G, {
                                            isEditing: !1,
                                            isEmpty: !0,
                                            hasSomethingToUndo: !1,
                                            hasSomethingToRedo: !1,
                                            hasSelectedEditor: !1,
                                        }),
                                        __privateAdd(this, V, [0, 0]),
                                        __privateAdd(this, H, null),
                                        __privateAdd(this, q, null),
                                        __privateAdd(this, K, null),
                                        __privateSet(this, q, e),
                                        __privateSet(this, K, t),
                                        __privateSet(this, v, n),
                                        (this._eventBus = r),
                                        this._eventBus._on(
                                            "editingaction",
                                            __privateGet(this, B)
                                        ),
                                        this._eventBus._on(
                                            "pagechanging",
                                            __privateGet(this, U)
                                        ),
                                        this._eventBus._on(
                                            "scalechanging",
                                            __privateGet(this, z)
                                        ),
                                        this._eventBus._on(
                                            "rotationchanging",
                                            __privateGet(this, W)
                                        ),
                                        __privateSet(
                                            this,
                                            b,
                                            i.annotationStorage
                                        ),
                                        __privateSet(this, R, i.filterFactory),
                                        __privateSet(this, $, s),
                                        (this.viewParameters = {
                                            realScale:
                                                Ee.PixelsPerInch
                                                    .PDF_TO_CSS_UNITS,
                                            rotation: 0,
                                        });
                                }
                                static get _keyboardManager() {
                                    const t = e.prototype,
                                        n = (e) => {
                                            const { activeElement: t } =
                                                document;
                                            return (
                                                t &&
                                                __privateGet(e, q).contains(
                                                    t
                                                ) &&
                                                e.hasSomethingToControl()
                                            );
                                        },
                                        r = this.TRANSLATE_SMALL,
                                        i = this.TRANSLATE_BIG;
                                    return (0, _e.shadow)(
                                        this,
                                        "_keyboardManager",
                                        new Ce([
                                            [
                                                ["ctrl+a", "mac+meta+a"],
                                                t.selectAll,
                                            ],
                                            [["ctrl+z", "mac+meta+z"], t.undo],
                                            [
                                                [
                                                    "ctrl+y",
                                                    "ctrl+shift+z",
                                                    "mac+meta+shift+z",
                                                    "ctrl+shift+Z",
                                                    "mac+meta+shift+Z",
                                                ],
                                                t.redo,
                                            ],
                                            [
                                                [
                                                    "Backspace",
                                                    "alt+Backspace",
                                                    "ctrl+Backspace",
                                                    "shift+Backspace",
                                                    "mac+Backspace",
                                                    "mac+alt+Backspace",
                                                    "mac+ctrl+Backspace",
                                                    "Delete",
                                                    "ctrl+Delete",
                                                    "shift+Delete",
                                                    "mac+Delete",
                                                ],
                                                t.delete,
                                            ],
                                            [
                                                ["Escape", "mac+Escape"],
                                                t.unselectAll,
                                            ],
                                            [
                                                ["ArrowLeft", "mac+ArrowLeft"],
                                                t.translateSelectedEditors,
                                                { args: [-r, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowLeft",
                                                    "mac+shift+ArrowLeft",
                                                ],
                                                t.translateSelectedEditors,
                                                { args: [-i, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ArrowRight",
                                                    "mac+ArrowRight",
                                                ],
                                                t.translateSelectedEditors,
                                                { args: [r, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowRight",
                                                    "mac+shift+ArrowRight",
                                                ],
                                                t.translateSelectedEditors,
                                                { args: [i, 0], checker: n },
                                            ],
                                            [
                                                ["ArrowUp", "mac+ArrowUp"],
                                                t.translateSelectedEditors,
                                                { args: [0, -r], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowUp",
                                                    "mac+shift+ArrowUp",
                                                ],
                                                t.translateSelectedEditors,
                                                { args: [0, -i], checker: n },
                                            ],
                                            [
                                                ["ArrowDown", "mac+ArrowDown"],
                                                t.translateSelectedEditors,
                                                { args: [0, r], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowDown",
                                                    "mac+shift+ArrowDown",
                                                ],
                                                t.translateSelectedEditors,
                                                { args: [0, i], checker: n },
                                            ],
                                        ])
                                    );
                                }
                                destroy() {
                                    __privateMethod(this, te, ne).call(this),
                                        __privateMethod(this, Q, J).call(this),
                                        this._eventBus._off(
                                            "editingaction",
                                            __privateGet(this, B)
                                        ),
                                        this._eventBus._off(
                                            "pagechanging",
                                            __privateGet(this, U)
                                        ),
                                        this._eventBus._off(
                                            "scalechanging",
                                            __privateGet(this, z)
                                        ),
                                        this._eventBus._off(
                                            "rotationchanging",
                                            __privateGet(this, W)
                                        );
                                    for (const e of __privateGet(
                                        this,
                                        x
                                    ).values())
                                        e.destroy();
                                    __privateGet(this, x).clear(),
                                        __privateGet(this, g).clear(),
                                        __privateGet(this, A).clear(),
                                        __privateSet(this, m, null),
                                        __privateGet(this, M).clear(),
                                        __privateGet(this, y).destroy(),
                                        __privateGet(this, v).destroy();
                                }
                                get hcmFilter() {
                                    return (0, _e.shadow)(
                                        this,
                                        "hcmFilter",
                                        __privateGet(this, $)
                                            ? __privateGet(
                                                  this,
                                                  R
                                              ).addHCMFilter(
                                                  __privateGet(this, $)
                                                      .foreground,
                                                  __privateGet(this, $)
                                                      .background
                                              )
                                            : "none"
                                    );
                                }
                                get direction() {
                                    return (0, _e.shadow)(
                                        this,
                                        "direction",
                                        getComputedStyle(__privateGet(this, q))
                                            .direction
                                    );
                                }
                                editAltText(e) {
                                    var t;
                                    null == (t = __privateGet(this, v)) ||
                                        t.editAltText(this, e);
                                }
                                onPageChanging({ pageNumber: e }) {
                                    __privateSet(this, _, e - 1);
                                }
                                focusMainContainer() {
                                    __privateGet(this, q).focus();
                                }
                                findParent(e, t) {
                                    for (const n of __privateGet(
                                        this,
                                        x
                                    ).values()) {
                                        const {
                                            x: r,
                                            y: i,
                                            width: s,
                                            height: a,
                                        } = n.div.getBoundingClientRect();
                                        if (
                                            e >= r &&
                                            e <= r + s &&
                                            t >= i &&
                                            t <= i + a
                                        )
                                            return n;
                                    }
                                    return null;
                                }
                                disableUserSelect(e = !1) {
                                    __privateGet(this, K).classList.toggle(
                                        "noUserSelect",
                                        e
                                    );
                                }
                                addShouldRescale(e) {
                                    __privateGet(this, A).add(e);
                                }
                                removeShouldRescale(e) {
                                    __privateGet(this, A).delete(e);
                                }
                                onScaleChanging({ scale: e }) {
                                    this.commitOrRemove(),
                                        (this.viewParameters.realScale =
                                            e *
                                            Ee.PixelsPerInch.PDF_TO_CSS_UNITS);
                                    for (const t of __privateGet(this, A))
                                        t.onScaleChanging();
                                }
                                onRotationChanging({ pagesRotation: e }) {
                                    this.commitOrRemove(),
                                        (this.viewParameters.rotation = e);
                                }
                                addToAnnotationStorage(e) {
                                    e.isEmpty() ||
                                        !__privateGet(this, b) ||
                                        __privateGet(this, b).has(e.id) ||
                                        __privateGet(this, b).setValue(e.id, e);
                                }
                                blur() {
                                    if (!this.hasSelection) return;
                                    const { activeElement: e } = document;
                                    for (const t of __privateGet(this, M))
                                        if (t.div.contains(e)) {
                                            __privateSet(this, P, [t, e]),
                                                (t._focusEventsAllowed = !1);
                                            break;
                                        }
                                }
                                focus() {
                                    if (!__privateGet(this, P)) return;
                                    const [e, t] = __privateGet(this, P);
                                    __privateSet(this, P, null),
                                        t.addEventListener(
                                            "focusin",
                                            () => {
                                                e._focusEventsAllowed = !0;
                                            },
                                            { once: !0 }
                                        ),
                                        t.focus();
                                }
                                addEditListeners() {
                                    __privateMethod(this, Z, ee).call(this),
                                        __privateMethod(this, re, ie).call(
                                            this
                                        );
                                }
                                removeEditListeners() {
                                    __privateMethod(this, te, ne).call(this),
                                        __privateMethod(this, se, ae).call(
                                            this
                                        );
                                }
                                copy(e) {
                                    var t;
                                    if (
                                        (e.preventDefault(),
                                        null == (t = __privateGet(this, m)) ||
                                            t.commitOrRemove(),
                                        !this.hasSelection)
                                    )
                                        return;
                                    const n = [];
                                    for (const r of __privateGet(this, M)) {
                                        const e = r.serialize(!0);
                                        e && n.push(e);
                                    }
                                    0 !== n.length &&
                                        e.clipboardData.setData(
                                            "application/pdfjs",
                                            JSON.stringify(n)
                                        );
                                }
                                cut(e) {
                                    this.copy(e), this.delete();
                                }
                                paste(e) {
                                    e.preventDefault();
                                    const { clipboardData: t } = e;
                                    for (const s of t.items)
                                        for (const e of __privateGet(this, w))
                                            if (
                                                e.isHandlingMimeForPasting(
                                                    s.type
                                                )
                                            )
                                                return void e.paste(
                                                    s,
                                                    this.currentLayer
                                                );
                                    let n = t.getData("application/pdfjs");
                                    if (!n) return;
                                    try {
                                        n = JSON.parse(n);
                                    } catch (i) {
                                        return void (0, _e.warn)(
                                            `paste: "${i.message}".`
                                        );
                                    }
                                    if (!Array.isArray(n)) return;
                                    this.unselectAll();
                                    const r = this.currentLayer;
                                    try {
                                        const e = [];
                                        for (const s of n) {
                                            const t = r.deserialize(s);
                                            if (!t) return;
                                            e.push(t);
                                        }
                                        const t = () => {
                                                for (const t of e)
                                                    __privateMethod(
                                                        this,
                                                        me,
                                                        ge
                                                    ).call(this, t);
                                                __privateMethod(
                                                    this,
                                                    be,
                                                    ye
                                                ).call(this, e);
                                            },
                                            i = () => {
                                                for (const t of e) t.remove();
                                            };
                                        this.addCommands({
                                            cmd: t,
                                            undo: i,
                                            mustExec: !0,
                                        });
                                    } catch (i) {
                                        (0, _e.warn)(`paste: "${i.message}".`);
                                    }
                                }
                                keydown(t) {
                                    var n;
                                    (null == (n = this.getActive())
                                        ? void 0
                                        : n.shouldGetKeyboardEvents()) ||
                                        e._keyboardManager.exec(this, t);
                                }
                                onEditingAction(e) {
                                    [
                                        "undo",
                                        "redo",
                                        "delete",
                                        "selectAll",
                                    ].includes(e.name) && this[e.name]();
                                }
                                setEditingState(e) {
                                    e
                                        ? (__privateMethod(this, Y, X).call(
                                              this
                                          ),
                                          __privateMethod(this, Z, ee).call(
                                              this
                                          ),
                                          __privateMethod(this, re, ie).call(
                                              this
                                          ),
                                          __privateMethod(this, oe, le).call(
                                              this,
                                              {
                                                  isEditing:
                                                      __privateGet(this, T) !==
                                                      _e.AnnotationEditorType
                                                          .NONE,
                                                  isEmpty: __privateMethod(
                                                      this,
                                                      xe,
                                                      ve
                                                  ).call(this),
                                                  hasSomethingToUndo:
                                                      __privateGet(
                                                          this,
                                                          y
                                                      ).hasSomethingToUndo(),
                                                  hasSomethingToRedo:
                                                      __privateGet(
                                                          this,
                                                          y
                                                      ).hasSomethingToRedo(),
                                                  hasSelectedEditor: !1,
                                              }
                                          ))
                                        : (__privateMethod(this, Q, J).call(
                                              this
                                          ),
                                          __privateMethod(this, te, ne).call(
                                              this
                                          ),
                                          __privateMethod(this, se, ae).call(
                                              this
                                          ),
                                          __privateMethod(this, oe, le).call(
                                              this,
                                              { isEditing: !1 }
                                          ),
                                          this.disableUserSelect(!1));
                                }
                                registerEditorTypes(e) {
                                    if (!__privateGet(this, w)) {
                                        __privateSet(this, w, e);
                                        for (const e of __privateGet(this, w))
                                            __privateMethod(this, ce, ue).call(
                                                this,
                                                e.defaultPropertiesToUpdate
                                            );
                                    }
                                }
                                getId() {
                                    return __privateGet(this, C).getId();
                                }
                                get currentLayer() {
                                    return __privateGet(this, x).get(
                                        __privateGet(this, _)
                                    );
                                }
                                getLayer(e) {
                                    return __privateGet(this, x).get(e);
                                }
                                get currentPageIndex() {
                                    return __privateGet(this, _);
                                }
                                addLayer(e) {
                                    __privateGet(this, x).set(e.pageIndex, e),
                                        __privateGet(this, j)
                                            ? e.enable()
                                            : e.disable();
                                }
                                removeLayer(e) {
                                    __privateGet(this, x).delete(e.pageIndex);
                                }
                                updateMode(e, t = null) {
                                    if (__privateGet(this, T) !== e) {
                                        if (
                                            (__privateSet(this, T, e),
                                            e === _e.AnnotationEditorType.NONE)
                                        )
                                            return (
                                                this.setEditingState(!1),
                                                void __privateMethod(
                                                    this,
                                                    he,
                                                    fe
                                                ).call(this)
                                            );
                                        this.setEditingState(!0),
                                            __privateMethod(this, de, pe).call(
                                                this
                                            ),
                                            this.unselectAll();
                                        for (const t of __privateGet(
                                            this,
                                            x
                                        ).values())
                                            t.updateMode(e);
                                        if (t)
                                            for (const e of __privateGet(
                                                this,
                                                g
                                            ).values())
                                                if (
                                                    e.annotationElementId === t
                                                ) {
                                                    this.setSelected(e),
                                                        e.enterInEditMode();
                                                    break;
                                                }
                                    }
                                }
                                updateToolbar(e) {
                                    e !== __privateGet(this, T) &&
                                        this._eventBus.dispatch(
                                            "switchannotationeditormode",
                                            { source: this, mode: e }
                                        );
                                }
                                updateParams(e, t) {
                                    if (__privateGet(this, w))
                                        if (
                                            e !==
                                            _e.AnnotationEditorParamsType.CREATE
                                        ) {
                                            for (const n of __privateGet(
                                                this,
                                                M
                                            ))
                                                n.updateParams(e, t);
                                            for (const n of __privateGet(
                                                this,
                                                w
                                            ))
                                                n.updateDefaultParams(e, t);
                                        } else
                                            this.currentLayer.addNewEditor(e);
                                }
                                enableWaiting(e = !1) {
                                    if (__privateGet(this, k) !== e) {
                                        __privateSet(this, k, e);
                                        for (const t of __privateGet(
                                            this,
                                            x
                                        ).values())
                                            e
                                                ? t.disableClick()
                                                : t.enableClick(),
                                                t.div.classList.toggle(
                                                    "waiting",
                                                    e
                                                );
                                    }
                                }
                                getEditors(e) {
                                    const t = [];
                                    for (const n of __privateGet(
                                        this,
                                        g
                                    ).values())
                                        n.pageIndex === e && t.push(n);
                                    return t;
                                }
                                getEditor(e) {
                                    return __privateGet(this, g).get(e);
                                }
                                addEditor(e) {
                                    __privateGet(this, g).set(e.id, e);
                                }
                                removeEditor(e) {
                                    var t;
                                    __privateGet(this, g).delete(e.id),
                                        this.unselect(e),
                                        (e.annotationElementId &&
                                            __privateGet(this, E).has(
                                                e.annotationElementId
                                            )) ||
                                            null ==
                                                (t = __privateGet(this, b)) ||
                                            t.remove(e.id);
                                }
                                addDeletedAnnotationElement(e) {
                                    __privateGet(this, E).add(
                                        e.annotationElementId
                                    ),
                                        (e.deleted = !0);
                                }
                                isDeletedAnnotationElement(e) {
                                    return __privateGet(this, E).has(e);
                                }
                                removeDeletedAnnotationElement(e) {
                                    __privateGet(this, E).delete(
                                        e.annotationElementId
                                    ),
                                        (e.deleted = !1);
                                }
                                setActiveEditor(e) {
                                    __privateGet(this, m) !== e &&
                                        (__privateSet(this, m, e),
                                        e &&
                                            __privateMethod(this, ce, ue).call(
                                                this,
                                                e.propertiesToUpdate
                                            ));
                                }
                                toggleSelected(e) {
                                    if (__privateGet(this, M).has(e))
                                        return (
                                            __privateGet(this, M).delete(e),
                                            e.unselect(),
                                            void __privateMethod(
                                                this,
                                                oe,
                                                le
                                            ).call(this, {
                                                hasSelectedEditor:
                                                    this.hasSelection,
                                            })
                                        );
                                    __privateGet(this, M).add(e),
                                        e.select(),
                                        __privateMethod(this, ce, ue).call(
                                            this,
                                            e.propertiesToUpdate
                                        ),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            { hasSelectedEditor: !0 }
                                        );
                                }
                                setSelected(e) {
                                    for (const t of __privateGet(this, M))
                                        t !== e && t.unselect();
                                    __privateGet(this, M).clear(),
                                        __privateGet(this, M).add(e),
                                        e.select(),
                                        __privateMethod(this, ce, ue).call(
                                            this,
                                            e.propertiesToUpdate
                                        ),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            { hasSelectedEditor: !0 }
                                        );
                                }
                                isSelected(e) {
                                    return __privateGet(this, M).has(e);
                                }
                                unselect(e) {
                                    e.unselect(),
                                        __privateGet(this, M).delete(e),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            {
                                                hasSelectedEditor:
                                                    this.hasSelection,
                                            }
                                        );
                                }
                                get hasSelection() {
                                    return 0 !== __privateGet(this, M).size;
                                }
                                undo() {
                                    __privateGet(this, y).undo(),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            {
                                                hasSomethingToUndo:
                                                    __privateGet(
                                                        this,
                                                        y
                                                    ).hasSomethingToUndo(),
                                                hasSomethingToRedo: !0,
                                                isEmpty: __privateMethod(
                                                    this,
                                                    xe,
                                                    ve
                                                ).call(this),
                                            }
                                        );
                                }
                                redo() {
                                    __privateGet(this, y).redo(),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            {
                                                hasSomethingToUndo: !0,
                                                hasSomethingToRedo:
                                                    __privateGet(
                                                        this,
                                                        y
                                                    ).hasSomethingToRedo(),
                                                isEmpty: __privateMethod(
                                                    this,
                                                    xe,
                                                    ve
                                                ).call(this),
                                            }
                                        );
                                }
                                addCommands(e) {
                                    __privateGet(this, y).add(e),
                                        __privateMethod(this, oe, le).call(
                                            this,
                                            {
                                                hasSomethingToUndo: !0,
                                                hasSomethingToRedo: !1,
                                                isEmpty: __privateMethod(
                                                    this,
                                                    xe,
                                                    ve
                                                ).call(this),
                                            }
                                        );
                                }
                                delete() {
                                    if (
                                        (this.commitOrRemove(),
                                        !this.hasSelection)
                                    )
                                        return;
                                    const e = [...__privateGet(this, M)];
                                    this.addCommands({
                                        cmd: () => {
                                            for (const t of e) t.remove();
                                        },
                                        undo: () => {
                                            for (const t of e)
                                                __privateMethod(
                                                    this,
                                                    me,
                                                    ge
                                                ).call(this, t);
                                        },
                                        mustExec: !0,
                                    });
                                }
                                commitOrRemove() {
                                    var e;
                                    null == (e = __privateGet(this, m)) ||
                                        e.commitOrRemove();
                                }
                                hasSomethingToControl() {
                                    return (
                                        __privateGet(this, m) ||
                                        this.hasSelection
                                    );
                                }
                                selectAll() {
                                    for (const e of __privateGet(this, M))
                                        e.commit();
                                    __privateMethod(this, be, ye).call(
                                        this,
                                        __privateGet(this, g).values()
                                    );
                                }
                                unselectAll() {
                                    if (__privateGet(this, m))
                                        __privateGet(this, m).commitOrRemove();
                                    else if (this.hasSelection) {
                                        for (const e of __privateGet(this, M))
                                            e.unselect();
                                        __privateGet(this, M).clear(),
                                            __privateMethod(this, oe, le).call(
                                                this,
                                                { hasSelectedEditor: !1 }
                                            );
                                    }
                                }
                                translateSelectedEditors(e, t, n = !1) {
                                    if (
                                        (n || this.commitOrRemove(),
                                        !this.hasSelection)
                                    )
                                        return;
                                    (__privateGet(this, V)[0] += e),
                                        (__privateGet(this, V)[1] += t);
                                    const [r, i] = __privateGet(this, V),
                                        s = [...__privateGet(this, M)];
                                    __privateGet(this, H) &&
                                        clearTimeout(__privateGet(this, H)),
                                        __privateSet(
                                            this,
                                            H,
                                            setTimeout(() => {
                                                __privateSet(this, H, null),
                                                    (__privateGet(this, V)[0] =
                                                        __privateGet(
                                                            this,
                                                            V
                                                        )[1] =
                                                            0),
                                                    this.addCommands({
                                                        cmd: () => {
                                                            for (const e of s)
                                                                __privateGet(
                                                                    this,
                                                                    g
                                                                ).has(e.id) &&
                                                                    e.translateInPage(
                                                                        r,
                                                                        i
                                                                    );
                                                        },
                                                        undo: () => {
                                                            for (const e of s)
                                                                __privateGet(
                                                                    this,
                                                                    g
                                                                ).has(e.id) &&
                                                                    e.translateInPage(
                                                                        -r,
                                                                        -i
                                                                    );
                                                        },
                                                        mustExec: !1,
                                                    });
                                            }, 1e3)
                                        );
                                    for (const a of s) a.translateInPage(e, t);
                                }
                                setUpDragSession() {
                                    if (this.hasSelection) {
                                        this.disableUserSelect(!0),
                                            __privateSet(this, S, new Map());
                                        for (const e of __privateGet(this, M))
                                            __privateGet(this, S).set(e, {
                                                savedX: e.x,
                                                savedY: e.y,
                                                savedPageIndex: e.pageIndex,
                                                newX: 0,
                                                newY: 0,
                                                newPageIndex: -1,
                                            });
                                    }
                                }
                                endDragSession() {
                                    if (!__privateGet(this, S)) return !1;
                                    this.disableUserSelect(!1);
                                    const e = __privateGet(this, S);
                                    __privateSet(this, S, null);
                                    let t = !1;
                                    for (const [
                                        { x: r, y: i, pageIndex: s },
                                        a,
                                    ] of e)
                                        (a.newX = r),
                                            (a.newY = i),
                                            (a.newPageIndex = s),
                                            t ||
                                                (t =
                                                    r !== a.savedX ||
                                                    i !== a.savedY ||
                                                    s !== a.savedPageIndex);
                                    if (!t) return !1;
                                    const n = (e, t, n, r) => {
                                        if (__privateGet(this, g).has(e.id)) {
                                            const i = __privateGet(this, x).get(
                                                r
                                            );
                                            i
                                                ? e._setParentAndPosition(
                                                                      Object.entries(e).some(
                                        ([e, t]) =>
                                            __privateGet(this, G)[e] !== t
                                    ) &&
                                        this._eventBus.dispatch(
                                            "annotationeditorstateschanged",
                                            {
                                                source: this,
                                                details: Object.assign(
                                                    __privateGet(this, G),
                                                    e
                                                ),
                                            }
                                        );
                                }),
                                (ce = new WeakSet()),
                                (ue = function (e) {
                                    this._eventBus.dispatch(
                                        "annotationeditorparamschanged",
                                        { source: this, details: e }
                                    );
                                }),
                                (de = new WeakSet()),
                                (pe = function () {
                                    if (!__privateGet(this, j)) {
                                        __privateSet(this, j, !0);
                                        for (const e of __privateGet(
                                            this,
                                            x
                                        ).values())
                                            e.enable();
                                    }
                                }),
                                (he = new WeakSet()),
                                (fe = function () {
                                    if (
                                        (this.unselectAll(),
                                        __privateGet(this, j))
                                    ) {
                                        __privateSet(this, j, !1);
                                        for (const e of __privateGet(
                                            this,
                                            x
                                        ).values())
                                            e.disable();
                                    }
                                }),
                                (me = new WeakSet()),
                                (ge = function (e) {
                                    const t = __privateGet(this, x).get(
                                        e.pageIndex
                                    );
                                    t ? t.addOrRebuild(e) : this.addEditor(e);
                                }),
                                (xe = new WeakSet()),
                                (ve = function () {
                                    if (0 === __privateGet(this, g).size)
                                        return !0;
                                    if (1 === __privateGet(this, g).size)
                                        for (const e of __privateGet(
                                            this,
                                            g
                                        ).values())
                                            return e.isEmpty();
                                    return !1;
                                }),
                                (be = new WeakSet()),
                                (ye = function (e) {
                                    __privateGet(this, M).clear();
                                    for (const t of e)
                                        t.isEmpty() ||
                                            (__privateGet(this, M).add(t),
                                            t.select());
                                    __privateMethod(this, oe, le).call(this, {
                                        hasSelectedEditor: !0,
                                    });
                                }),
                                __publicField(Pe, "TRANSLATE_SMALL", 1),
                                __publicField(Pe, "TRANSLATE_BIG", 10);
                            let Te = Pe;
                            t.AnnotationEditorUIManager = Te;
                        },
                        (e, t, n) => {
                            var r,
                                i,
                                s,
                                a,
                                o,
                                l,
                                c,
                                u,
                                d,
                                p,
                                h,
                                f,
                                m,
                                g,
                                x,
                                v,
                                b,
                                y,
                                _,
                                E,
                                S,
                                w,
                                A,
                                R,
                                C;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.StatTimer =
                                    t.RenderingCancelledException =
                                    t.PixelsPerInch =
                                    t.PageViewport =
                                    t.PDFDateString =
                                    t.DOMStandardFontDataFactory =
                                    t.DOMSVGFactory =
                                    t.DOMFilterFactory =
                                    t.DOMCanvasFactory =
                                    t.DOMCMapReaderFactory =
                                        void 0),
                                (t.deprecated = function (e) {
                                    console.log("Deprecated API usage: " + e);
                                }),
                                (t.getColorValues = function (e) {
                                    const t = document.createElement("span");
                                    (t.style.visibility = "hidden"),
                                        document.body.append(t);
                                    for (const n of e.keys()) {
                                        t.style.color = n;
                                        const r =
                                            window.getComputedStyle(t).color;
                                        e.set(n, G(r));
                                    }
                                    t.remove();
                                }),
                                (t.getCurrentTransform = function (e) {
                                    const {
                                        a: t,
                                        b: n,
                                        c: r,
                                        d: i,
                                        e: s,
                                        f: a,
                                    } = e.getTransform();
                                    return [t, n, r, i, s, a];
                                }),
                                (t.getCurrentTransformInverse = function (e) {
                                    const {
                                        a: t,
                                        b: n,
                                        c: r,
                                        d: i,
                                        e: s,
                                        f: a,
                                    } = e.getTransform().invertSelf();
                                    return [t, n, r, i, s, a];
                                }),
                                (t.getFilenameFromUrl = function (e, t = !1) {
                                    return (
                                        t || ([e] = e.split(/[#?]/, 1)),
                                        e.substring(e.lastIndexOf("/") + 1)
                                    );
                                }),
                                (t.getPdfFilenameFromUrl = function (
                                    e,
                                    t = "document.pdf"
                                ) {
                                    if ("string" != typeof e) return t;
                                    if (z(e))
                                        return (
                                            (0, k.warn)(
                                                'getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'
                                            ),
                                            t
                                        );
                                    const n = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i,
                                        r =
                                            /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/.exec(
                                                e
                                            );
                                    let i =
                                        n.exec(r[1]) ||
                                        n.exec(r[2]) ||
                                        n.exec(r[3]);
                                    if (i && ((i = i[0]), i.includes("%")))
                                        try {
                                            i = n.exec(
                                                decodeURIComponent(i)
                                            )[0];
                                        } catch {}
                                    return i || t;
                                }),
                                (t.getRGB = G),
                                (t.getXfaPageViewport = function (
                                    e,
                                    { scale: t = 1, rotation: n = 0 }
                                ) {
                                    const { width: r, height: i } =
                                            e.attributes.style,
                                        s = [0, 0, parseInt(r), parseInt(i)];
                                    return new B({
                                        viewBox: s,
                                        scale: t,
                                        rotation: n,
                                    });
                                }),
                                (t.isDataScheme = z),
                                (t.isPdfFile = function (e) {
                                    return (
                                        "string" == typeof e &&
                                        /\.pdf$/i.test(e)
                                    );
                                }),
                                (t.isValidFetchUrl = W),
                                (t.loadScript = function (e, t = !1) {
                                    return new Promise((n, r) => {
                                        const i =
                                            document.createElement("script");
                                        (i.src = e),
                                            (i.onload = function (e) {
                                                t && i.remove(), n(e);
                                            }),
                                            (i.onerror = function () {
                                                r(
                                                    new Error(
                                                        `Cannot load script at: ${i.src}`
                                                    )
                                                );
                                            }),
                                            (
                                                document.head ||
                                                document.documentElement
                                            ).append(i);
                                    });
                                }),
                                (t.noContextMenu = function (e) {
                                    e.preventDefault();
                                }),
                                (t.setLayerDimensions = function (
                                    e,
                                    t,
                                    n = !1,
                                    r = !0
                                ) {
                                    if (t instanceof B) {
                                        const { pageWidth: r, pageHeight: i } =
                                                t.rawDims,
                                            { style: s } = e,
                                            a =
                                                k.FeatureTest
                                                    .isCSSRoundSupported,
                                            o = `var(--scale-factor) * ${r}px`,
                                            l = `var(--scale-factor) * ${i}px`,
                                            c = a
                                                ? `round(${o}, 1px)`
                                                : `calc(${o})`,
                                            u = a
                                                ? `round(${l}, 1px)`
                                                : `calc(${l})`;
                                        n && t.rotation % 180 != 0
                                            ? ((s.width = u), (s.height = c))
                                            : ((s.width = c), (s.height = u));
                                    }
                                    r &&
                                        e.setAttribute(
                                            "data-main-rotation",
                                            t.rotation
                                        );
                                });
                            var j = n(7),
                                k = n(1);
                            const P = "http://www.w3.org/2000/svg",
                                T = class {};
                            __publicField(T, "CSS", 96),
                                __publicField(T, "PDF", 72),
                                __publicField(
                                    T,
                                    "PDF_TO_CSS_UNITS",
                                    T.CSS / T.PDF
                                );
                            let M,
                                $ = T;
                            t.PixelsPerInch = $;
                            class O extends j.BaseFilterFactory {
                                constructor({
                                    docId: e,
                                    ownerDocument: t = globalThis.document,
                                } = {}) {
                                    super(),
                                        __privateAdd(this, f),
                                        __privateAdd(this, g),
                                        __privateAdd(this, v),
                                        __privateAdd(this, y),
                                        __privateAdd(this, E),
                                        __privateAdd(this, w),
                                        __privateAdd(this, R),
                                        __privateAdd(this, r, void 0),
                                        __privateAdd(this, i, void 0),
                                        __privateAdd(this, s, void 0),
                                        __privateAdd(this, a, void 0),
                                        __privateAdd(this, o, void 0),
                                        __privateAdd(this, l, void 0),
                                        __privateAdd(this, c, void 0),
                                        __privateAdd(this, u, void 0),
                                        __privateAdd(this, d, void 0),
                                        __privateAdd(this, p, void 0),
                                        __privateAdd(this, h, 0),
                                        __privateSet(this, s, e),
                                        __privateSet(this, a, t);
                                }
                                addFilter(e) {
                                    if (!e) return "none";
                                    let t,
                                        n,
                                        r,
                                        i,
                                        a = __privateGet(this, f, m).get(e);
                                    if (a) return a;
                                    if (1 === e.length) {
                                        const s = e[0],
                                            a = new Array(256);
                                        for (let e = 0; e < 256; e++)
                                            a[e] = s[e] / 255;
                                        i = t = n = r = a.join(",");
                                    } else {
                                        const [s, a, o] = e,
                                            l = new Array(256),
                                            c = new Array(256),
                                            u = new Array(256);
                                        for (let e = 0; e < 256; e++)
                                            (l[e] = s[e] / 255),
                                                (c[e] = a[e] / 255),
                                                (u[e] = o[e] / 255);
                                        (t = l.join(",")),
                                            (n = c.join(",")),
                                            (r = u.join(",")),
                                            (i = `${t}${n}${r}`);
                                    }
                                    if (
                                        ((a = __privateGet(this, f, m).get(i)),
                                        a)
                                    )
                                        return (
                                            __privateGet(this, f, m).set(e, a),
                                            a
                                        );
                                    const o = `g_${__privateGet(
                                            this,
                                            s
                                        )}_transfer_map_${__privateWrapper(
                                            this,
                                            h
                                        )._++}`,
                                        l = `url(#${o})`;
                                    __privateGet(this, f, m).set(e, l),
                                        __privateGet(this, f, m).set(i, l);
                                    const c = __privateMethod(this, y, _).call(
                                        this,
                                        o
                                    );
                                    return (
                                        __privateMethod(this, w, A).call(
                                            this,
                                            t,
                                            n,
                                            r,
                                            c
                                        ),
                                        l
                                    );
                                }
                                addHCMFilter(e, t) {
                                    var n;
                                    const r = `${e}-${t}`;
                                    if (__privateGet(this, l) === r)
                                        return __privateGet(this, c);
                                    if (
                                        (__privateSet(this, l, r),
                                        __privateSet(this, c, "none"),
                                        null == (n = __privateGet(this, o)) ||
                                            n.remove(),
                                        !e || !t)
                                    )
                                        return __privateGet(this, c);
                                    const i = __privateMethod(this, R, C).call(
                                        this,
                                        e
                                    );
                                    e = k.Util.makeHexColor(...i);
                                    const a = __privateMethod(this, R, C).call(
                                        this,
                                        t
                                    );
                                    if (
                                        ((t = k.Util.makeHexColor(...a)),
                                        (__privateGet(this, g, x).style.color =
                                            ""),
                                        ("#000000" === e && "#ffffff" === t) ||
                                            e === t)
                                    )
                                        return __privateGet(this, c);
                                    const d = new Array(256);
                                    for (let s = 0; s <= 255; s++) {
                                        const e = s / 255;
                                        d[s] =
                                            e <= 0.03928
                                                ? e / 12.92
                                                : ((e + 0.055) / 1.055) ** 2.4;
                                    }
                                    const p = d.join(","),
                                        h = `g_${__privateGet(
                                            this,
                                            s
                                        )}_hcm_filter`,
                                        f = __privateSet(
                                            this,
                                            u,
                                            __privateMethod(this, y, _).call(
                                                this,
                                                h
                                            )
                                        );
                                    __privateMethod(this, w, A).call(
                                        this,
                                        p,
                                        p,
                                        p,
                                        f
                                    ),
                                        __privateMethod(this, v, b).call(
                                            this,
                                            f
                                        );
                                    const m = (e, t) => {
                                        const n = i[e] / 255,
                                            r = a[e] / 255,
                                            s = new Array(t + 1);
                                        for (let i = 0; i <= t; i++)
                                            s[i] = n + (i / t) * (r - n);
                                        return s.join(",");
                                    };
                                    return (
                                        __privateMethod(this, w, A).call(
                                            this,
                                            m(0, 5),
                                            m(1, 5),
                                            m(2, 5),
                                            f
                                        ),
                                        __privateSet(this, c, `url(#${h})`),
                                        __privateGet(this, c)
                                    );
                                }
                                addHighlightHCMFilter(e, t, n, r) {
                                    var i;
                                    const a = `${e}-${t}-${n}-${r}`;
                                    if (__privateGet(this, d) === a)
                                        return __privateGet(this, p);
                                    if (
                                        (__privateSet(this, d, a),
                                        __privateSet(this, p, "none"),
                                        null == (i = __privateGet(this, u)) ||
                                            i.remove(),
                                        !e || !t)
                                    )
                                        return __privateGet(this, p);
                                    const [o, l] = [e, t].map(
                                        __privateMethod(this, R, C).bind(this)
                                    );
                                    let c = Math.round(
                                            0.2126 * o[0] +
                                                0.7152 * o[1] +
                                                0.0722 * o[2]
                                        ),
                                        h = Math.round(
                                            0.2126 * l[0] +
                                                0.7152 * l[1] +
                                                0.0722 * l[2]
                                        ),
                                        [f, m] = [n, r].map(
                                            __privateMethod(this, R, C).bind(
                                                this
                                            )
                                        );
                                    h < c && ([c, h, f, m] = [h, c, m, f]),
                                        (__privateGet(this, g, x).style.color =
                                            "");
                                    const E = (e, t, n) => {
                                            const r = new Array(256),
                                                i = (h - c) / n,
                                                s = e / 255,
                                                a = (t - e) / (255 * n);
                                            let o = 0;
                                            for (let l = 0; l <= n; l++) {
                                                const e = Math.round(c + l * i),
                                                    t = s + l * a;
                                                for (let n = o; n <= e; n++)
                                                    r[n] = t;
                                                o = e + 1;
                                            }
                                            for (let l = o; l < 256; l++)
                                                r[l] = r[o - 1];
                                            return r.join(",");
                                        },
                                        S = `g_${__privateGet(
                                            this,
                                            s
                                        )}_hcm_highlight_filter`,
                                        j = __privateSet(
                                            this,
                                            u,
                                            __privateMethod(this, y, _).call(
                                                this,
                                                S
                                            )
                                        );
                                    return (
                                        __privateMethod(this, v, b).call(
                                            this,
                                            j
                                        ),
                                        __privateMethod(this, w, A).call(
                                            this,
                                            E(f[0], m[0], 5),
                                            E(f[1], m[1], 5),
                                            E(f[2], m[2], 5),
                                            j
                                        ),
                                        __privateSet(this, p, `url(#${S})`),
                                        __privateGet(this, p)
                                    );
                                }
                                destroy(e = !1) {
                                    (e &&
                                        (__privateGet(this, c) ||
                                            __privateGet(this, p))) ||
                                        (__privateGet(this, i) &&
                                            (__privateGet(
                                                this,
                                                i
                                            ).parentNode.parentNode.remove(),
                                            __privateSet(this, i, null)),
                                        __privateGet(this, r) &&
                                            (__privateGet(this, r).clear(),
                                            __privateSet(this, r, null)),
                                        __privateSet(this, h, 0));
                                }
                            }
                            (r = new WeakMap()),
                                (i = new WeakMap()),
                                (s = new WeakMap()),
                                (a = new WeakMap()),
                                (o = new WeakMap()),
                                (l = new WeakMap()),
                                (c = new WeakMap()),
                                (u = new WeakMap()),
                                (d = new WeakMap()),
                                (p = new WeakMap()),
                                (h = new WeakMap()),
                                (f = new WeakSet()),
                                (m = function () {
                                    return (
                                        __privateGet(this, r) ||
                                        __privateSet(this, r, new Map())
                                    );
                                }),
                                (g = new WeakSet()),
                                (x = function () {
                                    if (!__privateGet(this, i)) {
                                        const e = __privateGet(
                                                this,
                                                a
                                            ).createElement("div"),
                                            { style: t } = e;
                                        (t.visibility = "hidden"),
                                            (t.contain = "strict"),
                                            (t.width = t.height = 0),
                                            (t.position = "absolute"),
                                            (t.top = t.left = 0),
                                            (t.zIndex = -1);
                                        const n = __privateGet(
                                            this,
                                            a
                                        ).createElementNS(P, "svg");
                                        n.setAttribute("width", 0),
                                            n.setAttribute("height", 0),
                                            __privateSet(
                                                this,
                                                i,
                                                __privateGet(
                                                    this,
                                                    a
                                                ).createElementNS(P, "defs")
                                            ),
                                            e.append(n),
                                            n.append(__privateGet(this, i)),
                                            __privateGet(this, a).body.append(
                                                e
                                            );
                                    }
                                    return __privateGet(this, i);
                                }),
                                (v = new WeakSet()),
                                (b = function (e) {
                                    const t = __privateGet(
                                        this,
                                        a
                                    ).createElementNS(P, "feColorMatrix");
                                    t.setAttribute("type", "matrix"),
                                        t.setAttribute(
                                            "values",
                                            "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"
                                        ),
                                        e.append(t);
                                }),
                                (y = new WeakSet()),
                                (_ = function (e) {
                                    const t = __privateGet(
                                        this,
                                        a
                                    ).createElementNS(P, "filter");
                                    return (
                                        t.setAttribute(
                                            "color-interpolation-filters",
                                            "sRGB"
                                        ),
                                        t.setAttribute("id", e),
                                        __privateGet(this, g, x).append(t),
                                        t
                                    );
                                }),
                                (E = new WeakSet()),
                                (S = function (e, t, n) {
                                    const r = __privateGet(
                                        this,
                                        a
                                    ).createElementNS(P, t);
                                    r.setAttribute("type", "discrete"),
                                        r.setAttribute("tableValues", n),
                                        e.append(r);
                                }),
                                (w = new WeakSet()),
                                (A = function (e, t, n, r) {
                                    const i = __privateGet(
                                        this,
                                        a
                                    ).createElementNS(P, "feComponentTransfer");
                                    r.append(i),
                                        __privateMethod(this, E, S).call(
                                            this,
                                            i,
                                            "feFuncR",
                                            e
                                        ),
                                        __privateMethod(this, E, S).call(
                                            this,
                                            i,
                                            "feFuncG",
                                            t
                                        ),
                                        __privateMethod(this, E, S).call(
                                            this,
                                            i,
                                            "feFuncB",
                                            n
                                        );
                                }),
                                (R = new WeakSet()),
                                (C = function (e) {
                                    return (
                                        (__privateGet(this, g, x).style.color =
                                            e),
                                        G(
                                            getComputedStyle(
                                                __privateGet(this, g, x)
                                            ).getPropertyValue("color")
                                        )
                                    );
                                }),
                                (t.DOMFilterFactory = O);
                            class I extends j.BaseCanvasFactory {
                                constructor({
                                    ownerDocument: e = globalThis.document,
                                } = {}) {
                                    super(), (this._document = e);
                                }
                                _createCanvas(e, t) {
                                    const n =
                                        this._document.createElement("canvas");
                                    return (n.width = e), (n.height = t), n;
                                }
                            }
                            async function D(e, t = !1) {
                                if (W(e, document.baseURI)) {
                                    const n = await fetch(e);
                                    if (!n.ok) throw new Error(n.statusText);
                                    return t
                                        ? new Uint8Array(await n.arrayBuffer())
                                        : (0, k.stringToBytes)(await n.text());
                                }
                                return new Promise((n, r) => {
                                    const i = new XMLHttpRequest();
                                    i.open("GET", e, !0),
                                        t && (i.responseType = "arraybuffer"),
                                        (i.onreadystatechange = () => {
                                            if (
                                                i.readyState ===
                                                XMLHttpRequest.DONE
                                            ) {
                                                if (
                                                    200 === i.status ||
                                                    0 === i.status
                                                ) {
                                                    let e;
                                                    if (
                                                        (t && i.response
                                                            ? (e =
                                                                  new Uint8Array(
                                                                      i.response
                                                                  ))
                                                            : !t &&
                                                              i.responseText &&
                                                              (e = (0,
                                                              k.stringToBytes)(
                                                                  i.responseText
                                                              )),
                                                        e)
                                                    )
                                                        return void n(e);
                                                }
                                                r(new Error(i.statusText));
                                            }
                                        }),
                                        i.send(null);
                                });
                            }
                            t.DOMCanvasFactory = I;
                            class N extends j.BaseCMapReaderFactory {
                                _fetchData(e, t) {
                                    return D(e, this.isCompressed).then(
                                        (e) => ({
                                            cMapData: e,
                                            compressionType: t,
                                        })
                                    );
                                }
                            }
                            t.DOMCMapReaderFactory = N;
                            class F extends j.BaseStandardFontDataFactory {
                                _fetchData(e) {
                                    return D(e, !0);
                                }
                            }
                            t.DOMStandardFontDataFactory = F;
                            class L extends j.BaseSVGFactory {
                                _createSVG(e) {
                                    return document.createElementNS(P, e);
                                }
                            }
                            t.DOMSVGFactory = L;
                            class B {
                                constructor({
                                    viewBox: e,
                                    scale: t,
                                    rotation: n,
                                    offsetX: r = 0,
                                    offsetY: i = 0,
                                    dontFlip: s = !1,
                                }) {
                                    (this.viewBox = e),
                                        (this.scale = t),
                                        (this.rotation = n),
                                        (this.offsetX = r),
                                        (this.offsetY = i);
                                    const a = (e[2] + e[0]) / 2,
                                        o = (e[3] + e[1]) / 2;
                                    let l, c, u, d, p, h, f, m;
                                    switch (((n %= 360) < 0 && (n += 360), n)) {
                                        case 180:
                                            (l = -1), (c = 0), (u = 0), (d = 1);
                                            break;
                                        case 90:
                                            (l = 0), (c = 1), (u = 1), (d = 0);
                                            break;
                                        case 270:
                                            (l = 0),
                                                (c = -1),
                                                (u = -1),
                                                (d = 0);
                                            break;
                                        case 0:
                                            (l = 1), (c = 0), (u = 0), (d = -1);
                                            break;
                                        default:
                                            throw new Error(
                                                "PageViewport: Invalid rotation, must be a multiple of 90 degrees."
                                            );
                                    }
                                    s && ((u = -u), (d = -d)),
                                        0 === l
                                            ? ((p = Math.abs(o - e[1]) * t + r),
                                              (h = Math.abs(a - e[0]) * t + i),
                                              (f = (e[3] - e[1]) * t),
                                              (m = (e[2] - e[0]) * t))
                                            : ((p = Math.abs(a - e[0]) * t + r),
                                              (h = Math.abs(o - e[1]) * t + i),
                                              (f = (e[2] - e[0]) * t),
                                              (m = (e[3] - e[1]) * t)),
                                        (this.transform = [
                                            l * t,
                                            c * t,
                                            u * t,
                                            d * t,
                                            p - l * t * a - u * t * o,
                                            h - c * t * a - d * t * o,
                                        ]),
                                        (this.width = f),
                                        (this.height = m);
                                }
                                get rawDims() {
                                    const { viewBox: e } = this;
                                    return (0, k.shadow)(this, "rawDims", {
                                        pageWidth: e[2] - e[0],
                                        pageHeight: e[3] - e[1],
                                        pageX: e[0],
                                        pageY: e[1],
                                    });
                                }
                                clone({
                                    scale: e = this.scale,
                                    rotation: t = this.rotation,
                                    offsetX: n = this.offsetX,
                                    offsetY: r = this.offsetY,
                                    dontFlip: i = !1,
                                } = {}) {
                                    return new B({
                                        viewBox: this.viewBox.slice(),
                                        scale: e,
                                        rotation: t,
                                        offsetX: n,
                                        offsetY: r,
                                        dontFlip: i,
                                    });
                                }
                                convertToViewportPoint(e, t) {
                                    return k.Util.applyTransform(
                                        [e, t],
                                        this.transform
                                    );
                                }
                                convertToViewportRectangle(e) {
                                    const t = k.Util.applyTransform(
                                            [e[0], e[1]],
                                            this.transform
                                        ),
                                        n = k.Util.applyTransform(
                                            [e[2], e[3]],
                                            this.transform
                                        );
                                    return [t[0], t[1], n[0], n[1]];
                                }
                                convertToPdfPoint(e, t) {
                                    return k.Util.applyInverseTransform(
                                        [e, t],
                                        this.transform
                                    );
                                }
                            }
                            t.PageViewport = B;
                            class U extends k.BaseException {
                                constructor(e, t = 0) {
                                    super(e, "RenderingCancelledException"),
                                        (this.extraDelay = t);
                                }
                            }
                            function z(e) {
                                const t = e.length;
                                let n = 0;
                                for (; n < t && "" === e[n].trim(); ) n++;
                                return (
                                    "data:" ===
                                    e.substring(n, n + 5).toLowerCase()
                                );
                            }
                            function W(e, t) {
                                try {
                                    const { protocol: n } = t
                                        ? new URL(e, t)
                                        : new URL(e);
                                    return "http:" === n || "https:" === n;
                                } catch {
                                    return !1;
                                }
                            }
                            function G(e) {
                                if (e.startsWith("#")) {
                                    const t = parseInt(e.slice(1), 16);
                                    return [
                                        (16711680 & t) >> 16,
                                        (65280 & t) >> 8,
                                        255 & t,
                                    ];
                                }
                                return e.startsWith("rgb(")
                                    ? e
                                          .slice(4, -1)
                                          .split(",")
                                          .map((e) => parseInt(e))
                                    : e.startsWith("rgba(")
                                    ? e
                                          .slice(5, -1)
                                          .split(",")
                                          .map((e) => parseInt(e))
                                          .slice(0, 3)
                                    : ((0, k.warn)(
                                          `Not a valid color format: "${e}"`
                                      ),
                                      [0, 0, 0]);
                            }
                            (t.RenderingCancelledException = U),
                                (t.StatTimer = class {
                                    constructor() {
                                        __publicField(
                                            this,
                                            "started",
                                            Object.create(null)
                                        ),
                                            __publicField(this, "times", []);
                                    }
                                    time(e) {
                                        e in this.started &&
                                            (0, k.warn)(
                                                `Timer is already running for ${e}`
                                            ),
                                            (this.started[e] = Date.now());
                                    }
                                    timeEnd(e) {
                                        e in this.started ||
                                            (0, k.warn)(
                                                `Timer has not been started for ${e}`
                                            ),
                                            this.times.push({
                                                name: e,
                                                start: this.started[e],
                                                end: Date.now(),
                                            }),
                                            delete this.started[e];
                                    }
                                    toString() {
                                        const e = [];
                                        let t = 0;
                                        for (const { name: n } of this.times)
                                            t = Math.max(n.length, t);
                                        for (const {
                                            name: n,
                                            start: r,
                                            end: i,
                                        } of this.times)
                                            e.push(
                                                `${n.padEnd(t)} ${i - r}ms\n`
                                            );
                                        return e.join("");
                                    }
                                }),
                                (t.PDFDateString = class {
                                    static toDateObject(e) {
                                        if (!e || "string" != typeof e)
                                            return null;
                                        M ||
                                            (M = new RegExp(
                                                "^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"
                                            ));
                                        const t = M.exec(e);
                                        if (!t) return null;
                                        const n = parseInt(t[1], 10);
                                        let r = parseInt(t[2], 10);
                                        r = r >= 1 && r <= 12 ? r - 1 : 0;
                                        let i = parseInt(t[3], 10);
                                        i = i >= 1 && i <= 31 ? i : 1;
                                        let s = parseInt(t[4], 10);
                                        s = s >= 0 && s <= 23 ? s : 0;
                                        let a = parseInt(t[5], 10);
                                        a = a >= 0 && a <= 59 ? a : 0;
                                        let o = parseInt(t[6], 10);
                                        o = o >= 0 && o <= 59 ? o : 0;
                                        const l = t[7] || "Z";
                                        let c = parseInt(t[8], 10);
                                        c = c >= 0 && c <= 23 ? c : 0;
                                        let u = parseInt(t[9], 10) || 0;
                                        return (
                                            (u = u >= 0 && u <= 59 ? u : 0),
                                            "-" === l
                                                ? ((s += c), (a += u))
                                                : "+" === l &&
                                                  ((s -= c), (a -= u)),
                                            new Date(Date.UTC(n, r, i, s, a, o))
                                        );
                                    }
                                });
                        },
                        (e, t, n) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.BaseStandardFontDataFactory =
                                    t.BaseSVGFactory =
                                    t.BaseFilterFactory =
                                    t.BaseCanvasFactory =
                                    t.BaseCMapReaderFactory =
                                        void 0);
                            var r = n(1);
                            class i {
                                constructor() {
                                    this.constructor === i &&
                                        (0, r.unreachable)(
                                            "Cannot initialize BaseFilterFactory."
                                        );
                                }
                                addFilter(e) {
                                    return "none";
                                }
                                addHCMFilter(e, t) {
                                    return "none";
                                }
                                addHighlightHCMFilter(e, t, n, r) {
                                    return "none";
                                }
                                destroy(e = !1) {}
                            }
                            t.BaseFilterFactory = i;
                            class s {
                                constructor() {
                                    this.constructor === s &&
                                        (0, r.unreachable)(
                                            "Cannot initialize BaseCanvasFactory."
                                        );
                                }
                                create(e, t) {
                                    if (e <= 0 || t <= 0)
                                        throw new Error("Invalid canvas size");
                                    const n = this._createCanvas(e, t);
                                    return {
                                        canvas: n,
                                        context: n.getContext("2d"),
                                    };
                                }
                                reset(e, t, n) {
                                    if (!e.canvas)
                                        throw new Error(
                                            "Canvas is not specified"
                                        );
                                    if (t <= 0 || n <= 0)
                                        throw new Error("Invalid canvas size");
                                    (e.canvas.width = t), (e.canvas.height = n);
                                }
                                destroy(e) {
                                    if (!e.canvas)
                                        throw new Error(
                                            "Canvas is not specified"
                                        );
                                    (e.canvas.width = 0),
                                        (e.canvas.height = 0),
                                        (e.canvas = null),
                                        (e.context = null);
                                }
                                _createCanvas(e, t) {
                                    (0, r.unreachable)(
                                        "Abstract method `_createCanvas` called."
                                    );
                                }
                            }
                            t.BaseCanvasFactory = s;
                            class a {
                                constructor({
                                    baseUrl: e = null,
                                    isCompressed: t = !0,
                                }) {
                                    this.constructor === a &&
                                        (0, r.unreachable)(
                                            "Cannot initialize BaseCMapReaderFactory."
                                        ),
                                        (this.baseUrl = e),
                                        (this.isCompressed = t);
                                }
                                async fetch({ name: e }) {
                                    if (!this.baseUrl)
                                        throw new Error(
                                            'The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'
                                        );
                                    if (!e)
                                        throw new Error(
                                            "CMap name must be specified."
                                        );
                                    const t =
                                            this.baseUrl +
                                            e +
                                            (this.isCompressed ? ".bcmap" : ""),
                                        n = this.isCompressed
                                            ? r.CMapCompressionType.BINARY
                                            : r.CMapCompressionType.NONE;
                                    return this._fetchData(t, n).catch((e) => {
                                        throw new Error(
                                            `Unable to load ${
                                                this.isCompressed
                                                    ? "binary "
                                                    : ""
                                            }CMap at: ${t}`
                                        );
                                    });
                                }
                                _fetchData(e, t) {
                                    (0, r.unreachable)(
                                        "Abstract method `_fetchData` called."
                                    );
                                }
                            }
                            t.BaseCMapReaderFactory = a;
                            class o {
                                constructor({ baseUrl: e = null }) {
                                    this.constructor === o &&
                                        (0, r.unreachable)(
                                            "Cannot initialize BaseStandardFontDataFactory."
                                        ),
                                        (this.baseUrl = e);
                                }
                                async fetch({ filename: e }) {
                                    if (!this.baseUrl)
                                        throw new Error(
                                            'The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.'
                                        );
                                    if (!e)
                                        throw new Error(
                                            "Font filename must be specified."
                                        );
                                    const t = `${this.baseUrl}${e}`;
                                    return this._fetchData(t).catch((e) => {
                                        throw new Error(
                                            `Unable to load font data at: ${t}`
                                        );
                                    });
                                }
                                 r.setAttribute(
                                            "viewBox",
                                            `0 0 ${e} ${t}`
                                        ),
                                        r
                                    );
                                }
                                createElement(e) {
                                    if ("string" != typeof e)
                                        throw new Error(
                                            "Invalid SVG element type"
                                        );
                                    return this._createSVG(e);
                                }
                                _createSVG(e) {
                                    (0, r.unreachable)(
                                        "Abstract method `_createSVG` called."
                                    );
                                }
                            }
                            t.BaseSVGFactory = l;
                        },
                        (e, t, n) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.MurmurHash3_64 = void 0);
                            var r = n(1);
                            const i = 3285377520,
                                s = 4294901760,
                                a = 65535;
                            t.MurmurHash3_64 = class {
                                constructor(e) {
                                    (this.h1 = e ? 4294967295 & e : i),
                                        (this.h2 = e ? 4294967295 & e : i);
                                }
                                update(e) {
                                    let t, n;
                                    if ("string" == typeof e) {
                                        (t = new Uint8Array(2 * e.length)),
                                            (n = 0);
                                        for (
                                            let r = 0, i = e.length;
                                            r < i;
                                            r++
                                        ) {
                                            const i = e.charCodeAt(r);
                                            i <= 255
                                                ? (t[n++] = i)
                                                : ((t[n++] = i >>> 8),
                                                  (t[n++] = 255 & i));
                                        }
                                    } else {
                                        if (!(0, r.isArrayBuffer)(e))
                                            throw new Error(
                                                "Wrong data format in MurmurHash3_64_update. Input must be a string or array."
                                            );
                                        (t = e.slice()), (n = t.byteLength);
                                    }
                                    const i = n >> 2,
                                        o = n - 4 * i,
                                        l = new Uint32Array(t.buffer, 0, i);
                                    let c = 0,
                                        u = 0,
                                        d = this.h1,
                                        p = this.h2;
                                    const h = 3432918353,
                                        f = 461845907,
                                        m = 11601,
                                        g = 13715;
                                    for (let r = 0; r < i; r++)
                                        1 & r
                                            ? ((c = l[r]),
                                              (c =
                                                  ((c * h) & s) |
                                                  ((c * m) & a)),
                                              (c = (c << 15) | (c >>> 17)),
                                              (c =
                                                  ((c * f) & s) |
                                                  ((c * g) & a)),
                                              (d ^= c),
                                              (d = (d << 13) | (d >>> 19)),
                                              (d = 5 * d + 3864292196))
                                            : ((u = l[r]),
                                              (u =
                                                  ((u * h) & s) |
                                                  ((u * m) & a)),
                                              (u = (u << 15) | (u >>> 17)),
                                              (u =
                                                  ((u * f) & s) |
                                                  ((u * g) & a)),
                                              (p ^= u),
                                              (p = (p << 13) | (p >>> 19)),
                                              (p = 5 * p + 3864292196));
                                    switch (((c = 0), o)) {
                                        case 3:
                                            c ^= t[4 * i + 2] << 16;
                                        case 2:
                                            c ^= t[4 * i + 1] << 8;
                                        case 1:
                                            (c ^= t[4 * i]),
                                                (c =
                                                    ((c * h) & s) |
                                                    ((c * m) & a)),
                                                (c = (c << 15) | (c >>> 17)),
                                                (c =
                                                    ((c * f) & s) |
                                                    ((c * g) & a)),
                                                1 & i ? (d ^= c) : (p ^= c);
                                    }
                                    (this.h1 = d), (this.h2 = p);
                                }
                                hexdigest() {
                                    let e = this.h1,
                                        t = this.h2;
                                    return (
                                        (e ^= t >>> 1),
                                        (e =
                                            ((3981806797 * e) & s) |
                                            ((36045 * e) & a)),
                                        (t =
                                            ((4283543511 * t) & s) |
                                            (((2950163797 *
                                                ((t << 16) | (e >>> 16))) &
                                                s) >>>
                                                16)),
                                        (e ^= t >>> 1),
                                        (e =
                                            ((444984403 * e) & s) |
                                            ((60499 * e) & a)),
                                        (t =
                                            ((3301882366 * t) & s) |
                                            (((3120437893 *
                                                ((t << 16) | (e >>> 16))) &
                                                s) >>>
                                                16)),
                                        (e ^= t >>> 1),
                                        (e >>> 0)
                                            .toString(16)
                                            .padStart(8, "0") +
                                            (t >>> 0)
                                                .toString(16)
                                                .padStart(8, "0")
                                    );
                                }
                            };
                        },
                        (e, t, n) => {
                            var r;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.FontLoader = t.FontFaceObject = void 0);
                            var i = n(1);
                            (r = new WeakMap()),
                                (t.FontLoader = class {
                                    constructor({
                                        ownerDocument: e = globalThis.document,
                                        styleElement: t = null,
                                    }) {
                                        __privateAdd(this, r, new Set()),
                                            (this._document = e),
                                            (this.nativeFontFaces = new Set()),
                                            (this.styleElement = null),
                                            (this.loadingRequests = []),
                                            (this.loadTestFontId = 0);
                                    }
                                    addNativeFontFace(e) {
                                        this.nativeFontFaces.add(e),
                                            this._document.fonts.add(e);
                                    }
                                    removeNativeFontFace(e) {
                                        this.nativeFontFaces.delete(e),
                                            this._document.fonts.delete(e);
                                    }
                                    insertRule(e) {
                                        this.styleElement ||
                                            ((this.styleElement =
                                                this._document.createElement(
                                                    "style"
                                                )),
                                            this._document.documentElement
                                                .getElementsByTagName("head")[0]
                                                .append(this.styleElement));
                                        const t = this.styleElement.sheet;
                                        t.insertRule(e, t.cssRules.length);
                                    }
                                    clear() {
                                        for (const e of this.nativeFontFaces)
                                            this._document.fonts.delete(e);
                                        this.nativeFontFaces.clear(),
                                            __privateGet(this, r).clear(),
                                            this.styleElement &&
                                                (this.styleElement.remove(),
                                                (this.styleElement = null));
                                    }
                                    async loadSystemFont(e) {
                                        if (
                                            e &&
                                            !__privateGet(this, r).has(
                                                e.loadedName
                                            )
                                        )
                                            if (
                                                ((0, i.assert)(
                                                    !this.disableFontFace,
                                                    "loadSystemFont shouldn't be called when `disableFontFace` is set."
                                                ),
                                                this.isFontLoadingAPISupported)
                                            ) {
                                                const {
                                                        loadedName: t,
                                                        src: n,
                                                        style: s,
                                                    } = e,
                                                    a = new FontFace(t, n, s);
                                                this.addNativeFontFace(a);
                                                try {
                                                    await a.load(),
                                                        __privateGet(
                                                            this,
                                                            r
                                                        ).add(t);
                                                } catch {
                                                    (0, i.warn)(
                                                        `Cannot load system font: ${e.baseFontName}, installing it could help to improve PDF rendering.`
                                                    ),
                                                        this.removeNativeFontFace(
                                                            a
                                                        );
                                                }
                                            } else
                                                (0, i.unreachable)(
                                                    "Not implemented: loadSystemFont without the Font Loading API."
                                                );
                                    }
                                    async bind(e) {
                                        if (
                                            e.attached ||
                                            (e.missingFile && !e.systemFontInfo)
                                        )
                                            return;
                                        if (
                                            ((e.attached = !0),
                                            e.systemFontInfo)
                                        )
                                            return void (await this.loadSystemFont(
                                                e.systemFontInfo
                                            ));
                                        if (this.isFontLoadingAPISupported) {
                                            const t = e.createNativeFontFace();
                                            if (t) {
                                                this.addNativeFontFace(t);
                                                try {
                                                    await t.loaded;
                                                } catch (n) {
                                                    throw (
                                                        ((0, i.warn)(
                                                            `Failed to load font '${t.family}': '${n}'.`
                                                        ),
                                                        (e.disableFontFace =
                                                            !0),
                                                        n)
                                                    );
                                                }
                                            }
                                            return;
                                        }
                                        const t = e.createFontFaceRule();
                                        if (t) {
                                            if (
                                                (this.insertRule(t),
                                                this.isSyncFontLoadingSupported)
                                            )
                                                return;
                                            await new Promise((t) => {
                                                const n =
                                                    this._queueLoadingCallback(
                                                        t
                                                    );
                                                this._prepareFontLoadEvent(
                                                    e,
                                                    n
                                                );
                                            });
                                        }
                                    }
                                    get isFontLoadingAPISupported() {
                                        var e;
                                        const t = !!(null ==
                                        (e = this._document)
                                            ? void 0
                                            : e.fonts);
                                        return (0, i.shadow)(
                                            this,
                                            "isFontLoadingAPISupported",
                                            t
                                        );
                                    }
                                    get isSyncFontLoadingSupported() {
                                        let e = !1;
                                        return (
                                            (i.isNodeJS ||
                                                ("undefined" !=
                                                    typeof navigator &&
                                                    /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(
                                                        navigator.userAgent
                                                    ))) &&
                                                (e = !0),
                                            (0, i.shadow)(
                                                this,
                                                "isSyncFontLoadingSupported",
                                                e
                                            )
                                        );
                                    }
                                    _queueLoadingCallback(e) {
                                        const { loadingRequests: t } = this,
                                            n = {
                                                done: !1,
                                                complete: function () {
                                                    for (
                                                        (0, i.assert)(
                                                            !n.done,
                                                            "completeRequest() cannot be called twice."
                                                        ),
                                                            n.done = !0;
                                                        t.length > 0 &&
                                                        t[0].done;

                                                    ) {
                                                        const e = t.shift();
                                                        setTimeout(
                                                            e.callback,
                                                            0
                                                        );
                                                    }
                                                },
                                                callback: e,
                                            };
                                        return t.push(n), n;
                                    }
                                    get _loadTestFont() {
                                        const e = atob(
                                            "T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="
                                        );
                                        return (0, i.shadow)(
                                            this,
                                            "_loadTestFont",
                                            e
                                        );
                                    }
                                    _prepareFontLoadEvent(e, t) {
                                        function n(e, t) {
                                            return (
                                                (e.charCodeAt(t) << 24) |
                                                (e.charCodeAt(t + 1) << 16) |
                                                (e.charCodeAt(t + 2) << 8) |
                                                (255 & e.charCodeAt(t + 3))
                                            );
                                        }
                                        function r(e, t, n, r) {
                                            return (
                                                e.substring(0, t) +
                                                r +
                                                e.substring(t + n)
                                            );
                                        }
                                        let s, a;
                                        const o =
                                            this._document.createElement(
                                                "canvas"
                                            );
                                        (o.width = 1), (o.height = 1);
                                        const l = o.getContext("2d");
                                        let c = 0;
                                        const u = `lt${Date.now()}${this
                                            .loadTestFontId++}`;
                                        let d = this._loadTestFont;
                                        d = r(d, 976, u.length, u);
                                        const p = 1482184792;
                                        let h = n(d, 16);
                                        for (
                                            s = 0, a = u.length - 3;
                                            s < a;
                                            s += 4
                                        )
                                            h = (h - p + n(u, s)) | 0;
                                        s < u.length &&
                                            (h = (h - p + n(u + "XXX", s)) | 0),
                                            (d = r(
                                                d,
                                                16,
                                                4,
                                                (0, i.string32)(h)
                                            ));
                                        const f = `@font-face {font-family:"${u}";src:url(data:font/opentype;base64,${btoa(
                                            d
                                        )});}`;
                                        this.insertRule(f);
                                        const m =
                                            this._document.createElement("div");
                                        (m.style.visibility = "hidden"),
                                            (m.style.width = m.style.height =
                                                "10px"),
                                            (m.style.position = "absolute"),
                                            (m.style.top = m.style.left =
                                                "0px");
                                        for (const i of [e.loadedName, u]) {
                                            const e =
                                                this._document.createElement(
                                                    "span"
                                                );
                                            (e.textContent = "Hi"),
                                                (e.style.fontFamily = i),
                                                m.append(e);
                                        }
                                        this._document.body.append(m),
                                            (function e(t, n) {
                                                if (++c > 30)
                                                    return (
                                                        (0, i.warn)(
                                                            "Load test font never loaded."
                                                        ),
                                                        void n()
                                                    );
                                                (l.font = "30px " + t),
                                                    l.fillText(".", 0, 20),
                                                    l.getImageData(0, 0, 1, 1)
                                                        .data[3] > 0
                                                        ? n()
                                                        : setTimeout(
                                                              e.bind(null, t, n)
                                                          );
                                            })(u, () => {
                                                m.remove(), t.complete();
                                            });
                                    }
                                }),
                                (t.FontFaceObject = class {
                                    constructor(
                                        e,
                                        {
                                            isEvalSupported: t = !0,
                                            disableFontFace: n = !1,
                                            ignoreErrors: r = !1,
                                            inspectFont: i = null,
                                        }
                                    ) {
                                        this.compiledGlyphs =
                                            Object.create(null);
                                        for (const s in e) this[s] = e[s];
                                        (this.isEvalSupported = !1 !== t),
                                            (this.disableFontFace = !0 === n),
                                            (this.ignoreErrors = !0 === r),
                                            (this._inspectFont = i);
                                    }
                                    createNativeFontFace() {
                                        var e;
                                        if (!this.data || this.disableFontFace)
                                            return null;
                                        let t;
                                        if (this.cssFontInfo) {
                                            const e = {
                                                weight: this.cssFontInfo
                                                    .fontWeight,
                                            };
                                            this.cssFontInfo.italicAngle &&
                                                (e.style = `oblique ${this.cssFontInfo.italicAngle}deg`),
                                                (t = new FontFace(
                                                    this.cssFontInfo.fontFamily,
                                                    this.data,
                                                    e
                                                ));
                                        } else
                                            t = new FontFace(
                                                this.loadedName,
                                                this.data,
                                                {}
                                            );
                                        return (
                                            null == (e = this._inspectFont) ||
                                                e.call(this, this),
                                            t
                                        );
                                    }
                                    createFontFaceRule() {
                                        var e;
                                        if (!this.data || this.disableFontFace)
                                            return null;
                                        const t = (0, i.bytesToString)(
                                                this.data
                                            ),
                                            n = `url(data:${
                                                this.mimetype
                                            };base64,${btoa(t)});`;
                                        let r;
                                        if (this.cssFontInfo) {
                                            let e = `font-weight: ${this.cssFontInfo.fontWeight};`;
                                            this.cssFontInfo.italicAngle &&
                                                (e += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`),
                                                (r = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${e}src:${n}}`);
                                        } else
                                            r = `@font-face {font-family:"${this.loadedName}";src:${n}}`;
                                        return (
                                            null == (e = this._inspectFont) ||
                                                e.call(this, this, n),
                                            r
                                        );
                                    }
                                    getPathGenerator(e, t) {
                                        if (void 0 !== this.compiledGlyphs[t])
                                            return this.compiledGlyphs[t];
                                        let n;
                                        try {
                                            n = e.get(
                                                this.loadedName + "_path_" + t
                                            );
                                        } catch (r) {
                                            if (!this.ignoreErrors) throw r;
                                            return (
                                                (0, i.warn)(
                                                    `getPathGenerator - ignoring character: "${r}".`
                                                ),
                                                (this.compiledGlyphs[t] =
                                                    function (e, t) {})
                                            );
                                        }
                                        if (
                                            this.isEvalSupported &&
                                            i.FeatureTest.isEvalSupported
                                        ) {
                                            const e = [];
                                            for (const t of n) {
                                                const n =
                                                    void 0 !== t.args
                                                        ? t.args.join(",")
                                                        : "";
                                                e.push(
                                                    "c.",
                                                    t.cmd,
                                                    "(",
                                                    n,
                                                    ");\n"
                                                );
                                            }
                                            return (this.compiledGlyphs[t] =
                                                new Function(
                                                    "c",
                                                    "size",
                                                    e.join("")
                                                ));
                                        }
                                        return (this.compiledGlyphs[t] =
                                            function (e, t) {
                                                for (const r of n)
                                                    "scale" === r.cmd &&
                                                        (r.args = [t, -t]),
                                                        e[r.cmd].apply(
                                                            e,
                                                            r.args
                                                        );
                                            });
                                    }
                                });
                        },
                        (e, t, n) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.NodeStandardFontDataFactory =
                                    t.NodeFilterFactory =
                                    t.NodeCanvasFactory =
                                    t.NodeCMapReaderFactory =
                                        void 0);
                            var r = n(7);
                            n(1);
                            const i = function (e) {
                                return new Promise((t, n) => {
                                    require$$5.readFile(e, (e, r) => {
                                        !e && r
                                            ? t(new Uint8Array(r))
                                            : n(new Error(e));
                                    });
                                });
                            };
                            class s extends r.BaseFilterFactory {}
                            t.NodeFilterFactory = s;
                            class a extends r.BaseCanvasFactory {
                                _createCanvas(e, t) {
                                    return require$$5.createCanvas(e, t);
                                }
                            }
                            t.NodeCanvasFactory = a;
                            class o extends r.BaseCMapReaderFactory {
                                _fetchData(e, t) {
                                    return i(e).then((e) => ({
                                        cMapData: e,
                                        compressionType: t,
                                    }));
                                }
                            }
                            t.NodeCMapReaderFactory = o;
                            class l extends r.BaseStandardFontDataFactory {
                                _fetchData(e) {
                                    return i(e);
                                }
                            }
                            t.NodeStandardFontDataFactory = l;
                        },
                        (e, t, n) => {
                            var r, i, s, a;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.CanvasGraphics = void 0);
                            var o = n(1),
                                l = n(6),
                                c = n(12),
                                u = n(13);
                            const d = 4096,
                                p = 16;
                            class h {
                                constructor(e) {
                                    (this.canvasFactory = e),
                                        (this.cache = Object.create(null));
                                }
                                getCanvas(e, t, n) {
                                    let r;
                                    return (
                                        void 0 !== this.cache[e]
                                            ? ((r = this.cache[e]),
                                              this.canvasFactory.reset(r, t, n))
                                            : ((r = this.canvasFactory.create(
                                                  t,
                                                  n
                                              )),
                                              (this.cache[e] = r)),
                                        r
                                    );
                                }
                                delete(e) {
                                    delete this.cache[e];
                                }
                                clear() {
                                    for (const e in this.cache) {
                                        const t = this.cache[e];
                                        this.canvasFactory.destroy(t),
                                            delete this.cache[e];
                                    }
                                }
                            }
                            function f(e, t, n, r, i, s, a, o, c, u) {
                                const [d, p, h, f, m, g] = (0,
                                l.getCurrentTransform)(e);
                                if (0 === p && 0 === h) {
                                    const l = a * d + m,
                                        x = Math.round(l),
                                        v = o * f + g,
                                        b = Math.round(v),
                                        y = (a + c) * d + m,
                                        _ = Math.abs(Math.round(y) - x) || 1,
                                        E = (o + u) * f + g,
                                        S = Math.abs(Math.round(E) - b) || 1;
                                    return (
                                        e.setTransform(
                                            Math.sign(d),
                                            0,
                                            0,
                                            Math.sign(f),
                                            x,
                                            b
                                        ),
                                        e.drawImage(t, n, r, i, s, 0, 0, _, S),
                                        e.setTransform(d, p, h, f, m, g),
                                        [_, S]
                                    );
                                }
                                if (0 === d && 0 === f) {
                                    const l = o * h + m,
                                        x = Math.round(l),
                                        v = a * p + g,
                                        b = Math.round(v),
                                        y = (o + u) * h + m,
                                        _ = Math.abs(Math.round(y) - x) || 1,
                                        E = (a + c) * p + g,
                                        S = Math.abs(Math.round(E) - b) || 1;
                                    return (
                                        e.setTransform(
                                            0,
                                            Math.sign(p),
                                            Math.sign(h),
                                            0,
                                            x,
                                            b
                                        ),
                                        e.drawImage(t, n, r, i, s, 0, 0, S, _),
                                        e.setTransform(d, p, h, f, m, g),
                                        [S, _]
                                    );
                                }
                                return (
                                    e.drawImage(t, n, r, i, s, a, o, c, u),
                                    [Math.hypot(d, p) * c, Math.hypot(h, f) * u]
                                );
                            }
                            class m {
                                constructor(e, t) {
                                    (this.alphaIsShape = !1),
                                        (this.fontSize = 0),
                                        (this.fontSizeScale = 1),
                                        (this.textMatrix = o.IDENTITY_MATRIX),
                                        (this.textMatrixScale = 1),
                                        (this.fontMatrix =
                                            o.FONT_IDENTITY_MATRIX),
                                        (this.leading = 0),
                                        (this.x = 0),
                                        (this.y = 0),
                                        (this.lineX = 0),
                                        (this.lineY = 0),
                                        (this.charSpacing = 0),
                                        (this.wordSpacing = 0),
                                        (this.textHScale = 1),
                                        (this.textRenderingMode =
                                            o.TextRenderingMode.FILL),
                                        (this.textRise = 0),
                                        (this.fillColor = "#000000"),
                                        (this.strokeColor = "#000000"),
                                        (this.patternFill = !1),
                                        (this.fillAlpha = 1),
                                        (this.strokeAlpha = 1),
                                        (this.lineWidth = 1),
                                        (this.activeSMask = null),
                                        (this.transferMaps = "none"),
                                        this.startNewPathAndClipBox([
                                            0,
                                            0,
                                            e,
                                            t,
                                        ]);
                                }
                                clone() {
                                    const e = Object.create(this);
                                    return (
                                        (e.clipBox = this.clipBox.slice()), e
                                    );
                                }
                                setCurrentPoint(e, t) {
                                    (this.x = e), (this.y = t);
                                }
                                updatePathMinMax(e, t, n) {
                                    ([t, n] = o.Util.applyTransform([t, n], e)),
                                        (this.minX = Math.min(this.minX, t)),
                                        (this.minY = Math.min(this.minY, n)),
                                        (this.maxX = Math.max(this.maxX, t)),
                                        (this.maxY = Math.max(this.maxY, n));
                                }
                                updateRectMinMax(e, t) {
                                    const n = o.Util.applyTransform(t, e),
                                        r = o.Util.applyTransform(
                                            t.slice(2),
                                            e
                                        );
                                    (this.minX = Math.min(
                                        this.minX,
                                        n[0],
                                        r[0]
                                    )),
                                        (this.minY = Math.min(
                                            this.minY,
                                            n[1],
                                            r[1]
                                        )),
                                        (this.maxX = Math.max(
                                            this.maxX,
                                            n[0],
                                            r[0]
                                        )),
                                        (this.maxY = Math.max(
                                            this.maxY,
                                            n[1],
                                            r[1]
                                        ));
                                }
                                updateScalingPathMinMax(e, t) {
                                    o.Util.scaleMinMax(e, t),
                                        (this.minX = Math.min(this.minX, t[0])),
                                        (this.maxX = Math.max(this.maxX, t[1])),
                                        (this.minY = Math.min(this.minY, t[2])),
                                        (this.maxY = Math.max(this.maxY, t[3]));
                                }
                                updateCurvePathMinMax(
                                    e,
                                    t,
                                    n,
                                    r,
                                    i,
                                    s,
                                    a,
                                    l,
                                    c,
                                    u
                                ) {
                                    const d = o.Util.bezierBoundingBox(
                                        t,
                                        n,
                                        r,
                                        i,
                                        s,
                                        a,
                                        l,
                                        c
                                    );
                                    if (u)
                                        return (
                                            (u[0] = Math.min(u[0], d[0], d[2])),
                                            (u[1] = Math.max(u[1], d[0], d[2])),
                                            (u[2] = Math.min(u[2], d[1], d[3])),
                                            void (u[3] = Math.max(
                                                u[3],
                                                d[1],
                                                d[3]
                                            ))
                                        );
                                    this.updateRectMinMax(e, d);
                                }
                                getPathBoundingBox(
                                    e = c.PathType.FILL,
                                    t = null
                                ) {
                                    const n = [
                                        this.minX,
                                        this.minY,
                                        this.maxX,
                                        this.maxY,
                                    ];
                                    if (e === c.PathType.STROKE) {
                                        t ||
                                            (0, o.unreachable)(
                                                "Stroke bounding box must include transform."
                                            );
                                        const e =
                                                o.Util.singularValueDecompose2dScale(
                                                    t
                                                ),
                                            r = (e[0] * this.lineWidth) / 2,
                                            i = (e[1] * this.lineWidth) / 2;
                                        (n[0] -= r),
                                            (n[1] -= i),
                                            (n[2] += r),
                                            (n[3] += i);
                                    }
                                    return n;
                                }
                                updateClipFromPath() {
                                    const e = o.Util.intersect(
                                        this.clipBox,
                                        this.getPathBoundingBox()
                                    );
                                    this.startNewPathAndClipBox(
                                        e || [0, 0, 0, 0]
                                    );
                                }
                                isEmptyClip() {
                                    return this.minX === 1 / 0;
                                }
                                startNewPathAndClipBox(e) {
                                    (this.clipBox = e),
                                        (this.minX = 1 / 0),
                                        (this.minY = 1 / 0),
                                        (this.maxX = 0),
                                        (this.maxY = 0);
                                }
                                getClippedPathBoundingBox(
                                    e = c.PathType.FILL,
                                    t = null
                                ) {
                                    return o.Util.intersect(
                                        this.clipBox,
                                        this.getPathBoundingBox(e, t)
                                    );
                                }
                            }
                            function g(e, t) {
                                if (
                                    "undefined" != typeof ImageData &&
                                    t instanceof ImageData
                                )
                                    return void e.putImageData(t, 0, 0);
                                const n = t.height,
                                    r = t.width,
                                    i = n % p,
                                    s = (n - i) / p,
                                    a = 0 === i ? s : s + 1,
                                    l = e.createImageData(r, p);
                                let c,
                                    u = 0;
                                const d = t.data,
                                    h = l.data;
                                let f, m, g, x;
                                if (t.kind === o.ImageKind.GRAYSCALE_1BPP) {
                                    const t = d.byteLength,
                                        n = new Uint32Array(
                                            h.buffer,
                                            0,
                                            h.byteLength >> 2
                                        ),
                                        x = n.length,
                                        v = (r + 7) >> 3,
                                        b = 4294967295,
                                        y = o.FeatureTest.isLittleEndian
                                            ? 4278190080
                                            : 255;
                                    for (f = 0; f < a; f++) {
                                        for (
                                            g = f < s ? p : i, c = 0, m = 0;
                                            m < g;
                                            m++
                                        ) {
                                            const e = t - u;
                                            let i = 0;
                                            const s = e > v ? r : 8 * e - 7,
                                                a = -8 & s;
                                            let o = 0,
                                                l = 0;
                                            for (; i < a; i += 8)
                                                (l = d[u++]),
                                                    (n[c++] = 128 & l ? b : y),
                                                    (n[c++] = 64 & l ? b : y),
                                                    (n[c++] = 32 & l ? b : y),
                                                    (n[c++] = 16 & l ? b : y),
                                                    (n[c++] = 8 & l ? b : y),
                                                    (n[c++] = 4 & l ? b : y),
                                                    (n[c++] = 2 & l ? b : y),
                                                    (n[c++] = 1 & l ? b : y);
                                            for (; i < s; i++)
                                                0 === o &&
                                                    ((l = d[u++]), (o = 128)),
                                                    (n[c++] = l & o ? b : y),
                                                    (o >>= 1);
                                        }
                                        for (; c < x; ) n[c++] = 0;
                                        e.putImageData(l, 0, f * p);
                                    }
                                } else if (t.kind === o.ImageKind.RGBA_32BPP) {
                                    for (
                                        m = 0, x = r * p * 4, f = 0;
                                        f < s;
                                        f++
                                    )
                                        h.set(d.subarray(u, u + x)),
                                            (u += x),
                                            e.putImageData(l, 0, m),
                                            (m += p);
                                    f < a &&
                                        ((x = r * i * 4),
                                        h.set(d.subarray(u, u + x)),
                                        e.putImageData(l, 0, m));
                                } else {
                                    if (t.kind !== o.ImageKind.RGB_24BPP)
                                        throw new Error(
                                            `bad image kind: ${t.kind}`
                                        );
                                    for (g = p, x = r * g, f = 0; f < a; f++) {
                                        for (
                                            f >= s && ((g = i), (x = r * g)),
                                                c = 0,
                                                m = x;
                                            m--;

                                        )
                                            (h[c++] = d[u++]),
                                                (h[c++] = d[u++]),
                                                (h[c++] = d[u++]),
                                                (h[c++] = 255);
                                        e.putImageData(l, 0, f * p);
                                    }
                                }
                            }
                            function x(e, t) {
                                if (t.bitmap)
                                    return void e.drawImage(t.bitmap, 0, 0);
                                const n = t.height,
                                    r = t.width,
                                    i = n % p,
                                    s = (n - i) / p,
                                    a = 0 === i ? s : s + 1,
                                    o = e.createImageData(r, p);
                                let l = 0;
                                const c = t.data,
                                    d = o.data;
                                for (let h = 0; h < a; h++) {
                                    const t = h < s ? p : i;
                                    ({ srcPos: l } = (0,
                                    u.convertBlackAndWhiteToRGBA)({
                                        src: c,
                                        srcPos: l,
                                        dest: d,
                                        width: r,
                                        height: t,
                                        nonBlackColor: 0,
                                    })),
                                        e.putImageData(o, 0, h * p);
                                }
                            }
                            function v(e, t) {
                                const n = [
                                    "strokeStyle",
                                    "fillStyle",
                                    "fillRule",
                                    "globalAlpha",
                                    "lineWidth",
                                    "lineCap",
                                    "lineJoin",
                                    "miterLimit",
                                    "globalCompositeOperation",
                                    "font",
                                    "filter",
                                ];
                                for (const r of n)
                                    void 0 !== e[r] && (t[r] = e[r]);
                                void 0 !== e.setLineDash &&
                                    (t.setLineDash(e.getLineDash()),
                                    (t.lineDashOffset = e.lineDashOffset));
                            }
                            function b(e) {
                                if (
                                    ((e.strokeStyle = e.fillStyle = "#000000"),
                                    (e.fillRule = "nonzero"),
                                    (e.globalAlpha = 1),
                                    (e.lineWidth = 1),
                                    (e.lineCap = "butt"),
                                    (e.lineJoin = "miter"),
                                    (e.miterLimit = 10),
                                    (e.globalCompositeOperation =
                                        "source-over"),
                                    (e.font = "10px sans-serif"),
                                    void 0 !== e.setLineDash &&
                                        (e.setLineDash([]),
                                        (e.lineDashOffset = 0)),
                                    !o.isNodeJS)
                                ) {
                                    const { filter: t } = e;
                                    "none" !== t &&
                                        "" !== t &&
                                        (e.filter = "none");
                                }
                            }
                            function y(e, t, n, r) {
                                const i = e.length;
                                for (let s = 3; s < i; s += 4) {
                                    const i = e[s];
                                    if (0 === i)
                                        (e[s - 3] = t),
                                            (e[s - 2] = n),
                                            (e[s - 1] = r);
                                    else if (i < 255) {
                                        const a = 255 - i;
                                        (e[s - 3] =
                                            (e[s - 3] * i + t * a) >> 8),
                                            (e[s - 2] =
                                                (e[s - 2] * i + n * a) >> 8),
                                            (e[s - 1] =
                                                (e[s - 1] * i + r * a) >> 8);
                                    }
                                }
                            }
                            function _(e, t, n) {
                                const r = e.length,
                                    i = 1 / 255;
                                for (let s = 3; s < r; s += 4) {
                                    const r = n ? n[e[s]] : e[s];
                                    t[s] = (t[s] * r * i) | 0;
                                }
                            }
                            function E(e, t, n) {
                                const r = e.length;
                                for (let i = 3; i < r; i += 4) {
                                    const r =
                                        77 * e[i - 3] +
                                        152 * e[i - 2] +
                                        28 * e[i - 1];
                                    t[i] = n
                                        ? (t[i] * n[r >> 8]) >> 8
                                        : (t[i] * r) >> 16;
                                }
                            }
                            function S(e, t, n, r) {
                                const i = r[0],
                                    s = r[1],
                                    a = r[2] - i,
                                    o = r[3] - s;
                                0 !== a &&
                                    0 !== o &&
                                    ((function (
                                        e,
                                        t,
                                        n,
                                        r,
                                        i,
                                        s,
                                        a,
                                        o,
                                        l,
                                        c,
                                        u
                                    ) {
                                        const d = !!s,
                                            p = d ? s[0] : 0,
                                            h = d ? s[1] : 0,
                                            f = d ? s[2] : 0,
                                            m = "Luminosity" === i ? E : _,
                                            g = Math.min(
                                                r,
                                                Mat                                                x + (l - u),
                                                    n,
                                                    i
                                                ),
                                                v = t.getImageData(
                                                    o,
                                                    x + l,
                                                    n,
                                                    i
                                                );
                                            d && y(s.data, p, h, f),
                                                m(s.data, v.data, a),
                                                t.putImageData(v, o, x + l);
                                        }
                                    })(
                                        t.context,
                                        n,
                                        a,
                                        o,
                                        t.subtype,
                                        t.backdrop,
                                        t.transferMap,
                                        i,
                                        s,
                                        t.offsetX,
                                        t.offsetY
                                    ),
                                    e.save(),
                                    (e.globalAlpha = 1),
                                    (e.globalCompositeOperation =
                                        "source-over"),
                                    e.setTransform(1, 0, 0, 1, 0, 0),
                                    e.drawImage(n.canvas, 0, 0),
                                    e.restore());
                            }
                            function w(e, t) {
                                const n =
                                    o.Util.singularValueDecompose2dScale(e);
                                (n[0] = Math.fround(n[0])),
                                    (n[1] = Math.fround(n[1]));
                                const r = Math.fround(
                                    (globalThis.devicePixelRatio || 1) *
                                        l.PixelsPerInch.PDF_TO_CSS_UNITS
                                );
                                return void 0 !== t
                                    ? t
                                    : n[0] <= r || n[1] <= r;
                            }
                            const A = ["butt", "round", "square"],
                                R = ["miter", "round", "bevel"],
                                C = {},
                                j = {};
                            (r = new WeakSet()),
                                (i = function () {
                                    for (
                                        ;
                                        this.stateStack.length ||
                                        this.inSMaskMode;

                                    )
                                        this.restore();
                                    this.ctx.restore(),
                                        this.transparentCanvas &&
                                            ((this.ctx = this.compositeCtx),
                                            this.ctx.save(),
                                            this.ctx.setTransform(
                                                1,
                                                0,
                                                0,
                                                1,
                                                0,
                                                0
                                            ),
                                            this.ctx.drawImage(
                                                this.transparentCanvas,
                                                0,
                                                0
                                            ),
                                            this.ctx.restore(),
                                            (this.transparentCanvas = null));
                                }),
                                (s = new WeakSet()),
                                (a = function () {
                                    if (this.pageColors) {
                                        const e =
                                            this.filterFactory.addHCMFilter(
                                                this.pageColors.foreground,
                                                this.pageColors.background
                                            );
                                        if ("none" !== e) {
                                            const t = this.ctx.filter;
                                            (this.ctx.filter = e),
                                                this.ctx.drawImage(
                                                    this.ctx.canvas,
                                                    0,
                                                    0
                                                ),
                                                (this.ctx.filter = t);
                                        }
                                    }
                                });
                            let k = class e {
                                constructor(
                                    e,
                                    t,
                                    n,
                                    i,
                                    a,
                                    {
                                        optionalContentConfig: o,
                                        markedContentStack: l = null,
                                    },
                                    c,
                                    u
                                ) {
                                    __privateAdd(this, r),
                                        __privateAdd(this, s),
                                        (this.ctx = e),
                                        (this.current = new m(
                                            this.ctx.canvas.width,
                                            this.ctx.canvas.height
                                        )),
                                        (this.stateStack = []),
                                        (this.pendingClip = null),
                                        (this.pendingEOFill = !1),
                                        (this.res = null),
                                        (this.xobjs = null),
                                        (this.commonObjs = t),
                                        (this.objs = n),
                                        (this.canvasFactory = i),
                                        (this.filterFactory = a),
                                        (this.groupStack = []),
                                        (this.processingType3 = null),
                                        (this.baseTransform = null),
                                        (this.baseTransformStack = []),
                                        (this.groupLevel = 0),
                                        (this.smaskStack = []),
                                        (this.smaskCounter = 0),
                                        (this.tempSMask = null),
                                        (this.suspendedCtx = null),
                                        (this.contentVisible = !0),
                                        (this.markedContentStack = l || []),
                                        (this.optionalContentConfig = o),
                                        (this.cachedCanvases = new h(
                                            this.canvasFactory
                                        )),
                                        (this.cachedPatterns = new Map()),
                                        (this.annotationCanvasMap = c),
                                        (this.viewportScale = 1),
                                        (this.outputScaleX = 1),
                                        (this.outputScaleY = 1),
                                        (this.pageColors = u),
                                        (this._cachedScaleForStroking = [
                                            -1, 0,
                                        ]),
                                        (this._cachedGetSinglePixelWidth =
                                            null),
                                        (this._cachedBitmapsMap = new Map());
                                }
                                getObject(e, t = null) {
                                    return "string" == typeof e
                                        ? e.startsWith("g_")
                                            ? this.commonObjs.get(e)
                                            : this.objs.get(e)
                                        : t;
                                }
                                beginDrawing({
                                    transform: e,
                                    viewport: t,
                                    transparency: n = !1,
                                    background: r = null,
                                }) {
                                    const i = this.ctx.canvas.width,
                                        s = this.ctx.canvas.height,
                                        a = this.ctx.fillStyle;
                                    if (
                                        ((this.ctx.fillStyle = r || "#ffffff"),
                                        this.ctx.fillRect(0, 0, i, s),
                                        (this.ctx.fillStyle = a),
                                        n)
                                    ) {
                                        const e = this.cachedCanvases.getCanvas(
                                            "transparent",
                                            i,
                                            s
                                        );
                                        (this.compositeCtx = this.ctx),
                                            (this.transparentCanvas = e.canvas),
                                            (this.ctx = e.context),
                                            this.ctx.save(),
                                            this.ctx.transform(
                                                ...(0, l.getCurrentTransform)(
                                                    this.compositeCtx
                                                )
                                            );
                                    }
                                    this.ctx.save(),
                                        b(this.ctx),
                                        e &&
                                            (this.ctx.transform(...e),
                                            (this.outputScaleX = e[0]),
                                            (this.outputScaleY = e[0])),
                                        this.ctx.transform(...t.transform),
                                        (this.viewportScale = t.scale),
                                        (this.baseTransform = (0,
                                        l.getCurrentTransform)(this.ctx));
                                }
                                executeOperatorList(e, t, n, r) {
                                    const i = e.argsArray,
                                        s = e.fnArray;
                                    let a = t || 0;
                                    const l = i.length;
                                    if (l === a) return a;
                                    const c =
                                            l - a > 10 &&
                                            "function" == typeof n,
                                        u = c ? Date.now() + 15 : 0;
                                    let d = 0;
                                    const p = this.commonObjs,
                                        h = this.objs;
                                    let f;
                                    for (;;) {
                                        if (
                                            void 0 !== r &&
                                            a === r.nextBreakPoint
                                        )
                                            return r.breakIt(a, n), a;
                                        if (
                                            ((f = s[a]), f !== o.OPS.dependency)
                                        )
                                            this[f].apply(this, i[a]);
                                        else
                                            for (const e of i[a]) {
                                                const t = e.startsWith("g_")
                                                    ? p
                                                    : h;
                                                if (!t.has(e))
                                                    return t.get(e, n), a;
                                            }
                                        if ((a++, a === l)) return a;
                                        if (c && ++d > 10) {
                                            if (Date.now() > u) return n(), a;
                                            d = 0;
                                        }
                                    }
                                }
                                endDrawing() {
                                    __privateMethod(this, r, i).call(this),
                                        this.cachedCanvases.clear(),
                                        this.cachedPatterns.clear();
                                    for (const e of this._cachedBitmapsMap.values()) {
                                        for (const t of e.values())
                                            "undefined" !=
                                                typeof HTMLCanvasElement &&
                                                t instanceof
                                                    HTMLCanvasElement &&
                                                (t.width = t.height = 0);
                                        e.clear();
                                    }
                                    this._cachedBitmapsMap.clear(),
                                        __privateMethod(this, s, a).call(this);
                                }
                                _scaleImage(e, t) {
                                    const n = e.width,
                                        r = e.height;
                                    let i,
                                        s,
                                        a = Math.max(Math.hypot(t[0], t[1]), 1),
                                        o = Math.max(Math.hypot(t[2], t[3]), 1),
                                        l = n,
                                        c = r,
                                        u = "prescale1";
                                    for (
                                        ;
                                        (a > 2 && l > 1) || (o > 2 && c > 1);

                                    ) {
                                        let t = l,
                                            n = c;
                                        a > 2 &&
                                            l > 1 &&
                                            ((t =
                                                l >= 16384
                                                    ? Math.floor(l / 2) - 1 || 1
                                                    : Math.ceil(l / 2)),
                                            (a /= l / t)),
                                            o > 2 &&
                                                c > 1 &&
                                                ((n =
                                                    c >= 16384
                                                        ? Math.floor(c / 2) -
                                                              1 || 1
                                                        : Math.ceil(c) / 2),
                                                (o /= c / n)),
                                            (i = this.cachedCanvases.getCanvas(
                                                u,
                                                t,
                                                n
                                            )),
                                            (s = i.context),
                                            s.clearRect(0, 0, t, n),
                                            s.drawImage(
                                                e,
                                                0,
                                                0,
                                                l,
                                                c,
                                                0,
                                                0,
                                                t,
                                                n
                                            ),
                                            (e = i.canvas),
                                            (l = t),
                                            (c = n),
                                            (u =
                                                "prescale1" === u
                                                    ? "prescale2"
                                                    : "prescale1");
                                    }
                                    return {
                                        img: e,
                                        paintWidth: l,
                                        paintHeight: c,
                                    };
                                }
                                _createMaskCanvas(e) {
                                    const t = this.ctx,
                                        { width: n, height: r } = e,
                                        i = this.current.fillColor,
                                        s = this.current.patternFill,
                                        a = (0, l.getCurrentTransform)(t);
                                    let u, d, p, h;
                                    if ((e.bitmap || e.data) && e.count > 1) {
                                        const t = e.bitmap || e.data.buffer;
                                        (d = JSON.stringify(
                                            s ? a : [a.slice(0, 4), i]
                                        )),
                                            (u = this._cachedBitmapsMap.get(t)),
                                            u ||
                                                ((u = new Map()),
                                                this._cachedBitmapsMap.set(
                                                    t,
                                                    u
                                                ));
                                        const n = u.get(d);
                                        if (n && !s)
                                            return {
                                                canvas: n,
                                                offsetX: Math.round(
                                                    Math.min(a[0], a[2]) + a[4]
                                                ),
                                                offsetY: Math.round(
                                                    Math.min(a[1], a[3]) + a[5]
                                                ),
                                            };
                                        p = n;
                                    }
                                    p ||
                                        ((h = this.cachedCanvases.getCanvas(
                                            "maskCanvas",
                                            n,
                                            r
                                        )),
                                        x(h.context, e));
                                    let m = o.Util.transform(a, [
                                        1 / n,
                                        0,
                                        0,
                                        -1 / r,
                                        0,
                                        0,
                                    ]);
                                    m = o.Util.transform(m, [
                                        1,
                                        0,
                                        0,
                                        1,
                                        0,
                                        -r,
                                    ]);
                                    const g = o.Util.applyTransform([0, 0], m),
                                        v = o.Util.applyTransform([n, r], m),
                                        b = o.Util.normalizeRect([
                                            g[0],
                                            g[1],
                                            v[0],
                                            v[1],
                                        ]),
                                        y = Math.round(b[2] - b[0]) || 1,
                                        _ = Math.round(b[3] - b[1]) || 1,
                                        E = this.cachedCanvases.getCanvas(
                                            "fillCanvas",
                                            y,
                                            _
                                        ),
                                        S = E.context,
                                        A = Math.min(g[0], v[0]),
                                        R = Math.min(g[1], v[1]);
                                    S.translate(-A, -R),
                                        S.transform(...m),
                                        p ||
                                            ((p = this._scaleImage(
                                                h.canvas,
                                                (0,
                                                l.getCurrentTransformInverse)(S)
                                            )),
                                            (p = p.img),
                                            u && s && u.set(d, p)),
                                        (S.imageSmoothingEnabled = w(
                                            (0, l.getCurrentTransform)(S),
                                            e.interpolate
                                        )),
                                        f(
                                            S,
                                            p,
                                            0,
                                            0,
                                            p.width,
                                            p.height,
                                            0,
                                            0,
                                            n,
                                            r
                                        ),
                                        (S.globalCompositeOperation =
                                            "source-in");
                                    const C = o.Util.transform(
                                        (0, l.getCurrentTransformInverse)(S),
                                        [1, 0, 0, 1, -A, -R]
                                    );
                                    return (
                                        (S.fillStyle = s
                                            ? i.getPattern(
                                                  t,
                                                  this,
                                                  C,
                                                  c.PathType.FILL
                                              )
                                            : i),
                                        S.fillRect(0, 0, n, r),
                                        u &&
                                            !s &&
                                            (this.cachedCanvases.delete(
                                                "fillCanvas"
                                            ),
                                            u.set(d, E.canvas)),
                                        {
                                            canvas: E.canvas,
                                            offsetX: Math.round(A),
                                            offsetY: Math.round(R),
                                        }
                                    );
                                }
                                setLineWidth(e) {
                                    e !== this.current.lineWidth &&
                                        (this._cachedScaleForStroking[0] = -1),
                                        (this.current.lineWidth = e),
                                        (this.ctx.lineWidth = e);
                                }
                                setLineCap(e) {
                                    this.ctx.lineCap = A[e];
                                }
                                setLineJoin(e) {
                                    this.ctx.lineJoin = R[e];
                                }
                                setMiterLimit(e) {
                                    this.ctx.miterLimit = e;
                                }
                                setDash(e, t) {
                                    const n = this.ctx;
                                    void 0 !== n.setLineDash &&
                                        (n.setLineDash(e),
                                        (n.lineDashOffset = t));
                                }
                                setRenderingIntent(e) {}
                                setFlatness(e) {}
                                setGState(e) {
                                    for (const [t, n] of e)
                                        switch (t) {
                                            case "LW":
                                                this.setLineWidth(n);
                                                break;
                                            case "LC":
                                                this.setLineCap(n);
                                                break;
                                            case "LJ":
                                                this.setLineJoin(n);
                                                break;
                                            case "ML":
                                                this.setMiterLimit(n);
                                                break;
                                            case "D":
                                                this.setDash(n[0], n[1]);
                                                break;
                                            case "RI":
                                                this.setRenderingIntent(n);
                                                break;
                                            case "FL":
                                                this.setFlatness(n);
                                                break;
                                            case "Font":
                                                this.setFont(n[0], n[1]);
                                                break;
                                            case "CA":
                                                this.current.strokeAlpha = n;
                                                break;
                                            case "ca":
                                                (this.current.fillAlpha = n),
                                                    (this.ctx.globalAlpha = n);
                                                break;
                                            case "BM":
                                                this.ctx.globalCompositeOperation =
                                                    n;
                                                break;
                                            case "SMask":
                                                (this.current.activeSMask = n
                                                    ? this.tempSMask
                                                    : null),
                                                    (this.tempSMask = null),
                                                    this.checkSMaskState();
                                                break;
                                            case "TR":
                                                this.ctx.filter =
                                                    this.current.transferMaps =
                                                        this.filterFactory.addFilter(
                                                            n
                                                        );
                                        }
                                }
                                get inSMaskMode() {
                                    return !!this.suspendedCtx;
                                }
                                checkSMaskState() {
                                    const e = this.inSMaskMode;
                                    this.current.activeSMask && !e
                                        ? this.beginSMaskMode()
                                        : !this.current.activeSMask &&
                                          e &&
                                          this.endSMaskMode();
                                }
                                beginSMaskMode() {
                                    if (this.inSMaskMode)
                                        throw new Error(
                                            "beginSMaskMode called while already in smask mode"
                                        );
                                    const e = this.ctx.canvas.width,
                                        t = this.ctx.canvas.height,
                                        n = "smaskGroupAt" + this.groupLevel,
                                        r = this.cachedCanvases.getCanvas(
                                            n,
                                            e,
                                            t
                                        );
                                    (this.suspendedCtx = this.ctx),
                                        (this.ctx = r.context);
                                    const i = this.ctx;
                                    i.setTransform(
                                        ...(0, l.getCurrentTransform)(
                                            this.suspendedCtx
                                        )
                                    ),
                                        v(this.suspendedCtx, i),
                                        (function (e, t) {
                                            if (e._removeMirroring)
                                                throw new Error(
                                                    "Context is already forwarding operations."
                                                );
                                            (e.__originalSave = e.save),
                                                (e.__originalRestore =
                                                    e.restore),
                                                (e.__originalRotate = e.rotate),
                                                (e.__originalScale = e.scale),
                                                (e.__originalTranslate =
                                                    e.translate),
                                                (e.__originalTransform =
                                                    e.transform),
                                                (e.__originalSetTransform =
                                                    e.setTransform),
                                                (e.__originalResetTransform =
                                                    e.resetTransform),
                                                (e.__originalClip = e.clip),
                                                (e.__originalMoveTo = e.moveTo),
                                                (e.__originalLineTo = e.lineTo),
                                                (e.__originalBezierCurveTo =
                                                    e.bezierCurveTo),
                                                (e.__originalRect = e.rect),
                                                (e.__originalClosePath =
                                                    e.closePath),
                                                (e.__originalBeginPath =
                                                    e.beginPath),
                                                (e._removeMirroring = () => {
                                                    (e.save = e.__originalSave),
                                                        (e.restore =
                                                            e.__originalRestore),
                                                        (e.rotate =
                                                            e.__originalRotate),
                                                        (e.scale =
                                                            e.__originalScale),
                                                        (e.translate =
                                                            e.__originalTranslate),
                                                        (e.transform =
                                                            e.__originalTransform),
                                                        (e.setTransform =
                                                            e.__originalSetTransform),
                                                        (e.resetTransform =
                                                            e.__originalResetTransform),
                                                        (e.clip =
                                                            e.__originalClip),
                                                        (e.moveTo =
                                                            e.__originalMoveTo),
                                                        (e.lineTo =
                                                            e.__originalLineTo),
                                                        (e.bezierCurveTo =
                                                            e.__originalBezierCurveTo),
                                                        (e.rect =
                                                            e.__originalRect),
                                                        (e.closePath =
                                                            e.__originalClosePath),
                                                        (e.beginPath =
                                                            e.__originalBeginPath),
                                                        delete e._removeMirroring;
                                                }),
                                                (e.save = function () {
                                                    t.save(),
                                                        this.__originalSave();
                                                }),
                                                (e.restore = function () {
                                                    t.restore(),
                                                        this.__originalRestore();
                                                }),
                                                (e.translate = function (e, n) {
                                                    t.translate(e, n),
                                                        this.__originalTranslate(
                                                            e,
                                                            n
                                                        );
                                                }),
                                                (e.scale = function (e, n) {
                                                    t.scale(e, n),
                                                        this.__originalScale(
                                                            e,
                                                            n
                                                        );
                                                }),
                                                (e.transform = function (
                                                    e,
                                                    n,
                                                    r,
                                                    i,
                                                    s,
                                                    a
                                                ) {
                                                    t.transform(
                                                        e,
                                                        n,
                                                        r,
                                                        i,
                                                        s,
                                                        a
                                                    ),
                                                        this.__originalTransform(
                                                            e,
                                                            n,
                                                            r,
                                                            i,
                                                            s,
                                                            a
                                                        );
                                                }),
                                                (e.setTransform = function (
                                                    e,
                                                    n,
                                                    r,
                                                    i,
                                                    s,
                                                    a
                                                ) {
                                                    t.setTransform(
                                                        e,
                                                        n,
                                                        r,
                                                        i,
                                                        s,
                                                        a
                                                    ),
                                                        this.__originalSetTransform(
                                                            e,
                                                            n,
                                                            r,
                                                            i,
                                                            s,
                                                            a
                                                        );
                                                }),
                                                (e.resetTransform =
                                                    function () {
                                                        t.resetTransform(),
                                                            this.__originalResetTransform();
                                                    }),
                                                (e.rotate = function (e) {
                                                    t.rotate(e),
                                                        this.__originalRotate(
                                                            e
                                                        );
                                                }),
                                                (e.clip = function (e) {
                                                    t.clip(e),
                                                        this.__originalClip(e);
                                                }),
                                                (e.moveTo = function (e, n) {
                                                    t.moveTo(e, n),
                                                        this.__originalMoveTo(
                                                            e,
                                                            n
                                                        );
                                                }),
                                                (e.lineTo = function (e, n) {
                                                    t.lineTo(e, n),
                                                        this.__originalLineTo(
                                                            e,
                                                            n
                                                        );
                                                }),
                                                (e.bezierCurveTo = function (
                                                    e,
                                                    n,
                                                    r,
                                                    i,
                                                    s,
                                                    a
                                                ) {
                                                    t.bezierCurveTo(
                                                        e,
                                                        n,
                                                        r,
                                                        i,
                                                        s,
                                                        a
                                                    ),
                                                        this.__originalBezierCurveTo(
                                                            e,
                                                            n,
                                                            r,
                                                            i,
                                                            s,
                                                            a
                                                        );
                                                }),
                                                (e.rect = function (
                                                    e,
                                                    n,
                                                    r,
                                                    i
                                                ) {
                                                    t.rect(e, n, r, i),
                                                        this.__originalRect(
                                                            e,
                                                            n,
                                                            r,
                                                            i
                                                        );
                                                }),
                                                (e.closePath = function () {
                                                    t.closePath(),
                                                        this.__originalClosePath();
                                                }),
                                                (e.beginPath = function () {
                                                    t.beginPath(),
                                                        this.__originalBeginPath();
                                                });
                                        })(i, this.suspendedCtx),
                                        this.setGState([
                                            ["BM", "source-over"],
                                            ["ca", 1],
                                            ["CA", 1],
                                        ]);
                                }
                                endSMaskMode() {
                                    if (!this.inSMaskMode)
                                        throw new Error(
                                            "endSMaskMode called while not in smask mode"
                                        );
                                    this.ctx._removeMirroring(),
                                        v(this.ctx, this.suspendedCtx),
                                        (this.ctx = this.suspendedCtx),
                                        (this.suspendedCtx = null);
                                }
                                compose(e) {
                                    if (!this.current.activeSMask) return;
                                    e
                                        ? ((e[0] = Math.floor(e[0])),
                                          (e[1] = Math.floor(e[1])),
                                          (e[2] = Math.ceil(e[2])),
                                          (e[3] = Math.ceil(e[3])))
                                        : (e = [
                                              0,
                                              0,
                                              this.ctx.canvas.width,
                                              this.ctx.canvas.height,
                                          ]);
                                    const t = this.current.activeSMask;
                                    S(this.suspendedCtx, t, this.ctx, e),
                                        this.ctx.save(),
                                        this.ctx.setTransform(1, 0, 0, 1, 0, 0),
                                        this.ctx.clearRect(
                                            0,
                                            0,
                                            this.ctx.canvas.width,
                                            this.ctx.canvas.height
                                        ),
                                        this.ctx.restore();
                                }
                                save() {
                                    this.inSMaskMode
                                        ? (v(this.ctx, this.suspendedCtx),
                                          this.suspendedCtx.save())
                                        : this.ctx.save();
                                    const e = this.current;
                                    this.stateStack.push(e),
                                        (this.current = e.clone());
                                }
                                restore() {
                                    0 === this.stateStack.length &&
                                        this.inSMaskMode &&
                                        this.endSMaskMode(),
                                        0 !== this.stateStack.length &&
                                            ((this.current =
                                                this.stateStack.pop()),
                                            this.inSMaskMode
                                                ? (this.suspendedCtx.restore(),
                                                  v(
                                                      this.suspendedCtx,
                                                      this.ctx
                                                  ))
                                                : this.ctx.restore(),
                                            this.checkSMaskState(),
                                            (this.pendingClip = null),
                                            (this._cachedScaleForStroking[0] =
                                                -1),
                                            (this._cachedGetSinglePixelWidth =
                                                null));
                                }
                                transform(e, t, n, r, i, s) {
                                    this.ctx.transform(e, t, n, r, i, s),
                                        (this._cachedScaleForStroking[0] = -1),
                                        (this._cachedGetSinglePixelWidth =
                                            null);
                                }
                                constructPath(e, t, n) {
                                    const r = this.ctx,
                                        i = this.current;
                                    let s,
                                        a,
                                        c = i.x,
                                        u = i.y;
                                    const d = (0, l.getCurrentTransform)(r),
                                        p =
                                            (0 === d[0] && 0 === d[3]) ||
                                            (0 === d[1] && 0 === d[2]),
                                        h = p ? n.slice(0) : null;
                                    for (
                                        let l = 0, f = 0, m = e.length;
                                        l < m;
                                        l++
                                    )
                                        switch (0 | e[l]) {
                                            case o.OPS.rectangle:
                                                (c = t[f++]), (u = t[f++]);
                                                const e = t[f++],
                                                    n = t[f++],
                                                    l = c + e,
                                                    m = u + n;
                                                r.moveTo(c, u),
                                                    0 === e || 0 === n
                                                        ? r.lineTo(l, m)
                                                        : (r.lineTo(l, u),
                                                          r.lineTo(l, m),
                                                          r.lineTo(c, m)),
                                                    p ||
                                                        i.updateRectMinMax(d, [
                                                            c,
                                                            u,
                                                            l,
                                                            m,
                                                        ]),
                                                    r.closePath();
                                                break;
                                            case o.OPS.moveTo:
                                                (c = t[f++]),
                                                    (u = t[f++]),
                                                    r.moveTo(c, u),
                                                    p ||
                                                        i.updatePathMinMax(
                                                            d,
                                                            c,
                                                            u
                                                        );
                                                break;
                                            case o.OPS.lineTo:
                                                (c = t[f++]),
                                                    (u = t[f++]),
                                                    r.lineTo(c, u),
                                                    p ||
                                                        i.updatePathMinMax(
                                                            d,
                                                            c,
                                                            u
                                                        );
                                                break;
                                            case o.OPS.curveTo:
                                                (s = c),
                                                    (a = u),
                                                    (c = t[f + 4]),
                                                    (u = t[f + 5]),
                                                    r.bezierCurveTo(
                                                        t[f],
                                                        t[f + 1],
                                                        t[f + 2],
                                                        t[f + 3],
                                                        c,
                                                        u
                                                    ),
                                                    i.updateCurvePathMinMax(
                                                        d,
                                                        s,
                                                        a,
                                                        t[f],
                                                        t[f + 1],
                                                        t[f + 2],
                                                        t[f + 3],
                                                        c,
                                                        u,
                                                        h
                                                    ),
                                                    (f += 6);
                                                break;
                                            case o.OPS.curveTo2:
                                                (s = c),
                                                    (a = u),
                                                    r.bezierCurveTo(
                                                        c,
                                                        u,
                                                        t[f],
                                                        t[f + 1],
                                                        t[f + 2],
                                                        t[f + 3]
                                                    ),
                                                    i.updateCurvePathMinMax(
                                                        d,
                                                        s,
                                                        a,
                                                        c,
                                                        u,
                                                        t[f],
                                                        t[f + 1],
                                                        t[f + 2],
                                                        t[f + 3],
                                                        h
                                                    ),
                                                    (c = t[f + 2]),
                                                    (u = t[f + 3]),
                                                    (f += 4);
                                                break;
                                            case o.OPS.curveTo3:
                                                (s = c),
                                                    (a = u),
                                                    (c = t[f + 2]),
                                                    (u = t[f + 3]),
                                                    r.bezierCurveTo(
                                                        t[f],
                                                        t[f + 1],
                                                        c,
                                                        u,
                                                        c,
                                                        u
                                                    ),
                                                    i.updateCurvePathMinMax(
                                                        d,
                                                        s,
                                                        a,
                                                        t[f],
                                                        t[f + 1],
                                                        c,
                                                        u,
                                                        c,
                                                        u,
                                                        h
                                                    ),
                                                    (f += 4);
                                                break;
                                            case o.OPS.closePath:
                                                r.closePath();
                                        }
                                    p && i.updateScalingPathMinMax(d, h),
                                        i.setCurrentPoint(c, u);
                                }
                                closePath() {
                                    this.ctx.closePath();
                                }
                                stroke(e = !0) {
                                    const t = this.ctx,
                                        n = this.current.strokeColor;
                                    (t.globalAlpha = this.current.strokeAlpha),
                                        this.contentVisible &&
                                            ("object" == typeof n &&
                                            (null == n ? void 0 : n.getPattern)
                                                ? (t.save(),
                                                  (t.strokeStyle = n.getPattern(
                                                      t,
                                                      this,
                                                      (0,
                                                      l.getCurrentTransformInverse)(
                                                          t
                                                      ),
                                                      c.PathType.STROKE
                                                  )),
                                                  this.rescaleAndStroke(!1),
                                                  t.restore())
                                                : this.rescaleAndStroke(!0)),
                                        e &&
                                            this.consumePath(
                                                this.current.getClippedPathBoundingBox()
                                            ),
                                        (t.globalAlpha =
                                            this.current.fillAlpha);
                                }
                                closeStroke() {
                                    this.closePath(), this.stroke();
                                }
                                fill(e = !0) {
                                    const t = this.ctx,
                                        n = this.current.fillColor;
                                    let r = !1;
                                    this.current.patternFill &&
                                        (t.save(),
                                        (t.fillStyle = n.getPattern(
                                            t,
                                            this,
                                            (0, l.getCurrentTransformInverse)(
                                                t
                                            ),
                                            c.PathType.FILL
                                        )),
                                        (r = !0));
                                    const i =
                                        this.current.getClippedPathBoundingBox();
                                    this.contentVisible &&
                                        null !== i &&
                                        (this.pendingEOFill
                                            ? (t.fill("evenodd"),
                                              (this.pendingEOFill = !1))
                                            : t.fill()),
                                                 );
                                    this.cssStyle ||
                                        ((this.cssStyle =
                                            this.svgFactory.createElement(
                                                "svg:style"
                                            )),
                                        this.cssStyle.setAttributeNS(
                                            null,
                                            "type",
                                            "text/css"
                                        ),
                                        this.defs.append(this.cssStyle));
                                    const t = u(
                                        e.data,
                                        e.mimetype,
                                        this.forceDataSchema
                                    );
                                    this.cssStyle.textContent += `@font-face { font-family: "${e.loadedName}"; src: url(${t}); }\n`;
                                }
                                setFont(e) {
                                    const t = this.current,
                                        n = this.commonObjs.get(e[0]);
                                    let r = e[1];
                                    (t.font = n),
                                        !this.embedFonts ||
                                            n.missingFile ||
                                            this.embeddedFonts[n.loadedName] ||
                                            (this.addFontStyle(n),
                                            (this.embeddedFonts[n.loadedName] =
                                                n)),
                                        (t.fontMatrix =
                                            n.fontMatrix ||
                                            i.FONT_IDENTITY_MATRIX);
                                    let s = "normal";
                                    n.black
                                        ? (s = "900")
                                        : n.bold && (s = "bold");
                                    const a = n.italic ? "italic" : "normal";
                                    r < 0
                                        ? ((r = -r), (t.fontDirection = -1))
                                        : (t.fontDirection = 1),
                                        (t.fontSize = r),
                                        (t.fontFamily = n.loadedName),
                                        (t.fontWeight = s),
                                        (t.fontStyle = a),
                                        (t.tspan =
                                            this.svgFactory.createElement(
                                                "svg:tspan"
                                            )),
                                        t.tspan.setAttributeNS(
                                            null,
                                            "y",
                                            h(-t.y)
                                        ),
                                        (t.xcoords = []),
                                        (t.ycoords = []);
                                }
                                endText() {
                                    var e;
                                    const t = this.current;
                                    t.textRenderingMode &
                                        i.TextRenderingMode.ADD_TO_PATH_FLAG &&
                                        (null == (e = t.txtElement)
                                            ? void 0
                                            : e.hasChildNodes()) &&
                                        ((t.element = t.txtElement),
                                        this.clip("nonzero"),
                                        this.endPath());
                                }
                                setLineWidth(e) {
                                    e > 0 && (this.current.lineWidth = e);
                                }
                                setLineCap(e) {
                                    this.current.lineCap = l[e];
                                }
                                setLineJoin(e) {
                                    this.current.lineJoin = c[e];
                                }
                                setMiterLimit(e) {
                                    this.current.miterLimit = e;
                                }
                                setStrokeAlpha(e) {
                                    this.current.strokeAlpha = e;
                                }
                                setStrokeRGBColor(e, t, n) {
                                    this.current.strokeColor =
                                        i.Util.makeHexColor(e, t, n);
                                }
                                setFillAlpha(e) {
                                    this.current.fillAlpha = e;
                                }
                                setFillRGBColor(e, t, n) {
                                    (this.current.fillColor =
                                        i.Util.makeHexColor(e, t, n)),
                                        (this.current.tspan =
                                            this.svgFactory.createElement(
                                                "svg:tspan"
                                            )),
                                        (this.current.xcoords = []),
                                        (this.current.ycoords = []);
                                }
                                setStrokeColorN(e) {
                                    this.current.strokeColor =
                                        this._makeColorN_Pattern(e);
                                }
                                setFillColorN(e) {
                                    this.current.fillColor =
                                        this._makeColorN_Pattern(e);
                                }
                                shadingFill(e) {
                                    const { width: t, height: n } =
                                            this.viewport,
                                        r = i.Util.inverseTransform(
                                            this.transformMatrix
                                        ),
                                        [s, a, o, l] =
                                            i.Util.getAxialAlignedBoundingBox(
                                                [0, 0, t, n],
                                                r
                                            ),
                                        c =
                                            this.svgFactory.createElement(
                                                "svg:rect"
                                            );
                                    c.setAttributeNS(null, "x", s),
                                        c.setAttributeNS(null, "y", a),
                                        c.setAttributeNS(null, "width", o - s),
                                        c.setAttributeNS(null, "height", l - a),
                                        c.setAttributeNS(
                                            null,
                                            "fill",
                                            this._makeShadingPattern(e)
                                        ),
                                        this.current.fillAlpha < 1 &&
                                            c.setAttributeNS(
                                                null,
                                                "fill-opacity",
                                                this.current.fillAlpha
                                            ),
                                        this._ensureTransformGroup().append(c);
                                }
                                _makeColorN_Pattern(e) {
                                    return "TilingPattern" === e[0]
                                        ? this._makeTilingPattern(e)
                                        : this._makeShadingPattern(e);
                                }
                                _makeTilingPattern(e) {
                                    const t = e[1],
                                        n = e[2],
                                        r = e[3] || i.IDENTITY_MATRIX,
                                        [s, a, o, l] = e[4],
                                        c = e[5],
                                        u = e[6],
                                        d = e[7],
                                        p = "shading" + x++,
                                        [h, f, m, g] = i.Util.normalizeRect([
                                            ...i.Util.applyTransform([s, a], r),
                                            ...i.Util.applyTransform([o, l], r),
                                        ]),
                                        [v, b] =
                                            i.Util.singularValueDecompose2dScale(
                                                r
                                            ),
                                        y = c * v,
                                        _ = u * b,
                                        E =
                                            this.svgFactory.createElement(
                                                "svg:pattern"
                                            );
                                    E.setAttributeNS(null, "id", p),
                                        E.setAttributeNS(
                                            null,
                                            "patternUnits",
                                            "userSpaceOnUse"
                                        ),
                                        E.setAttributeNS(null, "width", y),
                                        E.setAttributeNS(null, "height", _),
                                        E.setAttributeNS(null, "x", `${h}`),
                                        E.setAttributeNS(null, "y", `${f}`);
                                    const S = this.svg,
                                        w = this.transformMatrix,
                                        A = this.current.fillColor,
                                        R = this.current.strokeColor,
                                        C = this.svgFactory.create(
                                            m - h,
                                            g - f
                                        );
                                    if (
                                        ((this.svg = C),
                                        (this.transformMatrix = r),
                                        2 === d)
                                    ) {
                                        const e = i.Util.makeHexColor(...t);
                                        (this.current.fillColor = e),
                                            (this.current.strokeColor = e);
                                    }
                                    return (
                                        this.executeOpTree(
                                            this.convertOpList(n)
                                        ),
                                        (this.svg = S),
                                        (this.transformMatrix = w),
                                        (this.current.fillColor = A),
                                        (this.current.strokeColor = R),
                                        E.append(C.childNodes[0]),
                                        this.defs.append(E),
                                        `url(#${p})`
                                    );
                                }
                                _makeShadingPattern(e) {
                                    switch (
                                        ("string" == typeof e &&
                                            (e = this.objs.get(e)),
                                        e[0])
                                    ) {
                                        case "RadialAxial":
                                            const t = "shading" + x++,
                                                n = e[3];
                                            let r;
                                            switch (e[1]) {
                                                case "axial":
                                                    const n = e[4],
                                                        i = e[5];
                                                    (r =
                                                        this.svgFactory.createElement(
                                                            "svg:linearGradient"
                                                        )),
                                                        r.setAttributeNS(
                                                            null,
                                                            "id",
                                                            t
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "gradientUnits",
                                                            "userSpaceOnUse"
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "x1",
                                                            n[0]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "y1",
                                                            n[1]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "x2",
                                                            i[0]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "y2",
                                                            i[1]
                                                        );
                                                    break;
                                                case "radial":
                                                    const s = e[4],
                                                        a = e[5],
                                                        o = e[6],
                                                        l = e[7];
                                                    (r =
                                                        this.svgFactory.createElement(
                                                            "svg:radialGradient"
                                                        )),
                                                        r.setAttributeNS(
                                                            null,
                                                            "id",
                                                            t
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "gradientUnits",
                                                            "userSpaceOnUse"
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "cx",
                                                            a[0]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "cy",
                                                            a[1]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "r",
                                                            l
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "fx",
                                                            s[0]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "fy",
                                                            s[1]
                                                        ),
                                                        r.setAttributeNS(
                                                            null,
                                                            "fr",
                                                            o
                                                        );
                                                    break;
                                                default:
                                                    throw new Error(
                                                        `Unknown RadialAxial type: ${e[1]}`
                                                    );
                                            }
                                            for (const e of n) {
                                                const t =
                                                    this.svgFactory.createElement(
                                                        "svg:stop"
                                                    );
                                                t.setAttributeNS(
                                                    null,
                                                    "offset",
                                                    e[0]
                                                ),
                                                    t.setAttributeNS(
                                                        null,
                                                        "stop-color",
                                                        e[1]
                                                    ),
                                                    r.append(t);
                                            }
                                            return (
                                                this.defs.append(r),
                                                `url(#${t})`
                                            );
                                        case "Mesh":
                                            return (
                                                (0, i.warn)(
                                                    "Unimplemented pattern Mesh"
                                                ),
                                                null
                                            );
                                        case "Dummy":
                                            return "hotpink";
                                        default:
                                            throw new Error(
                                                `Unknown IR type: ${e[0]}`
                                            );
                                    }
                                }
                                setDash(e, t) {
                                    (this.current.dashArray = e),
                                        (this.current.dashPhase = t);
                                }
                                constructPath(e, t) {
                                    const n = this.current;
                                    let r = n.x,
                                        s = n.y,
                                        a = [],
                                        o = 0;
                                    for (const l of e)
                                        switch (0 | l) {
                                            case i.OPS.rectangle:
                                                (r = t[o++]), (s = t[o++]);
                                                const e = r + t[o++],
                                                    n = s + t[o++];
                                                a.push(
                                                    "M",
                                                    h(r),
                                                    h(s),
                                                    "L",
                                                    h(e),
                                                    h(s),
                                                    "L",
                                                    h(e),
                                                    h(n),
                                                    "L",
                                                    h(r),
                                                    h(n),
                                                    "Z"
                                                );
                                                break;
                                            case i.OPS.moveTo:
                                                (r = t[o++]),
                                                    (s = t[o++]),
                                                    a.push("M", h(r), h(s));
                                                break;
                                            case i.OPS.lineTo:
                                                (r = t[o++]),
                                                    (s = t[o++]),
                                                    a.push("L", h(r), h(s));
                                                break;
                                            case i.OPS.curveTo:
                                                (r = t[o + 4]),
                                                    (s = t[o + 5]),
                                                    a.push(
                                                        "C",
                                                        h(t[o]),
                                                        h(t[o + 1]),
                                                        h(t[o + 2]),
                                                        h(t[o + 3]),
                                                        h(r),
                                                        h(s)
                                                    ),
                                                    (o += 6);
                                                break;
                                            case i.OPS.curveTo2:
                                                a.push(
                                                    "C",
                                                    h(r),
                                                    h(s),
                                                    h(t[o]),
                                                    h(t[o + 1]),
                                                    h(t[o + 2]),
                                                    h(t[o + 3])
                                                ),
                                                    (r = t[o + 2]),
                                                    (s = t[o + 3]),
                                                    (o += 4);
                                                break;
                                            case i.OPS.curveTo3:
                                                (r = t[o + 2]),
                                                    (s = t[o + 3]),
                                                    a.push(
                                                        "C",
                                                        h(t[o]),
                                                        h(t[o + 1]),
                                                        h(r),
                                                        h(s),
                                                        h(r),
                                                        h(s)
                                                    ),
                                                    (o += 4);
                                                break;
                                            case i.OPS.closePath:
                                                a.push("Z");
                                        }
                                    (a = a.join(" ")),
                                        n.path &&
                                        e.length > 0 &&
                                        e[0] !== i.OPS.rectangle &&
                                        e[0] !== i.OPS.moveTo
                                            ? (a =
                                                  n.path.getAttributeNS(
                                                      null,
                                                      "d"
                                                  ) + a)
                                            : ((n.path =
                                                  this.svgFactory.createElement(
                                                      "svg:path"
                                                  )),
                                              this._ensureTransformGroup().append(
                                                  n.path
                                              )),
                                        n.path.setAttributeNS(null, "d", a),
                                        n.path.setAttributeNS(
                                            null,
                                            "fill",
                                            "none"
                                        ),
                                        (n.element = n.path),
                                        n.setCurrentPoint(r, s);
                                }
                                endPath() {
                                    const e = this.current;
                                    if (((e.path = null), !this.pendingClip))
                                        return;
                                    if (!e.element)
                                        return void (this.pendingClip = null);
                                    const t = "clippath" + m++,
                                        n =
                                            this.svgFactory.createElement(
                                                "svg:clipPath"
                                            );
                                    n.setAttributeNS(null, "id", t),
                                        n.setAttributeNS(
                                            null,
                                            "transform",
                                            f(this.transformMatrix)
                                        );
                                    const r = e.element.cloneNode(!0);
                                    if (
                                        ("evenodd" === this.pendingClip
                                            ? r.setAttributeNS(
                                                  null,
                                                  "clip-rule",
                                                  "evenodd"
                                              )
                                            : r.setAttributeNS(
                                                  null,
                                                  "clip-rule",
                                                  "nonzero"
                                              ),
                                        (this.pendingClip = null),
                                        n.append(r),
                                        this.defs.append(n),
                                        e.activeClipUrl)
                                    ) {
                                        e.clipGroup = null;
                                        for (const e of this.extraStack)
                                            e.clipGroup = null;
                                        n.setAttributeNS(
                                            null,
                                            "clip-path",
                                            e.activeClipUrl
                                        );
                                    }
                                    (e.activeClipUrl = `url(#${t})`),
                                        (this.tgrp = null);
                                }
                                clip(e) {
                                    this.pendingClip = e;
                                }
                                closePath() {
                                    const e = this.current;
                                    if (e.path) {
                                        const t = `${e.path.getAttributeNS(
                                            null,
                                            "d"
                                        )}Z`;
                                        e.path.setAttributeNS(null, "d", t);
                                    }
                                }
                                setLeading(e) {
                                    this.current.leading = -e;
                                }
                                setTextRise(e) {
                                    this.current.textRise = e;
                                }
                                setTextRenderingMode(e) {
                                    this.current.textRenderingMode = e;
                                }
                                setHScale(e) {
                                    this.current.textHScale = e / 100;
                                }
                                setRenderingIntent(e) {}
                                setFlatness(e) {}
                                setGState(e) {
                                    for (const [t, n] of e)
                                        switch (t) {
                                            case "LW":
                                                this.setLineWidth(n);
                                                break;
                                            case "LC":
                                                this.setLineCap(n);
                                                break;
                                            case "LJ":
                                                this.setLineJoin(n);
                                                break;
                                            case "ML":
                                                this.setMiterLimit(n);
                                                break;
                                            case "D":
                                                this.setDash(n[0], n[1]);
                                                break;
                                            case "RI":
                                                this.setRenderingIntent(n);
                                                break;
                                            case "FL":
                                                this.setFlatness(n);
                                                break;
                                            case "Font":
                                                this.setFont(n);
                                                break;
                                            case "CA":
                                                this.setStrokeAlpha(n);
                                                break;
                                            case "ca":
                                                this.setFillAlpha(n);
                                                break;
                                            default:
                                                (0, i.warn)(
                                                    `Unimplemented graphic state operator ${t}`
                                                );
                                        }
                                }
                                fill() {
                                    const e = this.current;
                                    e.element &&
                                        (e.element.setAttributeNS(
                                            null,
                                            "fill",
                                            e.fillColor
                                        ),
                                        e.element.setAttributeNS(
                                            null,
                                            "fill-opacity",
                                            e.fillAlpha
                                        ),
                                        this.endPath());
                                }
                                stroke() {
                                    const e = this.current;
                                    e.element &&
                                        (this._setStrokeAttributes(e.element),
                                        e.element.setAttributeNS(
                                            null,
                                            "fill",
                                            "none"
                                        ),
                                        this.endPath());
                                }
                                _setStrokeAttributes(e, t = 1) {
                                    const n = this.current;
                                    let r = n.dashArray;
                                    1 !== t &&
                                        r.length > 0 &&
                                        (r = r.map(function (e) {
                                            return t * e;
                                        })),
                                        e.setAttributeNS(
                                            null,
                                            "stroke",
                                            n.strokeColor
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-opacity",
                                            n.strokeAlpha
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-miterlimit",
                                            h(n.miterLimit)
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-linecap",
                                            n.lineCap
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-linejoin",
                                            n.lineJoin
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-width",
                                            h(t * n.lineWidth) + "px"
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-dasharray",
                                            r.map(h).join(" ")
                                        ),
                                        e.setAttributeNS(
                                            null,
                                            "stroke-dashoffset",
                                            h(t * n.dashPhase) + "px"
                                        );
                                }
                                eoFill() {
                                    var e;
                                    null == (e = this.current.element) ||
                                        e.setAttributeNS(
                                            null,
                                            "fill-rule",
                                            "evenodd"
                                        ),
                                        this.fill();
                                }
                                fillStroke() {
                                    this.stroke(), this.fill();
                                }
                                eoFillStroke() {
                                    var e;
                                    null == (e = this.current.element) ||
                                        e.setAttributeNS(
                                            null,
                                            "fill-rule",
                                            "evenodd"
                                        ),
                                        this.fillStroke();
                                }
                                closeStroke() {
                                    this.closePath(), this.stroke();
                                }
                                closeFillStroke() {
                                    this.closePath(), this.fillStroke();
                                }
                                closeEOFillStroke() {
                                    this.closePath(), this.eoFillStroke();
                                }
                                paintSolidColorImageMask() {
                                    const e =
                                        this.svgFactory.createElement(
                                            "svg:rect"
                                        );
                                    e.setAttributeNS(null, "x", "0"),
                                        e.setAttributeNS(null, "y", "0"),
                                        e.setAttributeNS(null, "width", "1px"),
                                        e.setAttributeNS(null, "height", "1px"),
                                        e.setAttributeNS(
                                            null,
                                            "fill",
                                            this.current.fillColor
                                        ),
                                        this._ensureTransformGroup().append(e);
                                }
                                paintImageXObject(e) {
                                    const t = this.getObject(e);
                                    t
                                        ? this.paintInlineImageXObject(t)
                                        : (0, i.warn)(
                                              `Dependent image with object ID ${e} is not ready yet`
                                          );
                                }
                                paintInlineImageXObject(e, t) {
                                    const n = e.width,
                                        r = e.height,
                                        i = d(e, this.forceDataSchema, !!t),
                                        s =
                                            this.svgFactory.createElement(
                                                "svg:rect"
                                            );
                                    s.setAttributeNS(null, "x", "0"),
                                        s.setAttributeNS(null, "y", "0"),
                                        s.setAttributeNS(null, "width", h(n)),
                                        s.setAttributeNS(null, "height", h(r)),
                                        (this.current.element = s),
                                        this.clip("nonzero");
                                    const a =
                                        this.svgFactory.createElement(
                                            "svg:image"
                                        );
                                    a.setAttributeNS(
                                        "http://www.w3.org/1999/xlink",
                                        "xlink:href",
                                        i
                                    ),
                                        a.setAttributeNS(null, "x", "0"),
                                        a.setAttributeNS(null, "y", h(-r)),
                                        a.setAttributeNS(
                                            null,
                                            "width",
                                            h(n) + "px"
                                        ),
                                        a.setAttributeNS(
                                            null,
                                            "height",
                                            h(r) + "px"
                                        ),
                                        a.setAttributeNS(
                                            null,
                                            "transform",
                                            `scale(${h(1 / n)} ${h(-1 / r)})`
                                        ),
                                        t
                                            ? t.append(a)
                                            : this._ensureTransformGroup().append(
                                                  a
                                              );
                                }
                                paintImageMaskXObject(e) {
                                    const t = this.getObject(e.data, e);
                                    if (t.bitmap)
                                        return void (0, i.warn)(
                                            "paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled."
                                        );
                                    const n = this.current,
                                        r = t.width,
                                        s = t.height,
                                        a = n.fillColor;
                                    n.maskId = "mask" + g++;
                                    const o =
                                        this.svgFactory.createElement(
                                            "svg:mask"
                                        );
                                    o.setAttributeNS(null, "id", n.maskId);
                                    const l =
                                        this.svgFactory.createElement(
                                            "svg:rect"
                                        );
                                    l.setAttributeNS(null, "x", "0"),
                                        l.setAttributeNS(null, "y", "0"),
                                        l.setAttributeNS(null, "width", h(r)),
                                        l.setAttributeNS(null, "height", h(s)),
                                        l.setAttributeNS(null, "fill", a),
                                        l.setAttributeNS(
                                            null,
                                            "mask",
                                            `url(#${n.maskId})`
                                        ),
                                        this.defs.append(o),
                                        this._ensureTransformGroup().append(l),
                                        this.paintInlineImageXObject(t, o);
                                }
                                paintFormXObjectBegin(e, t) {
                                    if (
                                        (Array.isArray(e) &&
                                            6 === e.length &&
                                            this.transform(
                                                e[0],
                                                e[1],
                                                e[2],
                                                e[3],
                                                e[4],
                                                e[5]
                                            ),
                                        t)
                                    ) {
                                        const e = t[2] - t[0],
                                            n = t[3] - t[1],
                                            r =
                                                this.svgFactory.createElement(
                                                    "svg:rect"
                                                );
                                        r.setAttributeNS(null, "x", t[0]),
                                            r.setAttributeNS(null, "y", t[1]),
                                            r.setAttributeNS(
                                                null,
                                                "width",
                                                h(e)
                                            ),
                                            r.setAttributeNS(
                                                null,
                                                "height",
                                                h(n)
                                            ),
                                            (this.current.element = r),
                                            this.clip("nonzero"),
                                            this.endPath();
                                    }
                                }
                                paintFormXObjectEnd() {}
                                _initialize(e) {
                                    const t = this.svgFactory.create(
                                            e.width,
                                            e.height
                                        ),
                                        n =
                                            this.svgFactory.createElement(
                                                "svg:defs"
                                            );
                                    t.append(n), (this.defs = n);
                                    const r =
                                        this.svgFactory.createElement("svg:g");
                                    return (
                                        r.setAttributeNS(
                                            null,
                                            "transform",
                                            f(e.transform)
                                        ),
                                        t.append(r),
                                        (this.svg = r),
                                        t
                                    );
                                }
                                _ensureClipGroup() {
                                    if (!this.current.clipGroup) {
                                        const e =
                                            this.svgFactory.createElement(
                                                "svg:g"
                                            );
                                        e.setAttributeNS(
                                            null,
                                            "clip-path",
                                            this.current.activeClipUrl
                                        ),
                                            this.svg.append(e),
                                            (this.current.clipGroup = e);
                                    }
                                    return this.current.clipGroup;
                                }
                                _ensureTransformGroup() {
                                    return (
                                        this.tgrp ||
                                            ((this.tgrp =
                                                this.svgFactory.createElement(
                                                    "svg:g"
                                                )),
                                            this.tgrp.setAttributeNS(
                                                null,
                                                "transform",
                                                f(this.transformMatrix)
                                            ),
                                            this.current.activeClipUrl
                                                ? this._ensureClipGroup().append(
                                                      this.tgrp
                                                  )
                                                : this.svg.append(this.tgrp)),
                                        this.tgrp
                                    );
                                }
                            };
                        },
                        (e, t) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.XfaText = void 0);
                            class n {
                                static textContent(e) {
                                    const t = [],
                                        r = {
                                            items: t,
                                            styles: Object.create(null),
                                        };
                                    return (
                                        (function e(r) {
                                            var i;
                                            if (!r) return;
                                            let s = null;
                                            const a = r.name;
                                            if ("#text" === a) s = r.value;
                                            else {
                                                if (!n.shouldBuildText(a))
                                                    return;
                                                (
                                                    null ==
                                                    (i =
                                                        null == r
                                                            ? void 0
                                                            : r.attributes)
                                                        ? void 0
                                                        : i.textContent
                                                )
                                                    ? (s =
                                                          r.attributes
                                                              .textContent)
                                                    : r.value && (s = r.value);
                                            }
                                            if (
                                                (null !== s &&
                                                    t.push({ str: s }),
                                                r.children)
                                            )
                                                for (const t of r.children)
                                                    e(t);
                                        })(e),
                                        r
                                    );
                                }
                                static shouldBuildText(e) {
                                    return !(
                                        "textarea" === e ||
                                        "input" === e ||
                                        "option" === e ||
                                        "select" === e
                                    );
                                }
                            }
                            t.XfaText = n;
                        },
                        (e, t, n) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.TextLayerRenderTask = void 0),
                                (t.renderTextLayer = function (e) {
                                    e.textContentSource ||
                                        (!e.textContent &&
                                            !e.textContentStream) ||
                                        ((0, i.deprecated)(
                                            "The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."
                                        ),
                                        (e.textContentSource =
                                            e.textContent ||
                                            e.textContentStream));
                                    const { container: t, viewport: n } = e,
                                        r = getComputedStyle(t),
                                        s = r.getPropertyValue("visibility"),
                                        a = parseFloat(
                                            r.getPropertyValue("--scale-factor")
                                        );
                                    "visible" === s &&
                                        (!a || Math.abs(a - n.scale) > 1e-5) &&
                                        console.error(
                                            "The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM."
                                        );
                                    const o = new d(e);
                                    return o._render(), o;
                                }),
                                (t.updateTextLayer = function ({
                                    container: e,
                                    viewport: t,
                                    textDivs: n,
                                    textDivProperties: r,
                                    isOffscreenCanvasSupported: s,
                                    mustRotate: a = !0,
                                    mustRescale: o = !0,
                                }) {
                                    if (
                                        (a &&
                                            (0, i.setLayerDimensions)(e, {
                                                rotation: t.rotation,
                                            }),
                                        o)
                                    ) {
                                        const e = l(0, s),
                                            i = {
                                                prevFontSize: null,
                                                prevFontFamily: null,
                                                div: null,
                                                scale:
                                                    t.scale *
                                                    (globalThis.devicePixelRatio ||
                                                        1),
                                                properties: null,
                                                ctx: e,
                                            };
                                        for (const t of n)
                                            (i.properties = r.get(t)),
                                                (i.div = t),
                                                u(i);
                                    }
                                });
                            var r = n(1),
                                i = n(6);
                            const s = 30,
                                a = 0.8,
                                o = new Map();
                            function l(e, t) {
                                let n;
                                if (
                                    t &&
                                    r.FeatureTest.isOffscreenCanvasSupported
                                )
                                    n = new OffscreenCanvas(e, e).getContext(
                                        "2d",
                                        { alpha: !1 }
                                    );
                                else {
                                    const t = document.createElement("canvas");
                                    (t.width = t.height = e),
                                        (n = t.getContext("2d", { alpha: !1 }));
                                }
                                return n;
                            }
                            function c(e, t, n) {
                                const i = document.createElement("span"),
                                    c = {
                                        angle: 0,
                                        canvasWidth: 0,
                                        hasText: "" !== t.str,
                                        hasEOL: t.hasEOL,
                                        fontSize: 0,
                                    };
                                e._textDivs.push(i);
                                const u = r.Util.transform(
                                    e._transform,
                                    t.transform
                                );
                                let d = Math.atan2(u[1], u[0]);
                                const p = n[t.fontName];
                                p.vertical && (d += Math.PI / 2);
                                const h = Math.hypot(u[2], u[3]),
                                    f =
                                        h *
                                        (function (e, t) {
                                            const n = o.get(e);
                                            if (n) return n;
                                            const r = l(s, t);
                                            r.font = `${s}px ${e}`;
                                            const i = r.measureText("");
                                            let c = i.fontBoundingBoxAscent,
                                                u = Math.abs(
                                                    i.fontBoundingBoxDescent
                                                );
                                            if (c) {
                                                const t = c / (c + u);
                                                return (
                                                    o.set(e, t),
                                                    (r.canvas.width =
                                                        r.canvas.height =
                                                            0),
                                                    t
                                                );
                                            }
                                            (r.strokeStyle = "red"),
                                                r.clearRect(0, 0, s, s),
                                                r.strokeText("g", 0, 0);
                                            let d = r.getImageData(
                                                0,
                                                0,
                                                s,
                                                s
                                            ).data;
                                            u = 0;
                                            for (
                                                let a = d.length - 1 - 3;
                                                a >= 0;
                                                a -= 4
                                            )
                                                if (d[a] > 0) {
                                                    u = Math.ceil(a / 4 / s);
                                                    break;
                                                }
                                            r.clearRect(0, 0, s, s),
                                                r.strokeText("A", 0, s),
                                                (d = r.getImageData(
                                                    0,
                                                    0,
                                                    s,
                                                    s
                                                ).data),
                                                (c = 0);
                                            for (
                                                let a = 0, o = d.length;
                                                a < o;
                                                a += t x = "calc(var(--scale-factor)*",
                                    v = i.style;
                                e._container === e._rootContainer
                                    ? ((v.left = `${(
                                          (100 * m) /
                                          e._pageWidth
                                      ).toFixed(2)}%`),
                                      (v.top = `${(
                                          (100 * g) /
                                          e._pageHeight
                                      ).toFixed(2)}%`))
                                    : ((v.left = `${x}${m.toFixed(2)}px)`),
                                      (v.top = `${x}${g.toFixed(2)}px)`)),
                                    (v.fontSize = `${x}${h.toFixed(2)}px)`),
                                    (v.fontFamily = p.fontFamily),
                                    (c.fontSize = h),
                                    i.setAttribute("role", "presentation"),
                                    (i.textContent = t.str),
                                    (i.dir = t.dir),
                                    e._fontInspectorEnabled &&
                                        (i.dataset.fontName = t.fontName),
                                    0 !== d && (c.angle = d * (180 / Math.PI));
                                let b = !1;
                                if (t.str.length > 1) b = !0;
                                else if (
                                    " " !== t.str &&
                                    t.transform[0] !== t.transform[3]
                                ) {
                                    const e = Math.abs(t.transform[0]),
                                        n = Math.abs(t.transform[3]);
                                    e !== n &&
                                        Math.max(e, n) / Math.min(e, n) > 1.5 &&
                                        (b = !0);
                                }
                                b &&
                                    (c.canvasWidth = p.vertical
                                        ? t.height
                                        : t.width),
                                    e._textDivProperties.set(i, c),
                                    e._isReadableStream && e._layoutText(i);
                            }
                            function u(e) {
                                const {
                                        div: t,
                                        scale: n,
                                        properties: r,
                                        ctx: i,
                                        prevFontSize: s,
                                        prevFontFamily: a,
                                    } = e,
                                    { style: o } = t;
                                let l = "";
                                if (0 !== r.canvasWidth && r.hasText) {
                                    const { fontFamily: c } = o,
                                        { canvasWidth: u, fontSize: d } = r;
                                    (s === d && a === c) ||
                                        ((i.font = `${d * n}px ${c}`),
                                        (e.prevFontSize = d),
                                        (e.prevFontFamily = c));
                                    const { width: p } = i.measureText(
                                        t.textContent
                                    );
                                    p > 0 && (l = `scaleX(${(u * n) / p})`);
                                }
                                0 !== r.angle &&
                                    (l = `rotate(${r.angle}deg) ${l}`),
                                    l.length > 0 && (o.transform = l);
                            }
                            class d {
                                constructor({
                                    textContentSource: e,
                                    container: t,
                                    viewport: n,
                                    textDivs: s,
                                    textDivProperties: a,
                                    textContentItemsStr: o,
                                    isOffscreenCanvasSupported: c,
                                }) {
                                    var u;
                                    (this._textContentSource = e),
                                        (this._isReadableStream =
                                            e instanceof ReadableStream),
                                        (this._container = this._rootContainer =
                                            t),
                                        (this._textDivs = s || []),
                                        (this._textContentItemsStr = o || []),
                                        (this._isOffscreenCanvasSupported = c),
                                        (this._fontInspectorEnabled = !!(null ==
                                        (u = globalThis.FontInspector)
                                            ? void 0
                                            : u.enabled)),
                                        (this._reader = null),
                                        (this._textDivProperties =
                                            a || new WeakMap()),
                                        (this._canceled = !1),
                                        (this._capability =
                                            new r.PromiseCapability()),
                                        (this._layoutTextParams = {
                                            prevFontSize: null,
                                            prevFontFamily: null,
                                            div: null,
                                            scale:
                                                n.scale *
                                                (globalThis.devicePixelRatio ||
                                                    1),
                                            properties: null,
                                            ctx: l(0, c),
                                        });
                                    const {
                                        pageWidth: d,
                                        pageHeight: p,
                                        pageX: h,
                                        pageY: f,
                                    } = n.rawDims;
                                    (this._transform = [
                                        1,
                                        0,
                                        0,
                                        -1,
                                        -h,
                                        f + p,
                                    ]),
                                        (this._pageWidth = d),
                                        (this._pageHeight = p),
                                        (0, i.setLayerDimensions)(t, n),
                                        this._capability.promise
                                            .finally(() => {
                                                this._layoutTextParams = null;
                                            })
                                            .catch(() => {});
                                }
                                get promise() {
                                    return this._capability.promise;
                                }
                                cancel() {
                                    (this._canceled = !0),
                                        this._reader &&
                                            (this._reader
                                                .cancel(
                                                    new r.AbortException(
                                                        "TextLayer task cancelled."
                                                    )
                                                )
                                                .catch(() => {}),
                                            (this._reader = null)),
                                        this._capability.reject(
                                            new r.AbortException(
                                                "TextLayer task cancelled."
                                            )
                                        );
                                }
                                _processItems(e, t) {
                                    for (const n of e)
                                        if (void 0 !== n.str)
                                            this._textContentItemsStr.push(
                                                n.str
                                            ),
                                                c(this, n, t);
                                        else if (
                                            "beginMarkedContentProps" ===
                                                n.type ||
                                            "beginMarkedContent" === n.type
                                        ) {
                                            const e = this._container;
                                            (this._container =
                                                document.createElement("span")),
                                                this._container.classList.add(
                                                    "markedContent"
                                                ),
                                                null !== n.id &&
                                                    this._container.setAttribute(
                                                        "id",
                                                        `${n.id}`
                                                    ),
                                                e.append(this._container);
                                        } else
                                            "endMarkedContent" === n.type &&
                                                (this._container =
                                                    this._container.parentNode);
                                }
                                _layoutText(e) {
                                    const t =
                                        (this._layoutTextParams.properties =
                                            this._textDivProperties.get(e));
                                    if (
                                        ((this._layoutTextParams.div = e),
                                        u(this._layoutTextParams),
                                        t.hasText && this._container.append(e),
                                        t.hasEOL)
                                    ) {
                                        const e = document.createElement("br");
                                        e.setAttribute("role", "presentation"),
                                            this._container.append(e);
                                    }
                                }
                                _render() {
                                    const e = new r.PromiseCapability();
                                    let t = Object.create(null);
                                    if (this._isReadableStream) {
                                        const n = () => {
                                            this._reader
                                                .read()
                                                .then(
                                                    ({ value: r, done: i }) => {
                                                        i
                                                            ? e.resolve()
                                                            : (Object.assign(
                                                                  t,
                                                                  r.styles
                                                              ),
                                                              this._processItems(
                                                                  r.items,
                                                                  t
                                                              ),
                                                              n());
                                                    },
                                                    e.reject
                                                );
                                        };
                                        (this._reader =
                                            this._textContentSource.getReader()),
                                            n();
                                    } else {
                                        if (!this._textContentSource)
                                            throw new Error(
                                                'No "textContentSource" parameter specified.'
                                            );
                                        {
                                            const { items: t, styles: n } =
                                                this._textContentSource;
                                            this._processItems(t, n),
                                                e.resolve();
                                        }
                                    }
                                    e.promise.then(() => {
                                        (t = null),
                                            (function (e) {
                                                if (e._canceled) return;
                                                const t = e._textDivs,
                                                    n = e._capability;
                                                if (t.length > 1e5) n.resolve();
                                                else {
                                                    if (!e._isReadableStream)
                                                        for (const n of t)
                                                            e._layoutText(n);
                                                    n.resolve();
                                                }
                                            })(this);
                                    }, this._capability.reject);
                                }
                            }
                            t.TextLayerRenderTask = d;
                        },
                        (e, t, n) => {
                            var r,
                                i,
                                s,
                                a,
                                o,
                                l,
                                c,
                                u,
                                d,
                                p,
                                h,
                                f,
                                m,
                                g,
                                x,
                                v,
                                b,
                                y;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.AnnotationEditorLayer = void 0);
                            var _ = n(1),
                                E = n(4),
                                S = n(28),
                                w = n(33),
                                A = n(6),
                                R = n(34);
                            const C = class e {
                                constructor({
                                    uiManager: t,
                                    pageIndex: n,
                                    div: f,
                                    accessibilityManager: g,
                                    annotationLayer: v,
                                    viewport: y,
                                    l10n: _,
                                }) {
                                    __privateAdd(this, h),
                                        __privateAdd(this, m),
                                        __privateAdd(this, x),
                                        __privateAdd(this, b),
                                        __privateAdd(this, r, void 0),
                                        __privateAdd(this, i, !1),
                                        __privateAdd(this, s, null),
                                        __privateAdd(
                                            this,
                                            a,
                                            this.pointerup.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            o,
                                            this.pointerdown.bind(this)
                                        ),
                                        __privateAdd(this, l, new Map()),
                                        __privateAdd(this, c, !1),
                                        __privateAdd(this, u, !1),
                                        __privateAdd(this, d, !1),
                                        __privateAdd(this, p, void 0);
                                    const E = [
                                        S.FreeTextEditor,
                                        w.InkEditor,
                                        R.StampEditor,
                                    ];
                                    if (!e._initialized) {
                                        e._initialized = !0;
                                        for (const e of E) e.initialize(_);
                                    }
                                    t.registerEditorTypes(E),
                                        __privateSet(this, p, t),
                                        (this.pageIndex = n),
                                        (this.div = f),
                                        __privateSet(this, r, g),
                                        __privateSet(this, s, v),
                                        (this.viewport = y),
                                        __privateGet(this, p).addLayer(this);
                                }
                                get isEmpty() {
                                    return 0 === __privateGet(this, l).size;
                                }
                                updateToolbar(e) {
                                    __privateGet(this, p).updateToolbar(e);
                                }
                                updateMode(
                                    e = __privateGet(this, p).getMode()
                                ) {
                                    __privateMethod(this, b, y).call(this),
                                        e === _.AnnotationEditorType.INK
                                            ? (this.addInkEditorIfNeeded(!1),
                                              this.disableClick())
                                            : this.enableClick(),
                                        e !== _.AnnotationEditorType.NONE &&
                                            (this.div.classList.toggle(
                                                "freeTextEditing",
                                                e ===
                                                    _.AnnotationEditorType
                                                        .FREETEXT
                                            ),
                                            this.div.classList.toggle(
                                                "inkEditing",
                                                e === _.AnnotationEditorType.INK
                                            ),
                                            this.div.classList.toggle(
                                                "stampEditing",
                                                e ===
                                                    _.AnnotationEditorType.STAMP
                                            ),
                                            (this.div.hidden = !1));
                                }
                                addInkEditorIfNeeded(e) {
                                    if (
                                        e ||
                                        __privateGet(this, p).getMode() ===
                                            _.AnnotationEditorType.INK
                                    ) {
                                        if (!e)
                                            for (const e of __privateGet(
                                                this,
                                                l
                                            ).values())
                                                if (e.isEmpty())
                                                    return void e.setInBackground();
                                        __privateMethod(this, m, g)
                                            .call(
                                                this,
                                                { offsetX: 0, offsetY: 0 },
                                                !1
                                            )
                                            .setInBackground();
                                    }
                                }
                                setEditingState(e) {
                                    __privateGet(this, p).setEditingState(e);
                                }
                                addCommands(e) {
                                    __privateGet(this, p).addCommands(e);
                                }
                                enable() {
                                    this.div.style.pointerEvents = "auto";
                                    const e = new Set();
                                    for (const n of __privateGet(
                                        this,
                                        l
                                    ).values())
                                        n.enableEditing(),
                                            n.annotationElementId &&
                                                e.add(n.annotationElementId);
                                    if (!__privateGet(this, s)) return;
                                    const t = __privateGet(
                                        this,
                                        s
                                    ).getEditableAnnotations();
                                    for (const n of t) {
                                        if (
                                            (n.hide(),
                                            __privateGet(
                                                this,
                                                p
                                            ).isDeletedAnnotationElement(
                                                n.data.id
                                            ))
                                        )
                                            continue;
                                        if (e.has(n.data.id)) continue;
                                        const t = this.deserialize(n);
                                        t &&
                                            (this.addOrRebuild(t),
                                            t.enableEditing());
                                    }
                                }
                                disable() {
                                    var e;
                                    __privateSet(this, d, !0),
                                        (this.div.style.pointerEvents = "none");
                                    const t = new Set();
                                    for (const n of __privateGet(
                                        this,
                                        l
                                    ).values())
                                        n.disableEditing(),
                                            n.annotationElementId &&
                                            null === n.serialize()
                                                ? (null ==
                                                      (e =
                                                          this.getEditableAnnotation(
                                                              n.annotationElementId
                                                          )) || e.show(),
                                                  n.remove())
                                                : t.add(n.annotationElementId);
                                    if (__privateGet(this, s)) {
                                        const e = __privateGet(
                                            this,
                                            s
                                        ).getEditableAnnotations();
                                        for (const n of e) {
                                            const { id: e } = n.data;
                                            t.has(e) ||
                                                __privateGet(
                                                    this,
                                                    p
                                                ).isDeletedAnnotationElement(
                                                    e
                                                ) ||
                                                n.show();
                                        }
                                    }
                                    __privateMethod(this, b, y).call(this),
                                        this.isEmpty && (this.div.hidden = !0),
                                        __privateSet(this, d, !1);
                                }
                                getEditableAnnotation(e) {
                                    var t;
                                    return (
                                        (null == (t = __privateGet(this, s))
                                            ? void 0
                                            : t.getEditableAnnotation(e)) ||
                                        null
                                    );
                                }
                                setActiveEditor(e) {
                                    __privateGet(this, p).getActive() !== e &&
                                        __privateGet(this, p).setActiveEditor(
                                            e
                                        );
                                }
                                enableClick() {
                                    this.div.addEventListener(
                                        "pointerdown",
                                        __privateGet(this, o)
                                    ),
                                        this.div.addEventListener(
                                            "pointerup",
                                            __privateGet(this, a)
                                        );
                                }
                                disableClick() {
                                    this.div.removeEventListener(
                                        "pointerdown",
                                        __privateGet(this, o)
                                    ),
                                        this.div.removeEventListener(
                                            "pointerup",
                                            __privateGet(this, a)
                                        );
                                }
                                attach(e) {
                                    __privateGet(this, l).set(e.id, e);
                                    const { annotationElementId: t } = e;
                                    t &&
                                        __privateGet(
                                            this,
                                            p
                                        ).isDeletedAnnotationElement(t) &&
                                        __privateGet(
                                            this,
                                            p
                                        ).removeDeletedAnnotationElement(e);
                                }
                                detach(e) {
                                    var t;
                                    __privateGet(this, l).delete(e.id),
                                        null == (t = __privateGet(this, r)) ||
                                            t.removePointerInTextLayer(
                                                e.contentDiv
                                            ),
                                        !__privateGet(this, d) &&
                                            e.annotationElementId &&
                                            __privateGet(
                                                this,
                                                p
                                            ).addDeletedAnnotationElement(e);
                                }
                                remove(e) {
                                    this.detach(e),
                                        __privateGet(this, p).removeEditor(e),
                                        e.div.contains(
                                            document.activeElement
                                        ) &&
                                            setTimeout(() => {
                                                __privateGet(
                                                    this,
                                                    p
                                                ).focusMainContainer();
                                            }, 0),
                                        e.div.remove(),
                                        (e.isAttachedToDOM = !1),
                                        __privateGet(this, u) ||
                                            this.addInkEditorIfNeeded(!1);
                                }
                                changeParent(e) {
                                    var t;
                                    e.parent !== this &&
                                        (e.annotationElementId &&
                                            (__privateGet(
                                                this,
                                                p
                                            ).addDeletedAnnotationElement(
                                                e.annotationElementId
                                            ),
                                            E.AnnotationEditor.deleteAnnotationElement(
                                                e
                                            ),
                                            (e.annotationElementId = null)),
                                        this.attach(e),
                                        null == (t = e.parent) || t.detach(e),
                                        e.setParent(this),
                                        e.div &&
                                            e.isAttachedToDOM &&
                                            (e.div.remove(),
                                            this.div.append(e.div)));
                                }
                                add(e) {
                                    if (
                                        (this.changeParent(e),
                                        __privateGet(this, p).addEditor(e),
                                        this.attach(e),
                                        !e.isAttachedToDOM)
                                    ) {
                                        const t = e.render();
                                        this.div.append(t),
                                            (e.isAttachedToDOM = !0);
                                    }
                                    e.fixAndSetPosition(),
                                        e.onceAdded(),
                                        __privateGet(
                                            this,
                                            p
                                        ).addToAnnotationStorage(e);
                                }
                                moveEditorInDOM(e) {
                                    var t;
                                    if (!e.isAttachedToDOM) return;
                                    const { activeElement: n } = document;
                                    e.div.contains(n) &&
                                        ((e._focusEventsAllowed = !1),
                                        setTimeout(() => {
                                            e.div.contains(
                                                document.activeElement
                                            )
                                                ? (e._focusEventsAllowed = !0)
                                                : (e.div.addEventListener(
                                                      "focusin",
                                                      () => {
                                                          e._focusEventsAllowed =
                                                              !0;
                                                      },
                                                      { once: !0 }
                                                  ),
                                                  n.focus());
                                        }, 0)),
                                        (e._structTreeParentId =
                                            null == (t = __privateGet(this, r))
                                                ? void 0
                                                : t.moveElementInDOM(
                                                      this.div,
                                                      e.div,
                                                      e.contentDiv,
                                                      !0
                                                  ));
                                }
                                addOrRebuild(e) {
                                    e.needsToBeRebuilt()
                                        ? e.rebuild()
                                        : this.add(e);
                                }
                                addUndoableEditor(e) {
                                    this.addCommands({
                                        cmd: () => e._uiManager.rebuild(e),
                                        undo: () => {
                                            e.remove();
                                        },
                                        mustExec: !1,
                                    });
                                }
                                getNextId() {
                                    return __privateGet(this, p).getId();
                                }
                                pasteEditor(e, t) {
                                    __privateGet(this, p).updateToolbar(e),
                                        __privateGet(this, p).updateMode(e);
                                    const { offsetX: n, offsetY: r } =
                                            __privateMethod(this, x, v).call(
                                                this
                                            ),
                                        i = this.getNextId(),
                                        s = __privateMethod(this, h, f).call(
                                            this,
                                            {
                                                parent: this,
                                                id: i,
                                                x: n,
                                                y: r,
                                                uiManager: __privateGet(
                                                    this,
                                                    p
                                                ),
                                                isCentered: !0,
                                                ...t,
                                            }
                                        );
                                    s && this.add(s);
                                }
                                deserialize(e) {
                                    switch (
                                        e.annotationType ??
                                        e.annotationEditorType
                                    ) {
                                        case _.AnnotationEditorType.FREETEXT:
                                            return S.FreeTextEditor.deserialize(
                                                e,
                                                this,
                                                __privateGet(this, p)
                                            );
                                        case _.AnnotationEditorType.INK:
                                            return w.InkEditor.deserialize(
                                                e,
                                                this,
                                                __privateGet(this, p)
                                            );
                                        case _.AnnotationEditorType.STAMP:
                                            return R.StampEditor.deserialize(
                                                e,
                                                this,
                                                __privateGet(this, p)
                                            );
                                    }
                                    return null;
                                }
                                addNewEditor() {
                                    __privateMethod(this, m, g).call(
                                        this,
                                        __privateMethod(this, x, v).call(this),
                                        !0
                                    );
                                }
                                setSelected(e) {
                                    __privateGet(this, p).setSelected(e);
                                }
                                toggleSelected(e) {
                                    __privateGet(this, p).toggleSelected(e);
                                }
                                isSelected(e) {
                                    return __privateGet(this, p).isSelected(e);
                                }
                                unselect(e) {
                                    __privateGet(this, p).unselect(e);
                                }
                                pointerup(e) {
                                    const { isMac: t } = _.FeatureTest.platform;
                                    0 !== e.button ||
                                        (e.ctrlKey && t) ||
                                        (e.target === this.div &&
                                            __privateGet(this, c) &&
                                            (__privateSet(this, c, !1),
                                            __privateGet(this, i)
                                                ? __privateGet(
                                                      this,
                                                      p
                                                  ).getMode() !==
                                                  _.AnnotationEditorType.STAMP
                                                    ? __privateMethod(
                                                          this,
                                                          m,
                                                          g
                                                      ).call(this, e, !1)
                                                    : __privateGet(
                                                          this,
                                                          p
                                                      ).unselectAll()
                                                : __privateSet(this, i, !0)));
                                }
                                pointerdown(e) {
                                    if (__privateGet(this, c))
                                        return void __privateSet(this, c, !1);
                                    const { isMac: t } = _.FeatureTest.platform;
                                    if (0 !== e.button || (e.ctrlKey && t))
                                        return;
                                    if (e.target !== this.div) return;
                                    __privateSet(this, c, !0);
                                    const n = __privateGet(this, p).getActive();
                                    __privateSet(this, i, !n || n.isEmpty());
                                }
                                findNewParent(e, t, n) {
                                    const r = __privateGet(this, p).findParent(
                                        t,
                                        n
                                    );
                                    return (
                                        null !== r &&
                                        r !== this &&
                                        (r.changeParent(e), !0)
                                    );
                                }
                                destroy() {
                                    var e, t;
                                    (null ==
                                    (e = __privateGet(this, p).getActive())
                                        ? void 0
                                        : e.parent) === this &&
                                        (__privateGet(this, p).commitOrRemove(),
                                        __privateGet(this, p).setActiveEditor(
                                            null
                                        ));
                                    for (const n of __privateGet(
                                        this,
                                        l
                                    ).values())
                                        null == (t = __privateGet(this, r)) ||
                                            t.removePointerInTextLayer(
                                                n.contentDiv
                                            ),
                                            n.setParent(null),
                                            (n.isAttachedToDOM = !1),
                                            n.div.remove();
                                    (this.div = null),
                                        __privateGet(this, l).clear(),
                                        __privateGet(this, p).removeLayer(this);
                                }
                                render({ viewport: e }) {
                                    (this.viewport = e),
                                        (0, A.setLayerDimensions)(this.div, e);
                                    for (const t of __privateGet(
                                        this,
                                        p
                                    ).getEditors(this.pageIndex))
                                        this.add(t);
                                    this.updateMode();
                                }
                                update({ viewport: e }) {
                                    __privateGet(this, p).commitOrRemove(),
                                        (this.viewport = e),
                                        (0, A.setLayerDimensions)(this.div, {
                                            rotation: e.rotation,
                                        }),
                                        this.updateMode();
                                }
                                get pageDimensions() {
                                    const { pageWidth: e, pageHeight: t } =
                                        this.viewport.rawDims;
                                    return [e, t];
                                }
                            };
                            (r = new WeakMap()),
                                (i = new WeakMap()),
                                (s = new WeakMap()),
                                (a = new WeakMap()),
                                (o = new WeakMap()),
                                (l = new WeakMap()),
                                (c = new WeakMap()),
                                (u = new WeakMap()),
                                (d = new WeakMap()),
                                (p = new WeakMap()),
                                (h = new WeakSet()),
                                (f = function (e) {
                                    switch (__privateGet(this, p).getMode()) {
                                        case _.AnnotationEditorType.FREETEXT:
                                            return new S.FreeTextEditor(e);
                                        case _.AnnotationEditorType.INK:
                                            return new w.InkEditor(e);
                                        case _.AnnotationEditorType.STAMP:
                                            return new R.StampEditor(e);
                                    }
                                    return null;
                                }),
                                (m = new WeakSet()),
                                (g = function (e, t) {
                                    const n = this.getNextId(),
                                        r = __privateMethod(this, h, f).call(
                                            this,
                                            {
                                                parent: this,
                                                id: n,
                                                x: e.offsetX,
                                                y: e.offsetY,
                                                uiManager: __privateGet(
                                                    this,
                                                    p
                                                ),
                                                isCentered: t,
                                            }
                                        );
                                    return r && this.add(r), r;
                                }),
                                (x = new WeakSet()),
                                (v = function () {
                                    const {
                                            x: e,
                                            y: t,
                                            width: n,
                                            height: r,
                                        } = this.div.getBoundingClientRect(),
                                        i = Math.max(0, e),
                                        s = Math.max(0, t),
                                        a =
                                            (i +
                                                Math.min(
                                                    window.innerWidth,
                                                    e + n
                                                )) /
                                                2 -
                                            e,
                                        o =
                                            (s +
                                                Math.min(
                                                    window.innerHeight,
                                                    t + r
                                                )) /
                                                2 -
                                            t,
                                        [l, c] =
                                            this.viewport.rotation % 180 == 0
                                                ? [a, o]
                                                : [o, a];
                                    return { offsetX: l, offsetY: c };
                                }),
                                (b = new WeakSet()),
                                (y = function () {
                                    __privateSet(this, u, !0);
                                    for (const e of __privateGet(
                                        this,
                                        l
                                    ).values())
                                        e.isEmpty() && e.remove();
                                    __privateSet(this, u, !1);
                                }),
                                __publicField(C, "_initialized", !1);
                            let j = C;
                            t.AnnotationEditorLayer = j;
                        },
                        (e, t, n) => {
                            var r,
                                i,
                                s,
                                a,
                                o,
                                l,
                                c,
                                u,
                                d,
                                p,
                                h,
                                f,
                                m,
                                g,
                                x,
                                v,
                                b,
                                y,
                                _,
                                E,
                                S,
                                w,
                                A;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.FreeTextEditor = void 0);
                            var R = n(1),
                                C = n(5),
                                j = n(4),
                                k = n(29);
                            const P = class e extends j.AnnotationEditor {
                                constructor(t) {
                                    super({ ...t, name: "freeTextEditor" }),
                                        __privateAdd(this, p),
                                        __privateAdd(this, f),
                                        __privateAdd(this, g),
                                        __privateAdd(this, v),
                                        __privateAdd(this, y),
                                        __privateAdd(this, E),
                                        __privateAdd(this, w),
                                        __privateAdd(
                                            this,
                                            r,
                                            this.editorDivBlur.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            i,
                                            this.editorDivFocus.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            s,
                                            this.editorDivInput.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            a,
                                            this.editorDivKeydown.bind(this)
                                        ),
                                        __privateAdd(this, o, void 0),
                                        __privateAdd(this, l, ""),
                                        __privateAdd(
                                            this,
                                            c,
                                            `${this.id}-editor`
                                        ),
                                        __privateAdd(this, u, void 0),
                                        __privateAdd(this, d, null),
                                        __privateSet(
                                            this,
                                            o,
                                            t.color ||
                                                e._defaultColor ||
                                                j.AnnotationEditor
                                                    ._defaultLineColor
                                        ),
                                        __privateSet(
                                            this,
                                            u,
                                            t.fontSize || e._defaultFontSize
                                        );
                                }
                                static get _keyboardManager() {
                                    const t = e.prototype,
                                        n = (e) => e.isEmpty(),
                                        r =
                                            C.AnnotationEditorUIManager
                                                .TRANSLATE_SMALL,
                                        i =
                                            C.AnnotationEditorUIManager
                                                .TRANSLATE_BIG;
                                    return (0, R.shadow)(
                                        this,
                                        "_keyboardManager",
                                        new C.KeyboardManager([
                                            [
                                                [
                                                    "ctrl+s",
                                                    "mac+meta+s",
                                                    "ctrl+p",
                                                    "mac+meta+p",
                                                ],
                                                t.commitOrRemove,
                                                { bubbles: !0 },
                                            ],
                                            [
                                                [
                                                    "ctrl+Enter",
                                                    "mac+meta+Enter",
                                                    "Escape",
                                                    "mac+Escape",
                                                ],
                                                t.commitOrRemove,
                                            ],
                                            [
                                                ["ArrowLeft", "mac+ArrowLeft"],
                                                t._translateEmpty,
                                                { args: [-r, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowLeft",
                                                    "mac+shift+ArrowLeft",
                                                ],
                                                t._translateEmpty,
                                                { args: [-i, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ArrowRight",
                                                    "mac+ArrowRight",
                                                ],
                                                t._translateEmpty,
                                                { args: [r, 0], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowRight",
                                                    "mac+shift+ArrowRight",
                                                ],
                                                t._translateEmpty,
                                                { args: [i, 0], checker: n },
                                            ],
                                            [
                                                ["ArrowUp", "mac+ArrowUp"],
                                                t._translateEmpty,
                                                { args: [0, -r], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowUp",
                                                    "mac+shift+ArrowUp",
                                                ],
                                                t._translateEmpty,
                                                { args: [0, -i], checker: n },
                                            ],
                                            [
                                                ["ArrowDown", "mac+ArrowDown"],
                                                t._translateEmpty,
                                                { args: [0, r], checker: n },
                                            ],
                                            [
                                                [
                                                    "ctrl+ArrowDown",
                                                    "mac+shift+ArrowDown",
                                                ],
                                                t._translateEmpty,
                                                { args: [0, i], checker: n },
                                            ],
                                        ])
                                    );
                                }
                                static initialize(e) {
                                    j.AnnotationEditor.initialize(e, {
                                        strings: [
                                            "free_text2_default_content",
                                            "editor_free_text2_aria_label",
                                        ],
                                    });
                                    const t = getComputedStyle(
                                        document.documentElement
                                    );
                                    this._internalPadding = parseFloat(
                                        t.getPropertyValue("--freetext-padding")
                                    );
                                }
                                static updateDefaultParams(t, n) {
                                    switch (t) {
                                        case R.AnnotationEditorParamsType
                                            .FREETEXT_SIZE:
                                            e._defaultFontSize = n;
                                            break;
                                        case R.AnnotationEditorParamsType
                                            .FREETEXT_COLOR:
                                            e._defaultColor = n;
                                    }
                                }
                                updateParams(e, t) {
                                    switch (e) {
                                        case R.AnnotationEditorParamsType
                                            .FREETEXT_SIZE:
                                            __privateMethod(this, p, h).call(
                                                this,
                                                t
                                            );
                                            break;
                                        case R.AnnotationEditorParamsType
                                            .FREETEXT_COLOR:
                                            __privateMethod(this, f, m).call(
                                                this,
                                                t
                                            );
                                    }
                       (S = new WeakMap()),
                                (w = new WeakMap()),
                                (A = new WeakSet()),
                                (R = function (e) {
                                    e.altKey ||
                                        e.shiftKey ||
                                        e.ctrlKey ||
                                        e.metaKey ||
                                        (("Enter" === e.key ||
                                            ("Escape" === e.key &&
                                                __privateGet(this, b))) &&
                                            __privateMethod(this, C, j).call(
                                                this
                                            ));
                                }),
                                (C = new WeakSet()),
                                (j = function () {
                                    __privateSet(
                                        this,
                                        b,
                                        !__privateGet(this, b)
                                    ),
                                        __privateGet(this, b)
                                            ? (__privateMethod(this, k, P).call(
                                                  this
                                              ),
                                              __privateGet(
                                                  this,
                                                  f
                                              ).addEventListener(
                                                  "click",
                                                  __privateGet(this, p)
                                              ),
                                              __privateGet(
                                                  this,
                                                  f
                                              ).addEventListener(
                                                  "keydown",
                                                  __privateGet(this, c)
                                              ))
                                            : (__privateMethod(this, T, M).call(
                                                  this
                                              ),
                                              __privateGet(
                                                  this,
                                                  f
                                              ).removeEventListener(
                                                  "click",
                                                  __privateGet(this, p)
                                              ),
                                              __privateGet(
                                                  this,
                                                  f
                                              ).removeEventListener(
                                                  "keydown",
                                                  __privateGet(this, c)
                                              ));
                                }),
                                (k = new WeakSet()),
                                (P = function () {
                                    __privateGet(this, y) || this.render(),
                                        this.isVisible
                                            ? __privateGet(this, b) &&
                                              __privateGet(
                                                  this,
                                                  f
                                              ).classList.add("focused")
                                            : ((__privateGet(this, f).hidden =
                                                  !1),
                                              (__privateGet(
                                                  this,
                                                  f
                                              ).style.zIndex =
                                                  parseInt(
                                                      __privateGet(this, f)
                                                          .style.zIndex
                                                  ) + 1e3));
                                }),
                                (T = new WeakSet()),
                                (M = function () {
                                    __privateGet(this, f).classList.remove(
                                        "focused"
                                    ),
                                        !__privateGet(this, b) &&
                                            this.isVisible &&
                                            ((__privateGet(this, f).hidden =
                                                !0),
                                            (__privateGet(
                                                this,
                                                f
                                            ).style.zIndex =
                                                parseInt(
                                                    __privateGet(this, f).style
                                                        .zIndex
                                                ) - 1e3));
                                });
                            class ge extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        (this.textContent = e.data.textContent),
                                        (this.textPosition =
                                            e.data.textPosition),
                                        (this.annotationEditorType =
                                            K.AnnotationEditorType.FREETEXT);
                                }
                                render() {
                                    if (
                                        (this.container.classList.add(
                                            "freeTextAnnotation"
                                        ),
                                        this.textContent)
                                    ) {
                                        const e = document.createElement("div");
                                        e.classList.add(
                                            "annotationTextContent"
                                        ),
                                            e.setAttribute("role", "comment");
                                        for (const t of this.textContent) {
                                            const n =
                                                document.createElement("span");
                                            (n.textContent = t), e.append(n);
                                        }
                                        this.container.append(e);
                                    }
                                    return (
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this._editOnDoubleClick(),
                                        this.container
                                    );
                                }
                            }
                            t.FreeTextAnnotationElement = ge;
                            class xe extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        __privateAdd(this, $, null);
                                }
                                render() {
                                    this.container.classList.add(
                                        "lineAnnotation"
                                    );
                                    const e = this.data,
                                        { width: t, height: n } = ne(e.rect),
                                        r = this.svgFactory.create(t, n, !0),
                                        i = __privateSet(
                                            this,
                                            $,
                                            this.svgFactory.createElement(
                                                "svg:line"
                                            )
                                        );
                                    return (
                                        i.setAttribute(
                                            "x1",
                                            e.rect[2] - e.lineCoordinates[0]
                                        ),
                                        i.setAttribute(
                                            "y1",
                                            e.rect[3] - e.lineCoordinates[1]
                                        ),
                                        i.setAttribute(
                                            "x2",
                                            e.rect[2] - e.lineCoordinates[2]
                                        ),
                                        i.setAttribute(
                                            "y2",
                                            e.rect[3] - e.lineCoordinates[3]
                                        ),
                                        i.setAttribute(
                                            "stroke-width",
                                            e.borderStyle.width || 1
                                        ),
                                        i.setAttribute("stroke", "transparent"),
                                        i.setAttribute("fill", "transparent"),
                                        r.append(i),
                                        this.container.append(r),
                                        !e.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, $);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            $ = new WeakMap();
                            class ve extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        __privateAdd(this, O, null);
                                }
                                render() {
                                    this.container.classList.add(
                                        "squareAnnotation"
                                    );
                                    const e = this.data,
                                        { width: t, height: n } = ne(e.rect),
                                        r = this.svgFactory.create(t, n, !0),
                                        i = e.borderStyle.width,
                                        s = __privateSet(
                                            this,
                                            O,
                                            this.svgFactory.createElement(
                                                "svg:rect"
                                            )
                                        );
                                    return (
                                        s.setAttribute("x", i / 2),
                                        s.setAttribute("y", i / 2),
                                        s.setAttribute("width", t - i),
                                        s.setAttribute("height", n - i),
                                        s.setAttribute("stroke-width", i || 1),
                                        s.setAttribute("stroke", "transparent"),
                                        s.setAttribute("fill", "transparent"),
                                        r.append(s),
                                        this.container.append(r),
                                        !e.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, O);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            O = new WeakMap();
                            class be extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        __privateAdd(this, I, null);
                                }
                                render() {
                                    this.container.classList.add(
                                        "circleAnnotation"
                                    );
                                    const e = this.data,
                                        { width: t, height: n } = ne(e.rect),
                                        r = this.svgFactory.create(t, n, !0),
                                        i = e.borderStyle.width,
                                        s = __privateSet(
                                            this,
                                            I,
                                            this.svgFactory.createElement(
                                                "svg:ellipse"
                                            )
                                        );
                                    return (
                                        s.setAttribute("cx", t / 2),
                                        s.setAttribute("cy", n / 2),
                                        s.setAttribute("rx", t / 2 - i / 2),
                                        s.setAttribute("ry", n / 2 - i / 2),
                                        s.setAttribute("stroke-width", i || 1),
                                        s.setAttribute("stroke", "transparent"),
                                        s.setAttribute("fill", "transparent"),
                                        r.append(s),
                                        this.container.append(r),
                                        !e.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, I);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            I = new WeakMap();
                            class ye extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        __privateAdd(this, D, null),
                                        (this.containerClassName =
                                            "polylineAnnotation"),
                                        (this.svgElementName = "svg:polyline");
                                }
                                render() {
                                    this.container.classList.add(
                                        this.containerClassName
                                    );
                                    const e = this.data,
                                        { width: t, height: n } = ne(e.rect),
                                        r = this.svgFactory.create(t, n, !0);
                                    let i = [];
                                    for (const a of e.vertices) {
                                        const t = a.x - e.rect[0],
                                            n = e.rect[3] - a.y;
                                        i.push(t + "," + n);
                                    }
                                    i = i.join(" ");
                                    const s = __privateSet(
                                        this,
                                        D,
                                        this.svgFactory.createElement(
                                            this.svgElementName
                                        )
                                    );
                                    return (
                                        s.setAttribute("points", i),
                                        s.setAttribute(
                                            "stroke-width",
                                            e.borderStyle.width || 1
                                        ),
                                        s.setAttribute("stroke", "transparent"),
                                        s.setAttribute("fill", "transparent"),
                                        r.append(s),
                                        this.container.append(r),
                                        !e.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, D);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            D = new WeakMap();
                            class _e extends ye {
                                constructor(e) {
                                    super(e),
                                        (this.containerClassName =
                                            "polygonAnnotation"),
                                        (this.svgElementName = "svg:polygon");
                                }
                            }
                            class Ee extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    });
                                }
                                render() {
                                    return (
                                        this.container.classList.add(
                                            "caretAnnotation"
                                        ),
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                            }
                            class Se extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    }),
                                        __privateAdd(this, N, []),
                                        (this.containerClassName =
                                            "inkAnnotation"),
                                        (this.svgElementName = "svg:polyline"),
                                        (this.annotationEditorType =
                                            K.AnnotationEditorType.INK);
                                }
                                render() {
                                    this.container.classList.add(
                                        this.containerClassName
                                    );
                                    const e = this.data,
                                        { width: t, height: n } = ne(e.rect),
                                        r = this.svgFactory.create(t, n, !0);
                                    for (const i of e.inkLists) {
                                        let t = [];
                                        for (const r of i) {
                                            const n = r.x - e.rect[0],
                                                i = e.rect[3] - r.y;
                                            t.push(`${n},${i}`);
                                        }
                                        t = t.join(" ");
                                        const n = this.svgFactory.createElement(
                                            this.svgElementName
                                        );
                                        __privateGet(this, N).push(n),
                                            n.setAttribute("points", t),
                                            n.setAttribute(
                                                "stroke-width",
                                                e.borderStyle.width || 1
                                            ),
                                            n.setAttribute(
                                                "stroke",
                                                "transparent"
                                            ),
                                            n.setAttribute(
                                                "fill",
                                                "transparent"
                                            ),
                                            !e.popupRef &&
                                                this.hasPopupData &&
                                                this._createPopup(),
                                            r.append(n);
                                    }
                                    return (
                                        this.container.append(r), this.container
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, N);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            (N = new WeakMap()), (t.InkAnnotationElement = Se);
                            class we extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                        createQuadrilaterals: !0,
                                    });
                                }
                                render() {
                                    return (
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container.classList.add(
                                            "highlightAnnotation"
                                        ),
                                        this.container
                                    );
                                }
                            }
                            class Ae extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                        createQuadrilaterals: !0,
                                    });
                                }
                                render() {
                                    return (
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container.classList.add(
                                            "underlineAnnotation"
                                        ),
                                        this.container
                                    );
                                }
                            }
                            class Re extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                        createQuadrilaterals: !0,
                                    });
                                }
                                render() {
                                    return (
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container.classList.add(
                                            "squigglyAnnotation"
                                        ),
                                        this.container
                                    );
                                }
                            }
                            class Ce extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                        createQuadrilaterals: !0,
                                    });
                                }
                                render() {
                                    return (
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container.classList.add(
                                            "strikeoutAnnotation"
                                        ),
                                        this.container
                                    );
                                }
                            }
                            class je extends ie {
                                constructor(e) {
                                    super(e, {
                                        isRenderable: !0,
                                        ignoreBorder: !0,
                                    });
                                }
                                render() {
                                    return (
                                        this.container.classList.add(
                                            "stampAnnotation"
                                        ),
                                        !this.data.popupRef &&
                                            this.hasPopupData &&
                                            this._createPopup(),
                                        this.container
                                    );
                                }
                            }
                            t.StampAnnotationElement = je;
                            class ke extends ie {
                                constructor(e) {
                                    var t;
                                    super(e, { isRenderable: !0 }),
                                        __privateAdd(this, L),
                                        __privateAdd(this, F, null);
                                    const { filename: n, content: r } =
                                        this.data.file;
                                    (this.filename = (0, Y.getFilenameFromUrl)(
                                        n,
                                        !0
                                    )),
                                        (this.content = r),
                                        null ==
                                            (t = this.linkService.eventBus) ||
                                            t.dispatch(
                                                "fileattachmentannotation",
                                                {
                                                    source: this,
                                                    filename: n,
                                                    content: r,
                                                }
                                            );
                                }
                                render() {
                                    this.container.classList.add(
                                        "fileAttachmentAnnotation"
                                    );
                                    const { container: e, data: t } = this;
                                    let n;
                                    t.hasAppearance || 0 === t.fillAlpha
                                        ? (n = document.createElement("div"))
                                        : ((n = document.createElement("img")),
                                          (n.src = `${
                                              this.imageResourcesPath
                                          }annotation-${
                                              /paperclip/i.test(t.name)
                                                  ? "paperclip"
                                                  : "pushpin"
                                          }.svg`),
                                          t.fillAlpha &&
                                              t.fillAlpha < 1 &&
                                              (n.style = `filter: opacity(${Math.round(
                                                  100 * t.fillAlpha
                                              )}%);`)),
                                        n.addEventListener(
                                            "dblclick",
                                            __privateMethod(this, L, B).bind(
                                                this
                                            )
                                        ),
                                        __privateSet(this, F, n);
                                    const { isMac: r } = K.FeatureTest.platform;
                                    return (
                                        e.addEventListener("keydown", (e) => {
                                            "Enter" === e.key &&
                                                (r ? e.metaKey : e.ctrlKey) &&
                                                __privateMethod(
                                                    this,
                                                    L,
                                                    B
                                                ).call(this);
                                        }),
                                        !t.popupRef && this.hasPopupData
                                            ? this._createPopup()
                                            : n.classList.add(
                                                  "popupTriggerArea"
                                              ),
                                        e.append(n),
                                        e
                                    );
                                }
                                getElementsToTriggerPopup() {
                                    return __privateGet(this, F);
                                }
                                addHighlightArea() {
                                    this.container.classList.add(
                                        "highlightArea"
                                    );
                                }
                            }
                            (F = new WeakMap()),
                                (L = new WeakSet()),
                                (B = function () {
                                    var e;
                                    null == (e = this.downloadManager) ||
                                        e.openOrDownloadData(
                                            this.container,
                                            this.content,
                                            this.filename
                                        );
                                }),
                                (U = new WeakMap()),
                                (z = new WeakMap()),
                                (W = new WeakMap()),
                                (G = new WeakSet()),
                                (V = function (e, t) {
                                    var n;
                                    const r = e.firstChild || e;
                                    (r.id = `${K.AnnotationPrefix}${t}`),
                                        this.div.append(e),
                                        null == (n = __privateGet(this, U)) ||
                                            n.moveElementInDOM(
                                                this.div,
                                                e,
                                                r,
                                                !1
                                            );
                                }),
                                (H = new WeakSet()),
                                (q = function () {
                                    if (!__privateGet(this, z)) return;
                                    const e = this.div;
                                    for (const [t, n] of __privateGet(
                                        this,
                                        z
                                    )) {
                                        const r = e.querySelector(
                                            `[data-annotation-id="${t}"]`
                                        );
                                        if (!r) continue;
                                        const { firstChild: i } = r;
                                        i
                                            ? "CANVAS" === i.nodeName
                                                ? i.replaceWith(n)
                                                : i.before(n)
                                            : r.append(n);
                                    }
                                    __privateGet(this, z).clear();
                                }),
                                (t.AnnotationLayer = class {
                                    constructor({
                                        div: e,
                                        accessibilityManager: t,
                                        annotationCanvasMap: n,
                                        l10n: r,
                                        page: i,
                                        viewport: s,
                                    }) {
                                        __privateAdd(this, G),
                                            __privateAdd(this, H),
                                            __privateAdd(this, U, null),
                                            __privateAdd(this, z, null),
                                            __privateAdd(this, W, new Map()),
                                            (this.div = e),
                                            __privateSet(this, U, t),
                                            __privateSet(this, z, n),
                                            (this.l10n = r),
                                            (this.page = i),
                                            (this.viewport = s),
                                            (this.zIndex = 0),
                                            this.l10n ||
                                                (this.l10n = J.NullL10n);
                                    }
                                    async render(e) {
                                        const { annotations: t } = e,
                                            n = this.div;
                                        (0, Y.setLayerDimensions)(
                                            n,
                                            this.viewport
                                        );
                                        const r = new Map(),
                                            i = {
                                                data: null,
                                                layer: n,
                                                linkService: e.linkService,
                                                downloadManager:
                                                    e.downloadManager,
                                                imageResourcesPath:
                                                    e.imageResourcesPath || "",
                                                renderForms:
                                                    !1 !== e.renderForms,
                                                svgFactory:
                                                    new Y.DOMSVGFactory(),
                                                annotationStorage:
                                                    e.annotationStorage ||
                                                    new X.AnnotationStorage(),
                                                enableScripting:
                                                    !0 === e.enableScripting,
                                                hasJSActions: e.hasJSActions,
                                                fieldObjects: e.fieldObjects,
                                                parent: this,
                                                elements: null,
                                            };
                                        for (const s of t) {
                                            if (s.noHTML) continue;
                                            const e =
                                                s.annotationType ===
                                                K.AnnotationType.POPUP;
                                            if (e) {
                                                const e = r.get(s.id);
                                                if (!e) continue;
                                                i.elements = e;
                                            } else {
                                                const { width: e, height: t } =
                                                    ne(s.rect);
                                                if (e <= 0 || t <= 0) continue;
                                            }
                                            i.data = s;
                                            const t = re.create(i);
                                            if (!t.isRenderable) continue;
                                            if (!e && s.popupRef) {
                                                const e = r.get(s.popupRef);
                                                e
                                                    ? e.push(t)
                                                    : r.set(s.popupRef, [t]);
                                            }
                                            t.annotationEditorType > 0 &&
                                                __privateGet(this, W).set(
                                                    t.data.id,
                                                    t
                                                );
                                            const n = t.render();
                                            s.hidden &&
                                                (n.style.visibility = "hidden"),
                                                __privateMethod(
                                                    this,
                                                    G,
                                                    V
                                                ).call(this, n, s.id);
                                        }
                                        __privateMethod(this, H, q).call(this),
                                            await this.l10n.translate(n);
                                    }
                                    update({ viewport: e }) {
                                        const t = this.div;
                                        (this.viewport = e),
                                            (0, Y.setLayerDimensions)(t, {
                                                rotation: e.rotation,
                                            }),
                                            __privateMethod(this, H, q).call(
                                                this
                                            ),
                                            (t.hidden = !1);
                                    }
                                    getEditableAnnotations() {
                                        return Array.from(
                                            __privateGet(this, W).values()
                                        );
                                    }
                                    getEditableAnnotation(e) {
                                        return __privateGet(this, W).get(e);
                                    }
                                });
                        },
                        (e, t) => {
                            function n(e) {
                                return Math.floor(
                                    255 * Math.max(0, Math.min(1, e))
                                )
                                    .toString(16)
                                    .padStart(2, "0");
                            }
                            function r(e) {
                                return Math.max(0, Math.min(255, 255 * e));
                            }
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.ColorConverters = void 0),
                                (t.ColorConverters = class {
                                    static CMYK_G([e, t, n, r]) {
                                        return [
                                            "G",
                                            1 -
                                                Math.min(
                                                    1,
                                                    0.3 * e +
                                                        0.59 * n +
                                                        0.11 * t +
                                                        r
                                                ),
                                        ];
                                    }
                                    static G_CMYK([e]) {
                                        return ["CMYK", 0, 0, 0, 1 - e];
                                    }
                                    static G_RGB([e]) {
                                        return ["RGB", e, e, e];
                                    }
                                    static G_rgb([e]) {
                                        return [(e = r(e)), e, e];
                                    }
                                    static G_HTML([e]) {
                                        const t = n(e);
                                        return `#${t}${t}${t}`;
                                    }
                                    static RGB_G([e, t, n]) {
                                        return [
                                            "G",
                                            0.3 * e + 0.59 * t + 0.11 * n,
                                        ];
                                    }
                                    static RGB_rgb(e) {
                                        return e.map(r);
                                    }
                                    static RGB_HTML(e) {
                                        return `#${e.map(n).join("")}`;
                                    }
                                    static T_HTML() {
                                        return "#00000000";
                                    }
                                    static T_rgb() {
                                        return [null];
                                    }
                                    static CMYK_RGB([e, t, n, r]) {
                                        return [
                                            "RGB",
                                            1 - Math.min(1, e + r),
                                            1 - Math.min(1, n + r),
                                            1 - Math.min(1, t + r),
                                        ];
                                    }
                                    static CMYK_rgb([e, t, n, i]) {
                                        return [
                                            r(1 - Math.min(1, e + i)),
                                            r(1 - Math.min(1, n + i)),
                                            r(1 - Math.min(1, t + i)),
                                        ];
                                    }
                                    static CMYK_HTML(e) {
                                        const t = this.CMYK_RGB(e).slice(1);
                                        return this.RGB_HTML(t);
                                    }
                                    static RGB_CMYK([e, t, n]) {
                                        const r = 1 - e,
                                            i = 1 - t,
                                            s = 1 - n;
                                        return [
                                            "CMYK",
                                            r,
                                            i,
                                            s,
                                            Math.min(r, i, s),
                                        ];
                                    }
                                });
                        },
                        (e, t) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.NullL10n = void 0),
                                (t.getL10nFallback = r);
                            const n = {
                                of_pages: "of {{pagesCount}}",
                                page_of_pages:
                                    "({{pageNumber}} of {{pagesCount}})",
                                document_properties_kb:
                                    "{{size_kb}} KB ({{size_b}} bytes)",
                                document_properties_mb:
                                    "{{size_mb}} MB ({{size_b}} bytes)",
                                document_properties_date_string:
                                    "{{date}}, {{time}}",
                                document_properties_page_size_unit_inches: "in",
                                document_properties_page_size_unit_millimeters:
                                    "mm",
                                document_properties_page_size_orientation_portrait:
                                    "portrait",
                                document_properties_page_size_orientation_landscape:
                                    "landscape",
                                document_properties_page_size_name_a3: "A3",
                                document_properties_page_size_name_a4: "A4",
                                document_properties_page_size_name_letter:
                                    "Letter",
                                document_properties_page_size_name_legal:
                                    "Legal",
                                document_properties_page_size_dimension_string:
                                    "{{width}} × {{height}} {{unit}} ({{orientation}})",
                                document_properties_page_size_dimension_name_string:
                                    "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
                                document_properties_linearized_yes: "Yes",
                                document_properties_linearized_no: "No",
                                additional_layers: "Additional Layers",
                                page_landmark: "Page {{page}}",
                                thumb_page_title: "Page {{page}}",
                                thumb_page_canvas: "Thumbnail of Page {{page}}",
                                find_reached_top:
                                    "Reached top of document, continued from bottom",
                                find_reached_bottom:
                                    "Reached end of document, continued from top",
                                "find_match_count[one]":
                                    "{{current}} of {{total}} match",
                                "find_match_count[other]":
                                    "{{current}} of {{total}} matches",
                                "find_match_count_limit[one]":
                                    "More than {{limit}} match",
                                "find_match_count_limit[other]":
                                    "More than {{limit}} matches",
                                find_not_found: "Phrase not found",
                                page_scale_width: "Page Width",
                                page_scale_fit: "Page Fit",
                                page_scale_auto: "Automatic Zoom",
                                page_scale_actual: "Actual Size",
                                page_scale_percent: "{{scale}}%",
                                loading_error:
                                    "An error occurred while loading the PDF.",
                                invalid_file_error:
                                    "Invalid or corrupted PDF file.",
                                missing_file_error: "Missing PDF file.",
                                unexpected_response_error:
                                    "Unexpected server response.",
                                rendering_error:
                                    "An error occurred while rendering the page.",
                                annotation_date_string: "{{date}}, {{time}}",
                                printing_not_supported:
                                    "Warning: Printing is not fully supported by this browser.",
                                printing_not_ready:
                                    "Warning: The PDF is not fully loaded for printing.",
                                web_fonts_disabled:
                                    "Web fonts are disabled: unable to use embedded PDF fonts.",
                                free_text2_default_content: "Start typing…",
                                editor_free_text2_aria_label: "Text Editor",
                                editor_ink2_aria_label: "Draw Editor",
                                editor_ink_canvas_aria_label:
                                    "User-created image",
                                editor_alt_text_button_label: "Alt text",
                                editor_alt_text_edit_button_label:
                                    "Edit alt text",
                                editor_alt_text_decorative_tooltip:
                                    "Marked as decorative",
                            };
                            function r(e, t) {
                                switch (e) {
                                    case "find_match_count":
                                        e = `find_match_count[${
                                            1 === t.total ? "one" : "other"
                                        }]`;
                                        break;
                                    case "find_match_count_limit":
                                        e = `find_match_count_limit[${
                                            1 === t.limit ? "one" : "other"
                                        }]`;
                                }
                                return n[e] || "";
                            }
                            n.print_progress_percent = "{{progress}}%";
                            const i = {
                                getLanguage: async () => "en-us",
                                getDirection: async () => "ltr",
                                get: async (e, t = null, n = r(e, t)) =>
                                    (function (e, t) {
                                        return t
                                            ? e.replaceAll(
                                                  /\{\{\s*(\w+)\s*\}\}/g,
                                                  (e, n) =>
                                                      n in t
                                                          ? t[n]
                                                          : "{{" + n + "}}"
                                              )
                                            : e;
                                    })(n, t),
                                async translate(e) {},
                            };
                            t.NullL10n = i;
                        },
                        (e, t, n) => {
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.XfaLayer = void 0);
                            var r = n(25);
                            t.XfaLayer = class {
                                static setupStorage(e, t, n, r, i) {
                                    const s = r.getValue(t, { value: null });
                                    switch (n.name) {
                                        case "textarea":
                                            if (
                                                (null !== s.value &&
                                                    (e.textContent = s.value),
                                                "print" === i)
                                            )
                                                break;
                                            e.addEventListener("input", (e) => {
                                                r.setValue(t, {
                                                    value: e.target.value,
                                                });
                                            });
                                            break;
                                        case "input":
                                            if (
                                                "radio" === n.attributes.type ||
                                                "checkbox" === n.attributes.type
                                            ) {
                                                if (
                                                    (s.value ===
                                                    n.attributes.xfaOn
                                                        ? e.setAttribute(
                                                              "checked",
                                                              !0
                                                          )
                                                        : s.value ===
                                                              n.attributes
                                                                  .xfaOff &&
                                                          e.removeAttribute(
                                                              "checked"
                                                          ),
                                                    "print" === i)
                                                )
                                                    break;
                                                e.addEventListener(
                                                    "change",
                                                    (e) => {
                                                        r.setValue(t, {
                                                            value: e.target
                                                                .checked
                                                                ? e.target.getAttribute(
                                                                      "xfaOn"
                                                                  )
                                                                : e.target.getAttribute(
                                                                      "xfaOff"
                                                                  ),
                                                        });
                                                    }
                                                );
                                            } else {
                                                if (
                                                    (null !== s.value &&
                                                        e.setAttribute(
                                                            "value",
                                                            s.value
                                                        ),
                                                    "print" === i)
                                                )
                                                    break;
                                                e.addEventListener(
                                                    "input",
                                                    (e) => {
                                                        r.setValue(t, {
                                                            value: e.target
                                                                .value,
                                                        });
                                                    }
                                                );
                                            }
                                            break;
                                        case "select":
                                            if (null !== s.value) {
                                                e.setAttribute(
                                                    "value",
                                                    s.value
                                                );
                                                for (const e of n.children)
                                                    e.attributes.value ===
                                                    s.value
                                                        ? (e.attributes.selected =
                                                              !0)
                                                        : e.attributes.hasOwnProperty(
                                                              "selected"
                                                          ) &&
                                                          delete e.attributes
                                                              .selected;
                                            }
                                            e.addEventListener("input", (e) => {
                                                const n = e.target.options,
                                                    i =
                                                        -1 === n.selectedIndex
                                                                       "data-element-id",
                                                        l
                                                    );
                                                    break;
                                                case "style":
                                                    Object.assign(e.style, l);
                                                    break;
                                                case "textContent":
                                                    e.textContent = l;
                                                    break;
                                                default:
                                                    (!a ||
                                                        ("href" !== o &&
                                                            "newWindow" !==
                                                                o)) &&
                                                        e.setAttribute(o, l);
                                            }
                                    a &&
                                        i.addLinkAttributes(
                                            e,
                                            s.href,
                                            s.newWindow
                                        ),
                                        n &&
                                            s.dataId &&
                                            this.setupStorage(
                                                e,
                                                s.dataId,
                                                t,
                                                n
                                            );
                                }
                                static render(e) {
                                    var t;
                                    const n = e.annotationStorage,
                                        i = e.linkService,
                                        s = e.xfaHtml,
                                        a = e.intent || "display",
                                        o = document.createElement(s.name);
                                    s.attributes &&
                                        this.setAttributes({
                                            html: o,
                                            element: s,
                                            intent: a,
                                            linkService: i,
                                        });
                                    const l = [[s, -1, o]],
                                        c = e.div;
                                    if ((c.append(o), e.viewport)) {
                                        const t = `matrix(${e.viewport.transform.join(
                                            ","
                                        )})`;
                                        c.style.transform = t;
                                    }
                                    "richText" !== a &&
                                        c.setAttribute(
                                            "class",
                                            "xfaLayer xfaFont"
                                        );
                                    const u = [];
                                    for (; l.length > 0; ) {
                                        const [e, s, o] = l.at(-1);
                                        if (s + 1 === e.children.length) {
                                            l.pop();
                                            continue;
                                        }
                                        const c = e.children[++l.at(-1)[1]];
                                        if (null === c) continue;
                                        const { name: d } = c;
                                        if ("#text" === d) {
                                            const e = document.createTextNode(
                                                c.value
                                            );
                                            u.push(e), o.append(e);
                                            continue;
                                        }
                                        const p = (
                                            null ==
                                            (t =
                                                null == c
                                                    ? void 0
                                                    : c.attributes)
                                                ? void 0
                                                : t.xmlns
                                        )
                                            ? document.createElementNS(
                                                  c.attributes.xmlns,
                                                  d
                                              )
                                            : document.createElement(d);
                                        if (
                                            (o.append(p),
                                            c.attributes &&
                                                this.setAttributes({
                                                    html: p,
                                                    element: c,
                                                    storage: n,
                                                    intent: a,
                                                    linkService: i,
                                                }),
                                            c.children && c.children.length > 0)
                                        )
                                            l.push([c, -1, p]);
                                        else if (c.value) {
                                            const e = document.createTextNode(
                                                c.value
                                            );
                                            r.XfaText.shouldBuildText(d) &&
                                                u.push(e),
                                                p.append(e);
                                        }
                                    }
                                    for (const r of c.querySelectorAll(
                                        ".xfaNonInteractive input, .xfaNonInteractive textarea"
                                    ))
                                        r.setAttribute("readOnly", !0);
                                    return { textDivs: u };
                                }
                                static update(e) {
                                    const t = `matrix(${e.viewport.transform.join(
                                        ","
                                    )})`;
                                    (e.div.style.transform = t),
                                        (e.div.hidden = !1);
                                }
                            };
                        },
                        (e, t, n) => {
                            var r,
                                i,
                                s,
                                a,
                                o,
                                l,
                                c,
                                u,
                                d,
                                p,
                                h,
                                f,
                                m,
                                g,
                                x,
                                v,
                                b,
                                y,
                                _,
                                E,
                                S,
                                w,
                                A,
                                R,
                                C,
                                j,
                                k,
                                P,
                                T,
                                M,
                                $,
                                O,
                                I,
                                D,
                                N,
                                F,
                                L,
                                B,
                                U,
                                z,
                                W,
                                G,
                                V,
                                H,
                                q,
                                K,
                                Y,
                                X,
                                Q,
                                J,
                                Z,
                                ee,
                                te,
                                ne,
                                re,
                                ie,
                                se,
                                ae,
                                oe,
                                le,
                                ce,
                                ue,
                                de,
                                pe,
                                he,
                                fe;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.InkEditor = void 0);
                            var me = n(1),
                                ge = n(4),
                                xe = n(29),
                                ve = n(6),
                                be = n(5);
                            const ye = class e extends ge.AnnotationEditor {
                                constructor(e) {
                                    super({ ...e, name: "inkEditor" }),
                                        __privateAdd(this, x),
                                        __privateAdd(this, b),
                                        __privateAdd(this, _),
                                        __privateAdd(this, S),
                                        __privateAdd(this, A),
                                        __privateAdd(this, C),
                                        __privateAdd(this, k),
                                        __privateAdd(this, T),
                                        __privateAdd(this, $),
                                        __privateAdd(this, I),
                                        __privateAdd(this, N),
                                        __privateAdd(this, L),
                                        __privateAdd(this, U),
                                        __privateAdd(this, W),
                                        __privateAdd(this, V),
                                        __privateAdd(this, q),
                                        __privateAdd(this, Y),
                                        __privateAdd(this, Q),
                                        __privateAdd(this, Z),
                                        __privateAdd(this, oe),
                                        __privateAdd(this, ce),
                                        __privateAdd(this, de),
                                        __privateAdd(this, he),
                                        __privateAdd(this, r, 0),
                                        __privateAdd(this, i, 0),
                                        __privateAdd(
                                            this,
                                            s,
                                            this.canvasPointermove.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            a,
                                            this.canvasPointerleave.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            o,
                                            this.canvasPointerup.bind(this)
                                        ),
                                        __privateAdd(
                                            this,
                                            l,
                                            this.canvasPointerdown.bind(this)
                                        ),
                                        __privateAdd(this, c, new Path2D()),
                                        __privateAdd(this, u, !1),
                                        __privateAdd(this, d, !1),
                                        __privateAdd(this, p, !1),
                                        __privateAdd(this, h, null),
                                        __privateAdd(this, f, 0),
                                        __privateAdd(this, m, 0),
                                        __privateAdd(this, g, null),
                                        (this.color = e.color || null),
                                        (this.thickness = e.thickness || null),
                                        (this.opacity = e.opacity || null),
                                        (this.paths = []),
                                        (this.bezierPath2D = []),
                                        (this.allRawPaths = []),
                                        (this.currentPath = []),
                                        (this.scaleFactor = 1),
                                        (this.translationX = this.translationY =
                                            0),
                                        (this.x = 0),
                                        (this.y = 0),
                                        (this._willKeepAspectRatio = !0);
                                }
                                static initialize(e) {
                                    ge.AnnotationEditor.initialize(e, {
                                        strings: [
                                            "editor_ink_canvas_aria_label",
                                            "editor_ink2_aria_label",
                                        ],
                                    });
                                }
                                static updateDefaultParams(t, n) {
                                    switch (t) {
                                        case me.AnnotationEditorParamsType
                                            .INK_THICKNESS:
                                            e._defaultThickness = n;
                                            break;
                                        case me.AnnotationEditorParamsType
                                            .INK_COLOR:
                                            e._defaultColor = n;
                                            break;
                                        case me.AnnotationEditorParamsType
                                            .INK_OPACITY:
                                            e._defaultOpacity = n / 100;
                                    }
                                }
                                updateParams(e, t) {
                                    switch (e) {
                                        case me.AnnotationEditorParamsType
                                            .INK_THICKNESS:
                                            __privateMethod(this, x, v).call(
                                                this,
                                                t
                                            );
                                            break;
                                        case me.AnnotationEditorParamsType
                                            .INK_COLOR:
                                            __privateMethod(this, b, y).call(
                                                this,
                                                t
                                            );
                                            break;
                                        case me.AnnotationEditorParamsType
                                            .INK_OPACITY:
                                            __privateMethod(this, _, E).call(
                                                this,
                                                t
                                            );
                                    }
                                }
                                static get defaultPropertiesToUpdate() {
                                    return [
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_THICKNESS,
                                            e._defaultThickness,
                                        ],
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_COLOR,
                                            e._defaultColor ||
                                                ge.AnnotationEditor
                                                    ._defaultLineColor,
                                        ],
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_OPACITY,
                                            Math.round(100 * e._defaultOpacity),
                                        ],
                                    ];
                                }
                                get propertiesToUpdate() {
                                    return [
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_THICKNESS,
                                            this.thickness ||
                                                e._defaultThickness,
                                        ],
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_COLOR,
                                            this.color ||
                                                e._defaultColor ||
                                                ge.AnnotationEditor
                                                    ._defaultLineColor,
                                        ],
                                        [
                                            me.AnnotationEditorParamsType
                                                .INK_OPACITY,
                                            Math.round(
                                                100 *
                                                    (this.opacity ??
                                                        e._defaultOpacity)
                                            ),
                                        ],
                                    ];
                                }
                                rebuild() {
                                    this.parent &&
                                        (super.rebuild(),
                                        null !== this.div &&
                                            (this.canvas ||
                                                (__privateMethod(
                                                    this,
                                                    V,
                                                    H
                                                ).call(this),
                                                __privateMethod(
                                                    this,
                                                    q,
                                                    K
                                                ).call(this)),
                                            this.isAttachedToDOM ||
                                                (this.parent.add(this),
                                                __privateMethod(
                                                    this,
                                                    Y,
                                                    X
                                                ).call(this)),
                                            __privateMethod(this, he, fe).call(
                                                this
                                            )));
                                }
                                remove() {
                                    null !== this.canvas &&
                                        (this.isEmpty() || this.commit(),
                                        (this.canvas.width =
                                            this.canvas.height =
                                                0),
                                        this.canvas.remove(),
                                        (this.canvas = null),
                                        __privateGet(this, h).disconnect(),
                                        __privateSet(this, h, null),
                                        super.remove());
                                }
                                setParent(e) {
                                    !this.parent && e
                                        ? this._uiManager.removeShouldRescale(
                                              this
                                          )
                                        : this.parent &&
                                          null === e &&
                                          this._uiManager.addShouldRescale(
                                              this
                                          ),
                                        super.setParent(e);
                                }
                                onScaleChanging() {
                                    const [e, t] = this.parentDimensions,
                                        n = this.width * e,
                                        r = this.height * t;
                                    this.setDimensions(n, r);
                                }
                                enableEditMode() {
                                    __privateGet(this, u) ||
                                        null === this.canvas ||
                                        (super.enableEditMode(),
                                        (this._isDraggable = !1),
                                        this.canvas.addEventListener(
                                            "pointerdown",
                                            __privateGet(this, l)
                                        ));
                                }
                                disableEditMode() {
                                    this.isInEditMode() &&
                                        null !== this.canvas &&
                                        (super.disableEditMode(),
                                        (this._isDraggable = !this.isEmpty()),
                                        this.div.classList.remove("editing"),
                                        this.canvas.removeEventListener(
                                            "pointerdown",
                                            __privateGet(this, l)
                                        ));
                                }
                                onceAdded() {
                                    this._isDraggable = !this.isEmpty();
                                }
                                isEmpty() {
                                    return (
                                        0 === this.paths.length ||
                                        (1 === this.paths.length &&
                                            0 === this.paths[0].length)
                                    );
                                }
                                commit() {
                                    __privateGet(this, u) ||
                                        (super.commit(),
                                        (this.isEditing = !1),
                                        this.disableEditMode(),
                                        this.setInForeground(),
                                        __privateSet(this, u, !0),
                                        this.div.classList.add("disabled"),
                                        __privateMethod(this, he, fe).call(
                                            this,
                                            !0
                                        ),
                                        this.makeResizable(),
                                        this.parent.addInkEditorIfNeeded(!0),
                                        this.moveInDOM(),
                                        this.div.focus({ preventScroll: !0 }));
                                }
                                focusin(e) {
                                    this._focusEventsAllowed &&
                                        (super.focusin(e),
                                        this.enableEditMode());
                                }
                                canvasPointerdown(e) {
                                    0 === e.button &&
                                        this.isInEditMode() &&
                                        !__privateGet(this, u) &&
                                        (this.setInForeground(),
                                        e.preventDefault(),
                                        "mouse" !== e.type && this.div.focus(),
                                        __privateMethod(this, C, j).call(
                                            this,
                                            e.offsetX,
                                            e.offsetY
                                        ));
                                }
                                canvasPointermove(e) {
                                    e.preventDefault(),
                                        __privateMethod(this, k, P).call(
                                            this,
                                            e.offsetX,
                                            e.offsetY
                                        );
                                }
                                canvasPointerup(e) {
                                    e.preventDefault(),
                                        __privateMethod(this, W, G).call(
                                            this,
                                            e
                                        );
                                }
                                canvasPointerleave(e) {
                                    __privateMethod(this, W, G).call(this, e);
                                }
                                get isResizable() {
                                    return (
                                        !this.isEmpty() && __privateGet(this, u)
                                    );
                                }
                                render() {
                                    if (this.div) return this.div;
                                    let e, t;
                                    this.width && ((e = this.x), (t = this.y)),
                                        super.render(),
                                        ge.AnnotationEditor._l10nPromise
                                            .get("editor_ink2_aria_label")
                                            .then((e) => {
                                                var t;
                                                return null == (t = this.div)
                                                    ? void 0
                                                    : t.setAttribute(
                                                          "aria-label",
                                                          e
                                                      );
                                            });
                                    const [n, r, i, s] = __privateMethod(
                                        this,
                                        S,
                                        w
                                    ).call(this);
                                    if (
                                        (this.setAt(n, r, 0, 0),
                                        this.setDims(i, s),
                                        __privateMethod(this, V, H).call(this),
                                        this.width)
                                    ) {
                                        const [n, r] = this.parentDimensions;
                                        this.setAspectRatio(
                                            this.width * n,
                                            this.height * r
                                        ),
                                            this.setAt(
                                                e * n,
                                                t * r,
                                                this.width * n,
                                                this.height * r
                                            ),
                                            __privateSet(this, p, !0),
                                            __privateMethod(this, Y, X).call(
                                                this
                                            ),
                                            this.setDims(
                                                this.width * n,
                                                this.height * r
                                            ),
                                            __privateMethod(this, U, z).call(
                                                this
                                            ),
                                            this.div.classList.add("disabled");
                                    } else
                                        this.div.classList.add("editing"),
                                            this.enableEditMode();
                                    return (
                                        __privateMethod(this, q, K).call(this),
                                        this.div
                                    );
                                }
                                setDimensions(e, t) {
                                    const n = Math.round(e),
                                        r = Math.round(t);
                                    if (
                                        __privateGet(this, f) === n &&
                                        __privateGet(this, m) === r
                                    )
                                        return;
                                    __privateSet(this, f, n),
                                        __privateSet(this, m, r),
                                        (this.canvas.style.visibility =
                                            "hidden");
                                    const [i, s] = this.parentDimensions;
                                    (this.width = e / i),
                                        (this.height = t / s),
                                        this.fixAndSetPosition(),
                                        __privateGet(this, u) &&
                                            __privateMethod(this, Q, J).call(
                                                this,
                                                e,
                                                t
                                            ),
                                        __privateMethod(this, Y, X).call(this),
                                        __privateMethod(this, U, z).call(this),
                                        (this.canvas.style.visibility =
                                            "visible"),
                                        this.fixDims();
                                }
                                static deserialize(t, n, s) {
                                    var a, o, l;
                                    if (t instanceof xe.InkAnnotationElement)
                                        return null;
                                    const c = super.deserialize(t, n, s);
                                    (c.thickness = t.thickness),
                                        (c.color = me.Util.makeHexColor(
                                            ...t.color
                                        )),
                                        (c.opacity = t.opacity);
                                    const [d, p] = c.pageDimensions,
                                        h = c.width * d,
                                        g = c.height * p,
                                        x = c.parentScale,
                                        v = t.thickness / 2;
                                    __privateSet(c, u, !0),
                                        __privateSet(c, f, Math.round(h)),
                                        __privateSet(c, m, Math.round(g));
                                    const {
                                        paths: b,
                                        rect: y,
                                        rotation: _,
                                    } = t;
                                    for (let { bezier: r } of b) {
                                        r = __privateMethod(
                                            (a = e),
                                            se,
                                            ae
                                        ).call(a, r, y, _);
                                        const t = [];
                                        c.paths.push(t);
                                        let n = x * (r[0] - v),
                                            i = x * (r[1] - v);
                                        for (
                                            let e = 2, a = r.length;
                                            e < a;
                                            e += 6
                                        ) {
                                            const s = x * (r[e] - v),
                                                a = x * (r[e + 1] - v),
                                                o = x * (r[e + 2] - v),
                                                l = x * (r[e + 3] - v),
                                                c = x * (r[e + 4] - v),
                                                u = x * (r[e + 5] - v);
                                            t.push([
                                                [n, i],
                                                [s, a],
                                                [o, l],
                                                [c, u],
                                            ]),
                                                (n = c),
                                                (i = u);
                                        }
                                        const s = __privateMethod(
                                            this,
                                            te,
                                            ne
                                        ).call(this, t);
                                        c.bezierPath2D.push(s);
                                    }
                                    const E = __privateMethod(
                                        (o = c),
                                        ce,
                                        ue
                                    ).call(o);
                                    return (
                                        __privateSet(
                                            c,
                                            i,
                                            Math.max(
                                                ge.AnnotationEditor.MIN_SIZE,
                                                E[2] - E[0]
                                            )
                                        ),
                                        __privateSet(
                                            c,
                                            r,
                                            Math.max(
                                                ge.AnnotationEditor.MIN_SIZE,
                                                E[3] - E[1]
                                            )
                                        ),
                                        __privateMethod((l = c), Q, J).call(
                                            l,
                                            h,
                                            g
                                        ),
                                        c
                                    );
                                }
                                serialize() {
                                    if (this.isEmpty()) return null;
                                    const e = this.getRect(0, 0),
                                        t =
                                            ge.AnnotationEditor._colorManager.convert(
                                                this.ctx.strokeStyle
                                            );
                                    return {
                                        annotationType:
                                            me.AnnotationEditorType.INK,
                                        color: t,
                                        thickness: this.thickness,
                                        opacity: this.opacity,
                                        paths: __privateMethod(
                                            this,
                                            oe,
                                            le
                                        ).call(
                                            this,
                                            this.scaleFactor / this.parentScale,
                                            this.translationX,
                                            this.translationY,
                                            e
                                        ),
                                        pageIndex: this.pageIndex,
                                        rect: e,
                                        rotation: this.rotation,
                                        structTreeParentId:
                                            this._structTreeParentId,
                                    };
                                }
                            };
                            (r = new WeakMap()),
                                (i = new WeakMap()),
                                (s = new WeakMap()),
                                (a = new WeakMap()),
                                (o = new WeakMap()),
                                (l = new WeakMap()),
                                (c = new WeakMap()),
                                (u = new WeakMap()),
                                (d = new WeakMap()),
                                (p = new WeakMap()),
                                (h = new WeakMap()),
                                (f = new WeakMap()),
                                (m = new WeakMap()),
                                (g = new WeakMap()),
                                (x = new WeakSet()),
                                (v = function (e) {
                                    const t = this.thickness;
                                    this.addCommands({
                                        cmd: () => {
                                            (this.thickness = e),
                                                __privateMethod(
                                                    this,
                                                    he,
                                                    fe
                                                ).call(this);
                                        },
                                        undo: () => {
                                            (this.thickness = t),
                                                __privateMethod(
                                                    this,
                                                    he,
                                                    fe
                                                ).call(this);
                                        },
                                        mustExec: !0,
                                        type: me.AnnotationEditorParamsType
                                            .INK_THICKNESS,
                                        overwriteIfSameType: !0,
                                        keepUndo: !0,
                                    });
                                }),
                                (b = new WeakSet()),
                                (y = function (e) {
                                    const t = this.color;
                                    this.addCommands({
                                        cmd: () => {
                                            (this.color = e),
                                                __privateMethod(
                                                    this,
                                                    U,
                                                    z
                                                ).call(this);
                                        },
                                        undo: () => {
                                            (this.color = t),
                                                __privateMethod(
                                                    this,
                                                    U,
                                                    z
                                                ).call(this);
                                        },
                                        mustExec: !0,
                                        type: me.AnnotationEditorParamsType
                                            .INK_COLOR,
                                        overwriteIfSameType: !0,
                                        keepUndo: !0,
                                    });
                                }),
                                (_ = new WeakSet()),
                                (E = function (e) {
                                    e /= 100;
                                    const t = this.opacity;
                                    this.addCommands({
                                        cmd: () => {
                                            (this.opacity = e),
                                                __privateMethod(
                                                    this,
                                                    U,
                                                    z
                                                ).call(this);
                                        },
                                        undo: () => {
                                            (this.opacity = t),
                                                __privateMethod(
                                                    this,
                                                    U,
                                                    z
                                                ).call(this);
                                        },
                                        mustExec: !0,
                                        type: me.AnnotationEditorParamsType
                                            .INK_OPACITY,
                                        overwriteIfSameType: !0,
                                        keepUndo: !0,
                                    });
                                }),
                                (S = new WeakSet()),
                                (w = function () {
                                    const {
                                        parentRotation: e,
                                        parentDimensions: [t, n],
                                    } = this;
                                    switch (e) {
                                        case 90:
                                            return [0, n, n, t];
                                        case 180:
                                            return [t, n, t, n];
                                        case 270:
                                            return [t, 0, n, t];
                                        default:
                                            return [0, 0, t, n];
                                    }
                                }),
                                (A = new WeakSet()),
                                (R = function () {
                                    const {
                                        ctx: e,
                                        color: t,
                                        opacity: n,
                                        thickness: r,
                                        parentScale: i,
                                        scaleFactor: s,
                                    } = this;
                                    (e.lineWidth = (r * i) / s),
                                        (e.lineCap = "round"),
                                        (e.lineJoin = "round"),
                                        (e.miterLimit = 10),
                                        (e.strokeStyle = `${t}${(0,
                                        be.opacityToHex)(n)}`);
                                }),
                                (C = new WeakSet()),
                                (j = function (e, t) {
                                    this.canvas.addEventListener(
                                        "contextmenu",
                                        ve.noContextMenu
                                    ),
                                        this.canvas.addEventListener(
                                            "pointerleave",
                                            __privateGet(this, a)
                                        ),
                                        this.canvas.addEventListener(
                                            "pointermove",
                                            __privateGet(this, s)
                                        ),
                                        this.canvas.addEventListener(
                                            "pointerup",
                                            __privateGet(this, o)
                                        ),
                                        this.canvas.removeEventListener(
                                            "pointerdown",
                                            __privateGet(this, l)
                                        ),
                                        (this.isEditing = !0),
                                        __privateGet(this, p) ||
                                            (__privateSet(this, p, !0),
                                            __privateMethod(this, Y, X).call(
                                                this
                                            ),
                                            this.thickness ||
                                                (this.thickness =
                                                    ye._defaultThickness),
                                            this.color ||
                                                (this.color =
                                                    ye._defaultColor ||
                                                    ge.AnnotationEditor
                                                        ._defaultLineColor),
                                            this.opacity ??
                                                (this.opacity =
                                                    ye._defaultOpacity)),
                                        this.currentPath.push([e, t]),
                                        __privateSet(this, d, !1),
                                        __privateMethod(this, A, R).call(this),
                                        __privateSet(this, g, () => {
                                            __privateMethod(this, I, D).call(
                                                this
                                            ),
                                                __privateGet(this, g) &&
                                                    window.requestAnimationFrame(
                                                        __privateGet(this, g)
                                                    );
                                        }),
                                        window.requestAnimationFrame(
                                            __privateGet(this, g)
                                        );
                                }),
                                (k = new WeakSet()),
                                (P = function (e, t) {
                                    const [n, r] = this.currentPath.at(-1);
                                    if (
                                        this.currentPath.length > 1 &&
                                        e === n &&
                                        t === r
                                    )
                                        return;
                                    const i = this.currentPath;
                                    let s = __privateGet(this, c);
                                    if (
                                        (i.push([e, t]),
                                        __privateSet(this, d, !0),
                                        i.length <= 2)
                                    )
                                        return (
                                            s.moveTo(...i[0]),
                                            void s.lineTo(e, t)
                                        );
                                    3 === i.length &&
                                        (__privateSet(
                                            this,
                                            c,
                                            (s = new Path2D())
                                        ),
                                        s.moveTo(...i[0])),
                                        __privateMethod(this, N, F).call(
                                            this,
                                            s,
                                            ...i.at(-3),
                                            ...i.at(-2),
                                            e,
                                            t
                                        );
                                }),
                                (T = new WeakSet()),
                                (M = function () {
                                    if (0 === this.currentPath.length) return;
                                    const e = this.currentPath.at(-1);
                                    __privateGet(this, c).lineTo(...e);
                                }),
                                ($ = new WeakSet()),
                                (O = function (e, t) {
                                    let n;
                                    if (
                                        (__privateSet(this, g, null),
                                        (e = Math.min(
                                            Math.max(e, 0),
                                            this.canvas.width
                                        )),
                                        (t = Math.min(
                                            Math.max(t, 0),
                                            this.canvas.height
                                        )),
                                        __privateMethod(this, k, P).call(
                                            this,
                                            e,
                                            t
                                        ),
                                        __privateMethod(this, T, M).call(this),
                                        1 !== this.currentPath.length)
                                    )
                                        n = __privateMethod(this, L, B).call(
                                            this
                                        );
                                    else {
                                        const r = [e, t];
                                        n = [[r, r.slice(), r.slice(), r]];
                                    }
                                    const r = __privateGet(this, c),
                                        i = this.currentPath;
                                    (this.currentPath = []),
                                        __privateSet(this, c, new Path2D()),
                                        this.addCommands({
                                            cmd: () => {
                                                this.allRawPaths.push(i),
                                                    this.paths.push(n),
                                                    this.bezierPath2D.push(r),
                                                    this.rebuild();
                                            },
                                            undo: () => {
                                                this.allRawPaths.pop(),
                                                    this.paths.pop(),
                                                    this.bezierPath2D.pop(),
                                                    0 === this.paths.length
                                                        ? this.remove()
                                                        : (this.canvas ||
                                                              (__privateMethod(
                                                                  this,
                                                                  V,
                                                                  H
                                                              ).call(this),
                                                              __privateMethod(
                                                                  this,
                                                                  q,
                                                                  K
                                                              ).call(this)),
                                                          __privateMethod(
                                                              this,
                                                              he,
                                                              fe
                                                          ).call(this));
                                            },
                                            mustExec: !0,
                                        });
                                }),
                                (I = new WeakSet()),
                                (D = function () {
                                    if (!__privateGet(this, d)) return;
                                    __privateSet(this, d, !1),
                                        Math.ceil(
                                            this.thickness * this.parentScale
                                        );
                                    const e = this.currentPath.slice(-3),
                                        t = e.map((e) => e[0]),
                                        n = e.map((e) => e[1]);
                                    Math.min(...t),
                                        Math.max(...t),
                                        Math.min(...n),
                                        Math.max(...n);
                                    const { ctx: r } = this;
                                    r.save(),
                                        r.clearRect(
                                            0,
                                            0,
                                            this.canvas.width,
                                            this.canvas.height
                                        );
                                    for (const i of this.bezierPath2D)
                                        r.stroke(i);
                                    r.stroke(__privateGet(this, c)),
                                        r.restore();
                                }),
                                (N = new WeakSet()),
                                (F = function (e, t, n, r, i, s, a) {
                                    const o = (t + r) / 2,
                                        l = (n + i) / 2,
                                        c = (r + s) / 2,
                                        u = (i + a) / 2;
                                    e.bezierCurveTo(
                                        o + (2 * (r - o)) / 3,
                                        l + (2 * (i - l)) / 3,
                                        c + (2 * (r - c)) / 3,
                                        u + (2 * (i - u)) / 3,
                                        c,
                                        u
                                    );
                                }),
                                (L = new WeakSet()),
                                (B = function () {
                                    const e = this.currentPath;
                                    if (e.length <= 2)
                                        return [
                                            [e[0], e[0], e.at(-1), e.at(-1)],
                                        ];
                                    const t = [];
                                    let n,
                                        [r, i] = e[0];
                                    for (n = 1; n < e.length - 2; n++) {
                                        const [s, a] = e[n],
                                            [o, l] = e[n + 1],
                                            c = (s + o) / 2,
                                            u = (a + l) / 2,
                                            d = [
                                                r + (2 * (s - r)) / 3,
                                                i + (2 * (a - i)) / 3,
                                            ],
                                            p = [
                                                c + (2 * (s - c)) / 3,
                                                u + (2 * (a - u)) / 3,
                                            ];
                                        t.push([[r, i], d, p, [c, u]]),
                                            ([r, i] = [c, u]);
                                    }
                                    const [s, a] = e[n],
                                        [o, l] = e[n + 1],
                                        c = [
                                            r + (2 * (s - r)) / 3,
                                            i + (2 * (a - i)) / 3,
                                        ],
                                        u = [
                                            o + (2 * (s - o)) / 3,
                                            l + (2 * (a - l)) / 3,
                                        ];
                                    return t.push([[r, i], c, u, [o, l]]), t;
                                }),
                                (U = new WeakSet()),
                                (z = function () {
                                    if (this.isEmpty())
                                        return void __privateMethod(
                                            this,
                                            Z,
                                            ee
                                        ).call(this);
                                    __privateMethod(this, A, R).call(this);
                                    const { canvas: e, ctx: t } = this;
                                    t.setTransform(1, 0, 0, 1, 0, 0),
                                        t.clearRect(0, 0, e.width, e.height),
                                        __privateMethod(this, Z, ee).call(this);
                                    for (const n of this.bezierPath2D)
                                        t.stroke(n);
                                }),
                                (W = new WeakSet()),
                                (G = function (e) {
                                    this.canvas.removeEventListener(
                                        "pointerleave",
                                        __privateGet(this, a)
                                    ),
                                        this.canvas.removeEventListener(
                                            "pointermove",
                                            __privateGet(this, s)
                                        ),
                                        this.canvas.removeEventListener(
                                            "pointerup",
                                            __privateGet(this, o)
                                        ),
                                        this.canvas.addEventListener(
                                            "pointerdown",
                                            __privateGet(this, l)
                                    .append(this.canvas),
                                        (this.ctx =
                                            this.canvas.getContext("2d"));
                                }),
                                (q = new WeakSet()),
                                (K = function () {
                                    __privateSet(
                                        this,
                                        h,
                                        new ResizeObserver((e) => {
                                            const t = e[0].contentRect;
                                            t.width &&
                                                t.height &&
                                                this.setDimensions(
                                                    t.width,
                                                    t.height
                                                );
                                        })
                                    ),
                                        __privateGet(this, h).observe(this.div);
                                }),
                                (Y = new WeakSet()),
                                (X = function () {
                                    if (!__privateGet(this, p)) return;
                                    const [e, t] = this.parentDimensions;
                                    (this.canvas.width = Math.ceil(
                                        this.width * e
                                    )),
                                        (this.canvas.height = Math.ceil(
                                            this.height * t
                                        )),
                                        __privateMethod(this, Z, ee).call(this);
                                }),
                                (Q = new WeakSet()),
                                (J = function (e, t) {
                                    const n = __privateMethod(
                                            this,
                                            de,
                                            pe
                                        ).call(this),
                                        s = (e - n) / __privateGet(this, i),
                                        a = (t - n) / __privateGet(this, r);
                                    this.scaleFactor = Math.min(s, a);
                                }),
                                (Z = new WeakSet()),
                                (ee = function () {
                                    const e =
                                        __privateMethod(this, de, pe).call(
                                            this
                                        ) / 2;
                                    this.ctx.setTransform(
                                        this.scaleFactor,
                                        0,
                                        0,
                                        this.scaleFactor,
                                        this.translationX * this.scaleFactor +
                                            e,
                                        this.translationY * this.scaleFactor + e
                                    );
                                }),
                                (te = new WeakSet()),
                                (ne = function (e) {
                                    const t = new Path2D();
                                    for (let n = 0, r = e.length; n < r; n++) {
                                        const [r, i, s, a] = e[n];
                                        0 === n && t.moveTo(...r),
                                            t.bezierCurveTo(
                                                i[0],
                                                i[1],
                                                s[0],
                                                s[1],
                                                a[0],
                                                a[1]
                                            );
                                    }
                                    return t;
                                }),
                                (re = new WeakSet()),
                                (ie = function (e, t, n) {
                                    const [r, i, s, a] = t;
                                    switch (n) {
                                        case 0:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            )
                                                (e[t] += r),
                                                    (e[t + 1] = a - e[t + 1]);
                                            break;
                                        case 90:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            ) {
                                                const n = e[t];
                                                (e[t] = e[t + 1] + r),
                                                    (e[t + 1] = n + i);
                                            }
                                            break;
                                        case 180:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            )
                                                (e[t] = s - e[t]),
                                                    (e[t + 1] += i);
                                            break;
                                        case 270:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            ) {
                                                const n = e[t];
                                                (e[t] = s - e[t + 1]),
                                                    (e[t + 1] = a - n);
                                            }
                                            break;
                                        default:
                                            throw new Error("Invalid rotation");
                                    }
                                    return e;
                                }),
                                (se = new WeakSet()),
                                (ae = function (e, t, n) {
                                    const [r, i, s, a] = t;
                                    switch (n) {
                                        case 0:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            )
                                                (e[t] -= r),
                                                    (e[t + 1] = a - e[t + 1]);
                                            break;
                                        case 90:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            ) {
                                                const n = e[t];
                                                (e[t] = e[t + 1] - i),
                                                    (e[t + 1] = n - r);
                                            }
                                            break;
                                        case 180:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            )
                                                (e[t] = s - e[t]),
                                                    (e[t + 1] -= i);
                                            break;
                                        case 270:
                                            for (
                                                let t = 0, n = e.length;
                                                t < n;
                                                t += 2
                                            ) {
                                                const n = e[t];
                                                (e[t] = a - e[t + 1]),
                                                    (e[t + 1] = s - n);
                                            }
                                            break;
                                        default:
                                            throw new Error("Invalid rotation");
                                    }
                                    return e;
                                }),
                                (oe = new WeakSet()),
                                (le = function (e, t, n, r) {
                                    var i, s;
                                    const a = [],
                                        o = this.thickness / 2,
                                        l = e * t + o,
                                        c = e * n + o;
                                    for (const u of this.paths) {
                                        const t = [],
                                            n = [];
                                        for (
                                            let r = 0, i = u.length;
                                            r < i;
                                            r++
                                        ) {
                                            const [s, a, o, d] = u[r],
                                                p = e * s[0] + l,
                                                h = e * s[1] + c,
                                                f = e * a[0] + l,
                                                m = e * a[1] + c,
                                                g = e * o[0] + l,
                                                x = e * o[1] + c,
                                                v = e * d[0] + l,
                                                b = e * d[1] + c;
                                            0 === r &&
                                                (t.push(p, h), n.push(p, h)),
                                                t.push(f, m, g, x, v, b),
                                                n.push(f, m),
                                                r === i - 1 && n.push(v, b);
                                        }
                                        a.push({
                                            bezier: __privateMethod(
                                                (i = ye),
                                                re,
                                                ie
                                            ).call(i, t, r, this.rotation),
                                            points: __privateMethod(
                                                (s = ye),
                                                re,
                                                ie
                                            ).call(s, n, r, this.rotation),
                                        });
                                    }
                                    return a;
                                }),
                                (ce = new WeakSet()),
                                (ue = function () {
                                    let e = 1 / 0,
                                        t = -1 / 0,
                                        n = 1 / 0,
                                        r = -1 / 0;
                                    for (const i of this.paths)
                                        for (const [s, a, o, l] of i) {
                                            const i = me.Util.bezierBoundingBox(
                                                ...s,
                                                ...a,
                                                ...o,
                                                ...l
                                            );
                                            (e = Math.min(e, i[0])),
                                                (n = Math.min(n, i[1])),
                                                (t = Math.max(t, i[2])),
                                                (r = Math.max(r, i[3]));
                                        }
                                    return [e, n, t, r];
                                }),
                                (de = new WeakSet()),
                                (pe = function () {
                                    return __privateGet(this, u)
                                        ? Math.ceil(
                                              this.thickness * this.parentScale
                                          )
                                        : 0;
                                }),
                                (he = new WeakSet()),
                                (fe = function (e = !1) {
                                    if (this.isEmpty()) return;
                                    if (!__privateGet(this, u))
                                        return void __privateMethod(
                                            this,
                                            U,
                                            z
                                        ).call(this);
                                    const t = __privateMethod(
                                            this,
                                            ce,
                                            ue
                                        ).call(this),
                                        n = __privateMethod(this, de, pe).call(
                                            this
                                        );
                                    __privateSet(
                                        this,
                                        i,
                                        Math.max(
                                            ge.AnnotationEditor.MIN_SIZE,
                                            t[2] - t[0]
                                        )
                                    ),
                                        __privateSet(
                                            this,
                                            r,
                                            Math.max(
                                                ge.AnnotationEditor.MIN_SIZE,
                                                t[3] - t[1]
                                            )
                                        );
                                    const s = Math.ceil(
                                            n +
                                                __privateGet(this, i) *
                                                    this.scaleFactor
                                        ),
                                        a = Math.ceil(
                                            n +
                                                __privateGet(this, r) *
                                                    this.scaleFactor
                                        ),
                                        [o, l] = this.parentDimensions;
                                    (this.width = s / o),
                                        (this.height = a / l),
                                        this.setAspectRatio(s, a);
                                    const c = this.translationX,
                                        d = this.translationY;
                                    (this.translationX = -t[0]),
                                        (this.translationY = -t[1]),
                                        __privateMethod(this, Y, X).call(this),
                                        __privateMethod(this, U, z).call(this),
                                        __privateSet(this, f, s),
                                        __privateSet(this, m, a),
                                        this.setDims(s, a);
                                    const p = e ? n / this.scaleFactor / 2 : 0;
                                    this.translate(
                                        c - this.translationX - p,
                                        d - this.translationY - p
                                    );
                                }),
                                __privateAdd(ye, te),
                                __privateAdd(ye, re),
                                __privateAdd(ye, se),
                                __publicField(ye, "_defaultColor", null),
                                __publicField(ye, "_defaultOpacity", 1),
                                __publicField(ye, "_defaultThickness", 1),
                                __publicField(ye, "_type", "ink");
                            let _e = ye;
                            t.InkEditor = _e;
                        },
                        (e, t, n) => {
                            var r,
                                i,
                                s,
                                a,
                                o,
                                l,
                                c,
                                u,
                                d,
                                p,
                                h,
                                f,
                                m,
                                g,
                                x,
                                v,
                                b,
                                y,
                                _,
                                E,
                                S,
                                w,
                                A,
                                R,
                                C,
                                j,
                                k,
                                P;
                            Object.defineProperty(t, "__esModule", {
                                value: !0,
                            }),
                                (t.StampEditor = void 0);
                            var T = n(1),
                                M = n(4),
                                $ = n(6),
                                O = n(29);
                            const I = class extends M.AnnotationEditor {
                                constructor(e) {
                                    super({ ...e, name: "stampEditor" }),
                                        __privateAdd(this, h),
                                        __privateAdd(this, m),
                                        __privateAdd(this, x),
                                        __privateAdd(this, b),
                                        __privateAdd(this, _),
                                        __privateAdd(this, S),
                                        __privateAdd(this, A),
                                        __privateAdd(this, C),
                                        __privateAdd(this, k),
                                        __privateAdd(this, r, null),
                                        __privateAdd(this, i, null),
                                        __privateAdd(this, s, null),
                                        __privateAdd(this, a, null),
                                        __privateAdd(this, o, null),
                                        __privateAdd(this, l, null),
                                        __privateAdd(this, c, null),
                                        __privateAdd(this, u, null),
                                        __privateAdd(this, d, !1),
                                        __privateAdd(this, p, !1),
                                        __privateSet(this, a, e.bitmapUrl),
                                        __privateSet(this, o, e.bitmapFile);
                                }
                                static initialize(e) {
                                    M.AnnotationEditor.initialize(e);
                                }
                                static get supportedTypes() {
                                    return (0, T.shadow)(
                                        this,
                                        "supportedTypes",
                                        [
                                            "apng",
                                            "avif",
                                            "bmp",
                                            "gif",
                                            "jpeg",
                                            "png",
                                            "svg+xml",
                                            "webp",
                                            "x-icon",
                                        ].map((e) => `image/${e}`)
                                    );
                                }
                                static get supportedTypesStr() {
                                    return (0, T.shadow)(
                                        this,
                                        "supportedTypesStr",
                                        this.supportedTypes.join(",")
                                    );
                                }
                                static isHandlingMimeForPasting(e) {
                                    return this.supportedTypes.includes(e);
                                }
                                static paste(e, t) {
                                    t.pasteEditor(
                                        T.AnnotationEditorType.STAMP,
                                        { bitmapFile: e.getAsFile() }
                                    );
                                }
                                remove() {
                                    var e, t;
                                    __privateGet(this, i) &&
                                        (__privateSet(this, r, null),
                                        this._uiManager.imageManager.deleteId(
                                            __privateGet(this, i)
                                        ),
                                        null == (e = __privateGet(this, l)) ||
                                            e.remove(),
                                        __privateSet(this, l, null),
                                        null == (t = __privateGet(this, c)) ||
                                            t.disconnect(),
                                        __privateSet(this, c, null)),
                                        super.remove();
                                }
                                rebuild() {
                                    this.parent
                                        ? (super.rebuild(),
                                          null !== this.div &&
                                              (__privateGet(this, i) &&
                                                  __privateMethod(
                                                      this,
                                                      x,
                                                      v
                                                  ).call(this),
                                              this.isAttachedToDOM ||
                                                  this.parent.add(this)))
                                        : __privateGet(this, i) &&
                                          __privateMethod(this, x, v).call(
                                              this
                                          );
                                }
                                onceAdded() {
                                    (this._isDraggable = !0), this.div.focus();
                                }
                                isEmpty() {
                                    return !(
                                        __privateGet(this, s) ||
                                        __privateGet(this, r) ||
                                        __privateGet(this, a) ||
                                        __privateGet(this, o)
                                    );
                                }
                                get isResizable() {
                                    return !0;
                                }
                                render() {
                                    if (this.div) return this.div;
                                    let e, t;
                                    if (
                                        (this.width &&
                                            ((e = this.x), (t = this.y)),
                                        super.render(),
                                        (this.div.hidden = !0),
                                        __privateGet(this, r)
                                            ? __privateMethod(this, b, y).call(
                                                  this
                                              )
                                            : __privateMethod(this, x, v).call(
                                                  this
                                              ),
                                        this.width)
                                    ) {
                                        const [n, r] = this.parentDimensions;
                                        this.setAt(
                                            e * n,
                                            t * r,
                                            this.width * n,
                                            this.height * r
                                        );
                                    }
                                    return this.div;
                                }
                                static deserialize(e, t, n) {
                                    if (e instanceof O.StampAnnotationElement)
                                        return null;
                                    const r = super.deserialize(e, t, n),
                                        {
                                            rect: s,
                                            bitmapUrl: o,
                                            bitmapId: l,
                                            isSvg: c,
                                            accessibilityData: u,
                                        } = e;
                                    l && n.imageManager.isValidId(l)
                                        ? __privateSet(r, i, l)
                                        : __privateSet(r, a, o),
                                        __privateSet(r, d, c);
                                    const [p, h] = r.pageDimensions;
                                    return (
                                        (r.width = (s[2] - s[0]) / p),
                                        (r.height = (s[3] - s[1]) / h),
                                        u && (r.altTextData = u),
                                        r
                                    );
                                }
                                serialize(e = !1, t = null) {
                                    if (this.isEmpty()) return null;
                                    const n = {
                                        annotationType:
                                            T.AnnotationEditorType.STAMP,
                                        bitmapId: __privateGet(this, i),
                                        pageIndex: this.pageIndex,
                                        rect: this.getRect(0, 0),
                                        rotation: this.rotation,
                                        isSvg: __privateGet(this, d),
                                        structTreeParentId:
                                            this._structTreeParentId,
                                    };
                                    if (e)
                                        return (
                                            (n.bitmapUrl = __privateMethod(
                                                this,
                                                C,
                                                j
                                            ).call(this, !0)),
                                            (n.accessibilityData =
                                                this.altTextData),
                                            n
                                        );
                                    const { decorative: r, altText: s } =
                                        this.altTextData;
                                    if (
                                        (!r &&
                                            s &&
                                            (n.accessibilityData = {
                                                type: "Figure",
                                                alt: s,
                                            }),
                                        null === t)
                                    )
                                        return n;
                                    t.stamps || (t.stamps = new Map());
                                    const a = __privateGet(this, d)
                                        ? (n.rect[2] - n.rect[0]) *
                                          (n.rect[3] - n.rect[1])
                                        : null;
                                    if (t.stamps.has(__privateGet(this, i))) {
                                        if (__privateGet(this, d)) {
                                            const e = t.stamps.get(
                                                __privateGet(this, i)
                                            );
                                            a > e.area &&
                                                ((e.area = a),
                                                e.serialized.bitmap.close(),
                                                (e.serialized.bitmap =
                                                    __privateMethod(
                                                        this,
                                                        C,
                                                        j
                                                    ).call(this, !1)));
                                        }
                                    } else
                                        t.stamps.set(__privateGet(this, i), {
                                            area: a,
                                            serialized: n,
                                        }),
                                            (n.bitmap = __privateMethod(
                                                this,
                                                C,
                                                j
                                            ).call(this, !1));
                                    return n;
                                }
                            };
                            (r = new WeakMap()),
                                (i = new WeakMap()),
                                (s = new WeakMap()),
                                (a = new WeakMap()),
                                (o = new WeakMap()),
                                (l = new WeakMap()),
                                (c = new WeakMap()),
                                (u = new WeakMap()),
                                (d = new WeakMap()),
                                (p = new WeakMap()),
                                (h = new WeakSet()),
                                (f = function (e, t = !1) {
                                    e
                                        ? (__privateSet(this, r, e.bitmap),
                                          t ||
                                              (__privateSet(this, i, e.id),
                                              __privateSet(this, d, e.isSvg)),
                                          __privateMethod(this, b, y).call(
                                              this
                                          ))
                                        : this.remove();
                                }),
                                (m = new WeakSet()),
                                (g = function () {
                                    __privateSet(this, s, null),
                                        this._uiManager.enableWaiting(!1),
                                        __privateGet(this, l) &&
                                            this.div.focus();
                                }),
                                (x = new WeakSet()),
                                (v = function () {
                                    if (__privateGet(this, i))
                                        return (
                                            this._uiManager.enableWaiting(!0),
                                            void this._uiManager.imageManager
                                                .getFromId(
                                                    __privateGet(this, i)
                                                )
                                                .then((e) =>
                                                    __privateMethod(
                                                        this,
                                                        h,
                                                        f
                                                    ).call(this, e, !0)
                                                )
                                                .finally(() =>
                                                    __privateMethod(
                                                        this,
                                                        m,
                                                        g
                                                    ).call(this)
                                                )
                                        );
                                    if (__privateGet(this, a)) {
                                        const e = __privateGet(this, a);
                                        return (
                                            __privateSet(this, a, null),
                                            this._uiManager.enableWaiting(!0),
                                            void __privateSet(
                                                this,
                                                s,
                                                this._uiManager.imageManager
                                                    .getFromUrl(e)
                                                    .then((e) =>
                                                        __privateMethod(
                                                            this,
                                                            h,
                                                            f
                                                        ).call(this, e)
                                                    )
                                                    .finally(() =>
                                                        __privateMethod(
                                                            this,
                                                            m,
                                                            g
                                                        ).call(this)
                                                    )
                                            )
                                        );
                                    }
                                    if (__privateGet(this, o)) {
                                        const e = __privateGet(this, o);
                                        return (
                                            __privateSet(this, o, null),
                                            this._uiManager.enableWaiting(!0),
                                            void __privateSet(
                                                this,
                                                s,
                                                this._uiManager.imageManager
                                                    .getFromFile(e)
                                                    .then((e) =>
                                                        __privateMethod(
                                                            this,
                                                            h,
                                                            f
                                                        ).call(this, e)
                                                    )
                                                    .finally(() =>
                                                        __privateMethod(
                                                            this,
                                                            m,
                                                            g
                                                        ).call(this)
                                                    )
                                            )
                                        );
                                    }
                                    const e = document.createElement("input");
                                    (e.type = "file"),
                                        (e.accept = I.supportedTypesStr),
                                        __privateSet(
                                            this,
                                            s,
                                            new Promise((t) => {
                                                e.addEventListener(
                                                    "change",
                                                    async () => {
                                                        if (
                                                            e.files &&
                                                            0 !== e.files.length
                                                        ) {
                                                            this._uiManager.enableWaiting(
                                                                !0
                                                            );
                                                            const t =
                                                                await this._uiManager.imageManager.getFromFile(
                                                                    e.files[0]
                                                                );
                                                            __privateMethod(
                                                                this,
                                                                h,
                                                                f
                                                            ).call(this, t);
                                                        } else this.remove();
                                                        t();
                                                    }
                                                ),
                                                    e.addEventListener(
                                                        "cancel",
                                                        () => {
                                                            this.remove(), t();
                                                        }
                                                    );
                                            }).finally(() =>
                                                __privateMethod(
                                                    this,
                                                    m,
                                                    g
                                                ).call(this)
                                            )
                                        ),
                                        e.click();
                                }),
                                (b = new WeakSet()),
                                (y = function () {
                                    const { div: e } = this;
                                    let { width: t, height: n } = __privateGet(
                                        this,
                                        r
                                    );
                                    const [i, s] = this.pageDimensions,
                                        a = 0.75;
                                    if (this.width)
                                        (t = this.width * i),
                                            (n = this.height * s);
                                    else if (t > a * i || n > a * s) {
                                        const e = Math.min(
                                            (a * i) / t,
                                            (a * s) / n
                                        );
                                        (t *= e), (n *= e);
                                    }
                                    const [o, c] = this.parentDimensions;
                                    this.setDims((t * o) / i, (n * c) / s),
                                        this._uiManager.enableWaiting(!1);
                                    const u = __privateSet(
                                        this,
                                        l,
                                        document.createElement("canvas")
                                    );
                                    e.append(u),
                                        (e.hidden = !1),
                                        __privateMethod(this, A, R).call(
                                            this,
                                            t,
                                            n
                                        ),
                                        __privateMethod(this, k, P).call(this),
                                        __privateGet(this, p) ||
                                            (this.parent.addUndoableEditor(
                                                this
                                            ),
                                            __privateSet(this, p, !0)),
                                        this._uiManager._eventBus.dispatch(
                                            "reporttelemetry",
                                            {
                                                source: this,
                                                details: {
                                                    type: "editing",
                                                    subtype: this.editorType,
                                                    data: {
                                                        action: "inserted_image",
                                                    },
                                                },
                                            }
                                        ),
                                        this.addAltTextButton();
                                }),
                                (_ = new WeakSet()),
                                (E = function (e, t) {
                                    var n;
                                    const [r, i] = this.parentDimensions;
                                    (this.width = e / r),
                                        (this.height = t / i),
                                        this.setDims(e, t),
                                        (
                                            null == (n = this._initialOptions)
                                                ? void 0
                                                : n.isCentered
                                        )
                                            ? this.center()
                                            : this.fixAndSetPosition(),
                                        (this._initialOptions = null),
                                        null !== __privateGet(this, u) &&
                                            clearTimeout(__privateGet(this, u)),
                                        __privateSet(
                                            this,
                                            u,
                                            setTimeout(() => {
                                                __privateSet(this, u, null),
                                                    __privateMethod(
                                                        this,
                                                        A,
                                                        R
                                                    ).call(this, e, t);
                                            }, 200)
                                        );
                                }),
                                (S = new WeakSet()),
                                (w = function (e, t) {
                                    const { width: n, height: i } =
                                        __privateGet(this, r);
                                    let s = n,
                                        a = i,
                                        o = __privateGet(this, r);
                                    for (; s > 2 * e || a > 2 * t; ) {
                                        const n = s,
                                            r = a;
                                        s > 2 * e &&
                                            (s =
                                                s >= 16384
                                                    ? Math.floor(s / 2) - 1
                                                    : Math.ceil(s / 2)),
                                            a > 2 * t &&
                                                (a =
                                                    a >= 16384
                                                        ? Math.floor(a / 2) - 1
                                                        : Math.ceil(a / 2));
                                        const i = new OffscreenCanvas(s, a);
                                        i
                                            .getContext("2d")
                                            .drawImage(
                                                o,
                                                0,
                                                0,
                                                n,
                                                r,
                                                0,
                                                0,
                                                s,
                                                a
                                            ),
                                            (o = i.transferToImageBitmap());
                                    }
                                    return o;
                                }),
                                (A = new WeakSet()),
                                (R = function (e, t) {
                                    (e = Math.ceil(e)), (t = Math.ceil(t));
                                    const n = __privateGet(this, l);
                                    if (!n || (n.width === e && n.height === t))
                                        return;
                                    (n.width = e), (n.height = t);
                                    const i = __privateGet(this, d)
                                            ? __privateGet(this, r)
                                            : __privateMethod(this, S, w).call(
                                                  this,
                                                  e,
                                                  t
                                              ),
                                        s = n.getContext("2d");
                                    (s.filter = this._uiManager.hcmFilter),
                                        s.drawImage(
                                            i,
                                            0,
                                            0,
                                            i.width,
                                            i.height,
                                            0,
                                            0,
                                            e,
                                            t
                                        );
                                }),
                                (C = new WeakSet()),
                                (j = function (e) {
                                    if (e) {
                                        if (__privateGet(this, d)) {
                                            const e =
                                                this._uiManager.imageManager.getSvgUrl(
                                                    __privateGet(this, i)
                                                );
                                            if (e) return e;
                                        }
                                        const e =
                                            document.createElement("canvas");
                                        return (
                                            ({
                                                width: e.width,
                                                height: e.height,
                                            } = __privateGet(this, r)),
                                            e
                                                .getContext("2d")
                                                .drawImage(
                                                    __privateGet(this, r),
                                                    0,
                                                    0
                                                ),
                                            e.toDataURL()
                                        );
                                    }
                                    if (__privateGet(this, d)) {
                                        const [e, t] = this.pageDimensions,
                                            n = Math.round(
                                                this.width *
                                                    e *
                                                    $.PixelsPerInch
                                                        .PDF_TO_CSS_UNITS
                                            ),
                                            i = Math.round(
                                                this.height *
                                                    t *
                                                    $.PixelsPerInch
                                                        .PDF_TO_CSS_UNITS
                                            ),
                                            s = new OffscreenCanvas(n, i);
                                        return (
                                            s
                                                .getContext("2d")
                                                .drawImage(
                                                    __privateGet(this, r),
                                                    0,
                                                    0,
                                                    __privateGet(this, r).width,
                                                    __privateGet(this, r)
                                                        .height,
                                                    0,
                                                    0,
                                                    n,
                                                    i
                                                ),
                                            s.transferToImageBitmap()
                                        );
                                    }
                                    return structuredClone(
                                        __privateGet(this, r)
                                    );
                                }),
                                (k = new WeakSet()),
                                (P = function () {
                                    __privateSet(
                                        this,
                                        c,
                                        new ResizeObserver((e) => {
                                            const t = e[0].contentRect;
                                            t.width &&
                                                t.height &&
                                                __privateMethod(
                                                    this,
                                                    _,
                                                    E
                                                ).call(this, t.width, t.height);
                                        })
                                    ),
                                        __privateGet(this, c).observe(this.div);
                                }),
                                __publicField(I, "_type", "stamp");
                            let D = I;
                            t.StampEditor = D;
                        },
                    ],
                    __webpack_module_cache__ = {};
                function __w_pdfjs_require__(e) {
                    var t = __webpack_module_cache__[e];
                    if (void 0 !== t) return t.exports;
                    var n = (__webpack_module_cache__[e] = { exports: {} });
                    return (
                        __webpack_modules__[e](
                            n,
                            n.exports,
                            __w_pdfjs_require__
                        ),
                        n.exports
                    );
                }
                var __webpack_exports__ = {};
                return (
                    (() => {
                        var e = __webpack_exports__;
                        Object.defineProperty(e, "__esModule", { value: !0 }),
                            Object.defineProperty(e, "AbortException", {
                                enumerable: !0,
                                get: function () {
                                    return t.AbortException;
                                },
                            }),
                            Object.defineProperty(e, "AnnotationEditorLayer", {
                                enumerable: !0,
                                get: function () {
                                    return s.AnnotationEditorLayer;
                                },
                            }),
                            Object.defineProperty(
                                e,
                                "AnnotationEditorParamsType",
                                {
                                    enumerable: !0,
                                    get: function () {
                                        return t.AnnotationEditorParamsType;
                                    },
                                }
                            ),
                            Object.defineProperty(e, "AnnotationEditorType", {
                                enumerable: !0,
                                get: function () {
                                    return t.AnnotationEditorType;
                                },
                            }),
                            Object.defineProperty(
                                e,
                                "AnnotationEditorUIManager",
                                {
                                    enumerable: !0,
                                    get: function () {
                                        return a.AnnotationEditorUIManager;
                                    },
                                }
                            ),
                            Object.defineProperty(e, "AnnotationLayer", {
                                enumerable: !0,
                                get: function () {
                                    return o.AnnotationLayer;
                                },
                            }),
                            Object.defineProperty(e, "AnnotationMode", {
                                enumerable: !0,
                                get: function () {
                                    return t.AnnotationMode;
                                },
                            }),
                            Object.defineProperty(e, "CMapCompressionType", {
                                enumerable: !0,
                                get: function () {
                                    return t.CMapCompressionType;
                                },
                            }),
                            Object.defineProperty(e, "DOMSVGFactory", {
                                enumerable: !0,
                                get: function () {
                                    return r.DOMSVGFactory;
                                },
                            }),
                            Object.defineProperty(e, "FeatureTest", {
                                enumerable: !0,
                                get: function () {
                                    return t.FeatureTest;
                                },
                            }),
                            Object.defineProperty(e, "GlobalWorkerOptions", {
                                enumerable: !0,
                                get: function () {
                                    return l.GlobalWorkerOptions;
                                },
                            }),
                            Object.defineProperty(e, "ImageKind", {
                                enumerable: !0,
                                get: function () {
                                    return t.ImageKind;
                                },
                            }),
                            Object.defineProperty(e, "InvalidPDFException", {
                                enumerable: !0,
                                get: function () {
                                    return t.InvalidPDFException;
                                },
                            }),
                            Object.defineProperty(e, "MissingPDFException", {
                                enumerable: !0,
                                get: function () {
                                    return t.MissingPDFException;
                                },
                            }),
                            Object.defineProperty(e, "OPS", {
                                enumerable: !0,
                                get: function () {
                                    return t.OPS;
                                },
                            }),
                            Object.defineProperty(e, "PDFDataRangeTransport", {
                                enumerable: !0,
                                get: function () {
                                    return n.PDFDataRangeTransport;
                                },
                            }),
                            Object.defineProperty(e, "PDFDateString", {
                                enumerable: !0,
                                get: function () {
                                    return r.PDFDateString;
                                },
                            }),
                            Object.defineProperty(e, "PDFWorker", {
                                enumerable: !0,
                                get: function () {
                                    return n.PDFWorker;
                                },
                            }),
                            Object.defineProperty(e, "PasswordResponses", {
                                enumerable: !0,
                                get: function () {
                                    return t.PasswordResponses;
                                },
                            }),
                            Object.defineProperty(e, "PermissionFlag", {
                                enumerable: !0,
                                get: function () {
                                    return t.PermissionFlag;
                                },
                            }),
                            Object.defineProperty(e, "PixelsPerInch", {
                                enumerable: !0,
                                get: function () {
                                    return r.PixelsPerInch;
                                },
                            }),
                            Object.defineProperty(e, "PromiseCapability", {
                                enumerable: !0,
                                get: function () {
                                    return t.PromiseCapability;
                                },
                            }),
                            Object.defineProperty(
                                e,
                                "RenderingCancelledException",
                                {
                                    enumerable: !0,
                                    get: function () {
                                        return r.RenderingCancelledException;
                                    },
                                }
                            ),
                            Object.defineProperty(e, "SVGGraphics", {
                                enumerable: !0,
                                get: function () {
                                    return n.SVGGraphics;
                                },
                            }),
                            Object.defineProperty(
                                e,
                                "UnexpectedResponseExcep{
                                    return c.XfaLayer;
                                },
                            }),
                            Object.defineProperty(e, "build", {
                                enumerable: !0,
                                get: function () {
                                    return n.build;
                                },
                            }),
                            Object.defineProperty(e, "createValidAbsoluteUrl", {
                                enumerable: !0,
                                get: function () {
                                    return t.createValidAbsoluteUrl;
                                },
                            }),
                            Object.defineProperty(e, "getDocument", {
                                enumerable: !0,
                                get: function () {
                                    return n.getDocument;
                                },
                            }),
                            Object.defineProperty(e, "getFilenameFromUrl", {
                                enumerable: !0,
                                get: function () {
                                    return r.getFilenameFromUrl;
                                },
                            }),
                            Object.defineProperty(e, "getPdfFilenameFromUrl", {
                                enumerable: !0,
                                get: function () {
                                    return r.getPdfFilenameFromUrl;
                                },
                            }),
                            Object.defineProperty(e, "getXfaPageViewport", {
                                enumerable: !0,
                                get: function () {
                                    return r.getXfaPageViewport;
                                },
                            }),
                            Object.defineProperty(e, "isDataScheme", {
                                enumerable: !0,
                                get: function () {
                                    return r.isDataScheme;
                                },
                            }),
                            Object.defineProperty(e, "isPdfFile", {
                                enumerable: !0,
                                get: function () {
                                    return r.isPdfFile;
                                },
                            }),
                            Object.defineProperty(e, "loadScript", {
                                enumerable: !0,
                                get: function () {
                                    return r.loadScript;
                                },
                            }),
                            Object.defineProperty(e, "noContextMenu", {
                                enumerable: !0,
                                get: function () {
                                    return r.noContextMenu;
                                },
                            }),
                            Object.defineProperty(e, "normalizeUnicode", {
                                enumerable: !0,
                                get: function () {
                                    return t.normalizeUnicode;
                                },
                            }),
                            Object.defineProperty(e, "renderTextLayer", {
                                enumerable: !0,
                                get: function () {
                                    return i.renderTextLayer;
                                },
                            }),
                            Object.defineProperty(e, "setLayerDimensions", {
                                enumerable: !0,
                                get: function () {
                                    return r.setLayerDimensions;
                                },
                            }),
                            Object.defineProperty(e, "shadow", {
                                enumerable: !0,
                                get: function () {
                                    return t.shadow;
                                },
                            }),
                            Object.defineProperty(e, "updateTextLayer", {
                                enumerable: !0,
                                get: function () {
                                    return i.updateTextLayer;
                                },
                            }),
                            Object.defineProperty(e, "version", {
                                enumerable: !0,
                                get: function () {
                                    return n.version;
                                },
                            });
                        var t = __w_pdfjs_require__(1),
                            n = __w_pdfjs_require__(2),
                            r = __w_pdfjs_require__(6),
                            i = __w_pdfjs_require__(26),
                            s = __w_pdfjs_require__(27),
                            a = __w_pdfjs_require__(5),
                            o = __w_pdfjs_require__(29),
                            l = __w_pdfjs_require__(14),
                            c = __w_pdfjs_require__(32);
                    })(),
                    __webpack_exports__
                );
            })()),
        (module.exports = root.pdfjsLib = factory());
})(pdf);
var pdfExports = pdf.exports,
    __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
            ? function (e, t, n, r) {
                  void 0 === r && (r = n);
                  var i = Object.getOwnPropertyDescriptor(t, n);
                  (i &&
                      !("get" in i
                          ? !t.__esModule
                          : i.writable || i.configurable)) ||
                      (i = {
                          enumerable: !0,
                          get: function () {
                              return t[n];
                          },
                      }),
                      Object.defineProperty(e, r, i);
              }
            : function (e, t, n, r) {
                  void 0 === r && (r = n), (e[r] = t[n]);
              }),
    __setModuleDefault =
        (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
        (Object.create
            ? function (e, t) {
                  Object.defineProperty(e, "default", {
                      enumerable: !0,
                      value: t,
                  });
              }
            : function (e, t) {
                  e.default = t;
              }),
    __importStar =
        (commonjsGlobal && commonjsGlobal.__importStar) ||
        function (e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
                for (var n in e)
                    "default" !== n &&
                        Object.prototype.hasOwnProperty.call(e, n) &&
                        __createBinding(t, e, n);
            return __setModuleDefault(t, e), t;
        };
Object.defineProperty(pdfjs$1, "__esModule", { value: !0 });
const pdfjsModule = __importStar(pdfExports),
    pdfjs = "default" in pdfjsModule ? pdfjsModule.default : pdfjsModule;
pdfjs$1.default = pdfjs;
var Document$1 = {},
    cjs$2 = {},
    exports2,
    __spreadArray;
(exports2 = cjs$2),
    (__spreadArray =
        (commonjsGlobal && commonjsGlobal.__spreadArray) ||
        function (e, t, n) {
            if (n || 2 === arguments.length)
                for (var r, i = 0, s = t.length; i < s; i++)
                    (!r && i in t) ||
                        (r || (r = Array.prototype.slice.call(t, 0, i)),
                        (r[i] = t[i]));
            return e.concat(r || Array.prototype.slice.call(t));
        }),
    Object.defineProperty(exports2, "__esModule", { value: !0 }),
    (exports2.allEvents =
        exports2.changeEvents =
        exports2.otherEvents =
        exports2.transitionEvents =
        exports2.animationEvents =
        exports2.wheelEvents =
        exports2.uiEvents =
        exports2.pointerEvents =
        exports2.touchEvents =
        exports2.selectionEvents =
        exports2.dragEvents =
        exports2.mouseEvents =
        exports2.mediaEvents =
        exports2.keyboardEvents =
        exports2.imageEvents =
        exports2.formEvents =
        exports2.focusEvents =
        exports2.compositionEvents =
        exports2.clipboardEvents =
            void 0),
    (exports2.clipboardEvents = ["onCopy", "onCut", "onPaste"]),
    (exports2.compositionEvents = [
        "onCompositionEnd",
        "onCompositionStart",
        "onCompositionUpdate",
    ]),
    (exports2.focusEvents = ["onFocus", "onBlur"]),
    (exports2.formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"]),
    (exports2.imageEvents = ["onLoad", "onError"]),
    (exports2.keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"]),
    (exports2.mediaEvents = [
        "onAbort",
        "onCanPlay",
        "onCanPlayThrough",
        "onDurationChange",
        "onEmptied",
        "onEncrypted",
        "onEnded",
        "onError",
        "onLoadedData",
        "onLoadedMetadata",
        "onLoadStart",
        "onPause",
        "onPlay",
        "onPlaying",
        "onProgress",
        "onRateChange",
        "onSeeked",
        "onSeeking",
        "onStalled",
        "onSuspend",
        "onTimeUpdate",
        "onVolumeChange",
        "onWaiting",
    ]),
    (exports2.mouseEvents = [
        "onClick",
        "onContextMenu",
        "onDoubleClick",
        "onMouseDown",
        "onMouseEnter",
        "onMouseLeave",
        "onMouseMove",
        "onMouseOut",
        "onMouseOver",
        "onMouseUp",
    ]),
    (exports2.dragEvents = [
        "onDrag",
        "onDragEnd",
        "onDragEnter",
        "onDragExit",
        "onDragLeave",
        "onDragOver",
        "onDragStart",
        "onDrop",
    ]),
    (exports2.selectionEvents = ["onSelect"]),
    (exports2.touchEvents = [
        "onTouchCancel",
        "onTouchEnd",
        "onTouchMove",
        "onTouchStart",
    ]),
    (exports2.pointerEvents = [
        "onPointerDown",
        "onPointerMove",
        "onPointerUp",
        "onPointerCancel",
        "onGotPointerCapture",
        "onLostPointerCapture",
        "onPointerEnter",
        "onPointerLeave",
        "onPointerOver",
        "onPointerOut",
    ]),
    (exports2.uiEvents = ["onScroll"]),
    (exports2.wheelEvents = ["onWheel"]),
    (exports2.animationEvents = [
        "onAnimationStart",
        "onAnimationEnd",
        "onAnimationIteration",
    ]),
    (exports2.transitionEvents = ["onTransitionEnd"]),
    (exports2.otherEvents = ["onToggle"]),
    (exports2.changeEvents = ["onChange"]),
    (exports2.allEvents = __spreadArray(
        __spreadArray(
            __spreadArray(
                __spreadArray(
                    __spreadArray(
                        __spreadArray(
                            __spreadArray(
                                __spreadArray(
                                    __spreadArray(
                                        __spreadArray(
                                            __spreadArray(
                                                __spreadArray(
                                                    __spreadArray(
                                                        __spreadArray(
                                                            __spreadArray(
                                                                __spreadArray(
                                                                    __spreadArray(
                                                                        __spreadArray(
                                                                            [],
                                                                            exports2.clipboardEvents,
                                                                            !0
                                                                        ),
                                                                        exports2.compositionEvents,
                                                                        !0
                                                                    ),
                                                                    exports2.focusEvents,
                                                                    !0
                                                                ),
                                                                exports2.formEvents,
                                                                !0
                                                            ),
                                                            exports2.imageEvents,
                                                            !0
                                                        ),
                                                        exports2.keyboardEvents,
                                                        !0
                                                    ),
                                                    exports2.mediaEvents,
                                                    !0
                                                ),
                                                exports2.mouseEvents,
                                                !0
                                            ),
                                            exports2.dragEvents,
                                            !0
                                        ),
                                        exports2.selectionEvents,
                                        !0
                                    ),
                                    exports2.touchEvents,
                                    !0
                                ),
                                exports2.pointerEvents,
                                !0
                            ),
                            exports2.uiEvents,
                            !0
                        ),
                        exports2.wheelEvents,
                        !0
                    ),
                    exports2.animationEvents,
                    !0
                ),
                exports2.transitionEvents,
                !0
            ),
            exports2.changeEvents,
            !0
        ),
        exports2.otherEvents,
        !0
    )),
    (exports2.default = function (e, t) {
        var n = {};
        return (
            exports2.allEvents.forEach(function (r) {
                var i = e[r];
                i &&
                    (n[r] = t
                        ? function (e) {
                              return i(e, t(r));
                          }
                        : i);
            }),
            n
        );
    });
var cjs$1 = {};
function makeCancellablePromise(e) {
    var t = !1;
    return {
        promise: new Promise(function (n, r) {
            e.then(function (e) {
                return !t && n(e);
            }).catch(function (e) {
                return !t && r(e);
            });
        }),
        cancel: function () {
            t = !0;
        },
    };
}
Object.defineProperty(cjs$1, "__esModule", { value: !0 }),
    (cjs$1.default = makeCancellablePromise);
const require$$1 = getAugmentedNamespace(clsx$1);
var prefix = "Invariant failed";
function invariant(e, t) {
    if (!e) throw new Error(prefix);
}
var tinyInvariant_cjs = invariant,
    warning = function () {},
    warning_1$8 = warning,
    dist = {},
    has = Object.prototype.hasOwnProperty;
function find(e, t, n) {
    for (n of e.keys()) if (dequal(n, t)) return n;
}
function dequal(e, t) {
    var n, r, i;
    if (e === t) return !0;
    if (e && t && (n = e.constructor) === t.constructor) {
        if (n === Date) return e.getTime() === t.getTime();
        if (n === RegExp) return e.toString() === t.toString();
        if (n === Array) {
            if ((r = e.length) === t.length)
                for (; r-- && dequal(e[r], t[r]); );
            return -1 === r;
        }
        if (n === Set) {
            if (e.size !== t.size) return !1;
            for (r of e) {
                if ((i = r) && "object" == typeof i && !(i = find(t, i)))
                    return !1;
                if (!t.has(i)) return !1;
            }
            return !0;
        }
        if (n === Map) {
            if (e.size !== t.size) return !1;
            for (r of e) {
                if ((i = r[0]) && "object" == typeof i && !(i = find(t, i)))
                    return !1;
                if (!dequal(r[1], t.get(i))) return !1;
            }
            return !0;
        }
        if (n === ArrayBuffer) (e = new Uint8Array(e)), (t = new Uint8Array(t));
        else if (n === DataView) {
            if ((r = e.byteLength) === t.byteLength)
                for (; r-- && e.getInt8(r) === t.getInt8(r); );
            return -1 === r;
        }
        if (ArrayBuffer.isView(e)) {
            if ((r = e.byteLength) === t.byteLength)
                for (; r-- && e[r] === t[r]; );
            return -1 === r;
        }
        if (!n || "object" == typeof e) {
            for (n in ((r = 0), e)) {
                if (has.call(e, n) && ++r && !has.call(t, n)) return !1;
                if (!(n in t) || !dequal(e[n], t[n])) return !1;
            }
            return Object.keys(t).length === r;
        }
    }
    return e != e && t != t;
}
dist.dequal = dequal;
var DocumentContext = {};
Object.defineProperty(DocumentContext, "__esModule", { value: !0 });
const react_1$g = reactExports;
DocumentContext.default = (0, react_1$g.createContext)(null);
var Message$1 = {};
Object.defineProperty(Message$1, "__esModule", { value: !0 });
const jsx_runtime_1$b = jsxRuntimeExports;
function Message({ children: e, type: t }) {
    return (0, jsx_runtime_1$b.jsx)("div", {
        className: `react-pdf__message react-pdf__message--${t}`,
        children: e,
    });
}
Message$1.default = Message;
var LinkService$1 = {},
    __importDefault$e =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(LinkService$1, "__esModule", { value: !0 });
const tiny_invariant_1$a = __importDefault$e(tinyInvariant_cjs),
    DEFAULT_LINK_REL = "noopener noreferrer nofollow";
class LinkService {
    constructor() {
        (this.externalLinkEnabled = !0),
            (this.externalLinkRel = void 0),
            (this.externalLinkTarget = void 0),
            (this.isInPresentationMode = !1),
            (this.pdfDocument = void 0),
            (this.pdfViewer = void 0);
    }
    setDocument(e) {
        this.pdfDocument = e;
    }
    setViewer(e) {
        this.pdfViewer = e;
    }
    setExternalLinkRel(e) {
        this.externalLinkRel = e;
    }
    setExternalLinkTarget(e) {
        this.externalLinkTarget = e;
    }
    setHistory() {}
    get pagesCount() {
        return this.pdfDocument ? this.pdfDocument.numPages : 0;
    }
    get page() {
        return (
            (0, tiny_invariant_1$a.default)(
                this.pdfViewer,
                "PDF viewer is not initialized."
            ),
            this.pdfViewer.currentPageNumber || 0
        );
    }
    set page(e) {
        (0, tiny_invariant_1$a.default)(
            this.pdfViewer,
            "PDF viewer is not initialized."
        ),
            (this.pdfViewer.currentPageNumber = e);
    }
    get rotation() {
        return 0;
    }
    set rotation(e) {}
    goToDestination(e) {
        return new Promise((t) => {
            (0, tiny_invariant_1$a.default)(
                this.pdfDocument,
                "PDF document not loaded."
            ),
                (0, tiny_invariant_1$a.default)(
                    e,
                    "Destination is not specified."
                ),
                "string" == typeof e
                    ? this.pdfDocument.getDestination(e).then(t)
                    : Array.isArray(e)
                    ? t(e)
                    : e.then(t);
        }).then((e) => {
            (0, tiny_invariant_1$a.default)(
                Array.isArray(e),
                `"${e}" is not a valid destination array.`
            );
            const t = e[0];
            new Promise((e) => {
                (0, tiny_invariant_1$a.default)(
                    this.pdfDocument,
                    "PDF document not loaded."
                ),
                    t instanceof Object
                        ? this.pdfDocument
                              .getPageIndex(t)
                              .then((t) => {
                                  e(t);
                              })
                              .catch(() => {
                                  (0, tiny_invariant_1$a.default)(
                                      !1,
                                      `"${t}" is not a valid page reference.`
                                  );
                              })
                        : "number" == typeof t
                        ? e(t)
                        : (0, tiny_invariant_1$a.default)(
                              !1,
                              `"${t}" is not a valid destination reference.`
                          );
            }).then((t) => {
                const n = t + 1;
                (0, tiny_invariant_1$a.default)(
                    this.pdfViewer,
                    "PDF viewer is not initialized."
                ),
                    (0, tiny_invariant_1$a.default)(
                        n >= 1 && n <= this.pagesCount,
                        `"${n}" is not a valid page number.`
                    ),
                    this.pdfViewer.scrollPageIntoView({
                        dest: e,
                        pageIndex: t,
                        pageNumber: n,
                    });
            });
        });
    }
    navigateTo(e) {
        this.goToDestination(e);
    }
    goToPage(e) {
        const t = e - 1;
        (0, tiny_invariant_1$a.default)(
            this.pdfViewer,
            "PDF viewer is not initialized."
        ),
            (0, tiny_invariant_1$a.default)(
                e >= 1 && e <= this.pagesCount,
                `"${e}" is not a valid page number.`
            ),
            this.pdfViewer.scrollPageIntoView({ pageIndex: t, pageNumber: e });
    }
    addLinkAttributes(e, t, n) {
        (e.href = t),
            (e.rel = this.externalLinkRel || DEFAULT_LINK_REL),
            (e.target = n ? "_blank" : this.externalLinkTarget || "");
    }
    getDestinationHash() {
        return "#";
    }
    getAnchorUrl() {
        return "#";
    }
    setHash() {}
    executeNamedAction() {}
    cachePageRef() {}
    isPageVisible() {
        return !0;
    }
    isPageCached() {
        return !0;
    }
    executeSetOCGState() {}
}
LinkService$1.default = LinkService;
var PasswordResponses$1 = {};
Object.defineProperty(PasswordResponses$1, "__esModule", { value: !0 });
const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 };
PasswordResponses$1.default = PasswordResponses;
var utils = {};
!(function (e) {
    var t =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
    Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.loadFromFile =
            e.isCancelException =
            e.makePageCallback =
            e.cancelRunningTask =
            e.displayWorkerWarning =
            e.displayCORSWarning =
            e.getDevicePixelRatio =
            e.dataURItoByteString =
            e.isDataURI =
            e.isBlob =
            e.isArrayBuffer =
            e.isString =
            e.isProvided =
            e.isDefined =
            e.isLocalFileSystem =
            e.isBrowser =
                void 0);
    const n = t(tinyInvariant_cjs),
        r = t(warning_1$8);
    function i(e) {
        return void 0 !== e;
    }
    function s(e) {
        return "string" == typeof e;
    }
    function a(e) {
        return s(e) && /^data:/.test(e);
    }
    (e.isBrowser = "undefined" != typeof document),
        (e.isLocalFileSystem =
            e.isBrowser && "file:" === window.location.protocol),
        (e.isDefined = i),
        (e.isProvided = function (e) {
            return i(e) && null !== e;
        }),
        (e.isString = s),
        (e.isArrayBuffer = function (e) {
            return e instanceof ArrayBuffer;
        }),
        (e.isBlob = function (t) {
            return (
                (0, n.default)(
                    e.isBrowser,
                    "isBlob can only be used in a browser environment"
                ),
                t instanceof Blob
            );
        }),
        (e.isDataURI = a),
        (e.dataURItoByteString = function (e) {
            (0, n.default)(a(e), "Invalid data URI.");
            const [t = "", r = ""] = e.split(",");
            return -1 !== t.split(";").indexOf("base64")
                ? atob(r)
                : unescape(r);
        }),
        (e.getDevicePixelRatio = function () {
            return (e.isBrowser && window.devicePixelRatio) || 1;
        });
    const o =
        "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes.";
    (e.displayCORSWarning = function () {
        (0, r.default)(
            !e.isLocalFileSystem,
            `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${o}`
        );
    }),
        (e.displayWorkerWarning = function () {
            (0, r.default)(
                !e.isLocalFileSystem,
                `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${o}`
            );
        }),
        (e.cancelRunningTask = function (e) {
            e && e.cancel && e.cancel();
        }),
        (e.makePageCallback = function (e, t) {
            return (
                Object.defineProperty(e, "width", {
                    get() {
                        return this.view[2] * t;
                    },
                    configurable: !0,
                }),
                Object.defineProperty(e, "height", {
                    get() {
                        return this.view[3] * t;
                    },
                    configurable: !0,
                }),
                Object.defineProperty(e, "originalWidth", {
                    get() {
                        return this.view[2];
                    },
                    configurable: !0,
                }),
                Object.defineProperty(e, "originalHeight", {
                    get() {
                        return this.view[3];
                    },
                    configurable: !0,
                }),
                e
            );
        }),
        (e.isCancelException = function (e) {
            return "RenderingCancelledException" === e.name;
        }),
        (e.loadFromFile = function (e) {
            return new Promise((t, n) => {
                const r = new FileReader();
                (r.onload = () => {
                    if (!r.result)
                        return n(new Error("Error while reading a file."));
                    t(r.result);
                }),
                    (r.onerror = (e) => {
                        if (!e.target)
                            return n(new Error("Error while reading a file."));
                        const { error: t } = e.target;
                        if (!t)
                            return n(new Error("Error while reading a file."));
                        switch (t.code) {
                            case t.NOT_FOUND_ERR:
                                return n(
                                    new Error(
                                        "Error while reading a file: File not found."
                                    )
                                );
                            case t.SECURITY_ERR:
                                return n(
                                    new Error(
                                        "Error while reading a file: Security error."
                                    )
                                );
                            case t.ABORT_ERR:
                                return n(
                                    new Error(
                                        "Error while reading a file: Aborted."
                                    )
                                );
                            default:
                                return n(
                                    new Error("Error while reading a file.")
                                );
                        }
                    }),
                    r.readAsArrayBuffer(e);
            });
        });
})(utils);
var useResolver$1 = {};
Object.defineProperty(useResolver$1, "__esModule", { value: !0 });
const react_1$f = reactExports;
function reducer(e, t) {
    switch (t.type) {
        case "RESOLVE":
            return { value: t.value, error: void 0 };
        case "REJECT":
            return { value: !1, error: t.error };
        case "RESET":
            return { value: void 0, error: void 0 };
        default:
            return e;
    }
}
function useResolver() {
    return (0, react_1$f.useReducer)(reducer, { value: void 0, error: void 0 });
}
useResolver$1.default = useResolver;
var __awaiter$2 =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (e, t, n, r) {
            return new (n || (n = Promise))(function (i, s) {
                function a(e) {
                    try {
                        l(r.next(e));
                    } catch (e2) {
                        s(e2);
                    }
                }
                function o(e) {
                    try {
                        l(r.throw(e));
                    } catch (e2) {
                        s(e2);
                    }
                }
                function l(e) {
                    var t;
                    e.done
                        ? i(e.value)
                        : ((t = e.value),
                          t instanceof n
                              ? t
                              : new n(function (e) {
                                    e(t);
                                })).then(a, o);
                }
                l((r = r.apply(e, t || [])).next());
            });
        },
    __rest$4 =
        (commonjsGlobal && commonjsGlobal.__rest) ||
        function (e, t) {
            var n = {};
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) &&
                    t.indexOf(r) < 0 &&
                    (n[r] = e[r]);
            if (
                null != e &&
                "function" == typeof Object.getOwnPropertySymbols
            ) {
                var i = 0;
                for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)
                    t.indexOf(r[i]) < 0 &&
                        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
                        (n[r[i]] = e[r[i]]);
            }
            return n;
        },
    __importDefault$d =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(Document$1, "__esModule", { value: !0 });
const jsx_runtime_1$a = jsxRuntimeExports,
    react_1$e = reactExports,
    make_event_props_1$2 = __importDefault$d(cjs$2),
    make_cancellable_promise_1$6 = __importDefault$d(cjs$1),
    clsx_1$5 = __importDefault$d(require$$1),
    tiny_invariant_1$9 = __importDefault$d(tinyInvariant_cjs),
    warning_1$7 = __importDefault$d(warning_1$8),
    dequal_1 = dist,
    pdfjs_js_1$5 = __importDefault$d(pdfjs$1),
    DocumentContext_js_1$1 = __importDefault$d(DocumentContext),
    Message_js_1$1 = __importDefault$d(Message$1),
    LinkService_js_1 = __importDefault$d(LinkService$1),
    PasswordResponses_js_1$1 = __importDefault$d(PasswordResponses$1),
    utils_js_1$a = utils,
    useResolver_js_1$6 = __importDefault$d(useResolver$1),
    { PDFDataRangeTransport: PDFDataRangeTransport } = pdfjs_js_1$5.default,
    defaultOnPassword = (e, t) => {
        switch (t) {
            case PasswordResponses_js_1$1.default.NEED_PASSWORD:
                e(prompt("Enter the password to open this PDF file."));
                break;
            case PasswordResponses_js_1$1.default.INCORRECT_PASSWORD:
                e(prompt("Invalid password. Please try again."));
                break;
        }
    };
function isParameterObject(e) {
    return (
        "object" == typeof e &&
        null !== e &&
        ("data" in e || "range" in e || "url" in e)
    );
}
const Document = (0, react_1$e.forwardRef)(function (e, t) {
    var {
            children: n,
            className: r,
            error: i = "Failed to load PDF file.",
            externalLinkRel: s,
            externalLinkTarget: a,
            file: o,
            inputRef: l,
            imageResourcesPath: c,
            loading: u = "Loading PDF…",
            noData: d = "No PDF file specified.",
            onItemClick: p,
            onLoadError: h,
            onLoadProgress: f,
            onLoadSuccess: m,
            onPassword: g = defaultOnPassword,
            onSourceError: x,
            onSourceSuccess: v,
            options: b,
            renderMode: y,
            rotate: _,
        } = e,
        E = __rest$4(e, [
            "children",
            "className",
            "error",
            "externalLinkRel",
            "externalLinkTarget",
            "file",
            "inputRef",
            "imageResourcesPath",
            "loading",
            "noData",
            "onItemClick",
            "onLoadError",
            "onLoadProgress",
            "onLoadSuccess",
            "onPassword",
            "onSourceError",
            "onSourceSuccess",
            "options",
            "renderMode",
            "rotate",
        ]);
    const [S, w] = (0, useResolver_js_1$6.default)(),
        { value: A, error: R } = S,
        [C, j] = (0, useResolver_js_1$6.default)(),
        { value: k, error: P } = C,
        T = (0, react_1$e.useRef)(new LinkService_js_1.default()),
        M = (0, react_1$e.useRef)([]),
        $ = (0, react_1$e.useRef)(void 0),
        O = (0, react_1$e.useRef)(void 0);
    o &&
        o !== $.current &&
        isParameterObject(o) &&
        ((0, warning_1$7.default)(
            !(0, dequal_1.dequal)(o, $.current),
            'File prop passed to <Document /> changed, but it\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.'
        ),
        ($.current = o)),
        b &&
            b !== O.current &&
            ((0, warning_1$7.default)(
                !(0, dequal_1.dequal)(b, O.current),
                'Options prop passed to <Document /> changed, but it\'s equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.'
            ),
            (O.current = b));
    const I = (0, react_1$e.useRef)({
        scrollPageIntoView: (e) => {
            const { dest: t, pageNumber: n, pageIndex: r = n - 1 } = e;
            if (p) return void p({ dest: t, pageIndex: r, pageNumber: n });
            const i = M.current[r];
            i
                ? i.scrollIntoView()
                : (0, warning_1$7.default)(
                      !1,
                      `An internal link leading to page ${n} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`
                  );
        },
    });
    (0, react_1$e.useImperativeHandle)(
        t,
        () => ({ linkService: T, pages: M, viewer: I }),
        []
    ),
        (0, react_1$e.useEffect)(
            function () {
                w({ type: "RESET" });
            },
            [o, w]
        );
    const D = (0, react_1$e.useCallback)(
        () =>
            __awaiter$2(this, void 0, void 0, function* () {
                if (!o) return null;
                if ("string" == typeof o) {
                    if ((0, utils_js_1$a.isDataURI)(o)) {
                        return {
                            data: (0, utils_js_1$a.dataURItoByteString)(o),
                        };
                    }
                    return (0, utils_js_1$a.displayCORSWarning)(), { url: o };
                }
                if (o instanceof PDFDataRangeTransport) return { range: o };
                if ((0, utils_js_1$a.isArrayBuffer)(o)) return { data: o };
                if (utils_js_1$a.isBrowser && (0, utils_js_1$a.isBlob)(o)) {
                    return { data: yield (0, utils_js_1$a.loadFromFile)(o) };
                }
                if (
                    ((0, tiny_invariant_1$9.default)(
                        "object" == typeof o,
                        "Invalid parameter in file, need either Uint8Array, string or a parameter object"
                    ),
                    (0, tiny_invariant_1$9.default)(
                        isParameterObject(o),
                        "Invalid parameter object: need either .data, .range or .url"
                    ),
                    "url" in o && "string" == typeof o.url)
                ) {
                    if ((0, utils_js_1$a.isDataURI)(o.url)) {
                        const { url: e } = o,
                            t = __rest$4(o, ["url"]),
                            n = (0, utils_js_1$a.dataURItoByteString)(e);
                        return Object.assign({ data: n }, t);
                    }
                    (0, utils_js_1$a.displayCORSWarning)();
                }
                return o;
            }),
        [o]
    );
    function N(e, t) {
        M.current[e] = t;
    }
    function F(e) {
        delete M.current[e];
    }
    (0, react_1$e.useEffect)(() => {
        const e = (0, make_cancellable_promise_1$6.default)(D());
        return (
            e.promise
                .then((e) => {
                    w({ type: "RESOLVE", value: e });
                })
                .catch((e) => {
                    w({ type: "REJECT", error: e });
                }),
            () => {
                (0, utils_js_1$a.cancelRunningTask)(e);
            }
        );
    }, [D, w]),
        (0, react_1$e.useEffect)(() => {
            void 0 !== A &&
                (!1 !== A
                    ? v && v()
                    : R &&
                      ((0, warning_1$7.default)(!1, R.toString()), x && x(R)));
        }, [A]),
        (0, react_1$e.useEffect)(
            function () {
                j({ type: "RESET" });
            },
            [j, A]
        ),
        (0, react_1$e.useEffect)(
            function () {
                if (!A) return;
                const e = Object.assign(Object.assign({}, b), {
                        isEvalSupported: !1,
                    }),
                    t = Object.assign(Object.assign({}, A), e),
                    n = pdfjs_js_1$5.default.getDocument(t);
                f && (n.onProgress = f), g && (n.onPassword = g);
                const r = n;
                return (
                    r.promise
                        .then((e) => {
                            j({ type: "RESOLVE", value: e });
                        })
                        .catch((e) => {
                            r.destroyed || j({ type: "REJECT", error: e });
                        }),
                    () => {
                        r.destroy();
                    }
                );
            },
            [b, j, A]
        ),
        (0, react_1$e.useEffect)(() => {
            void 0 !== k &&
                (!1 !== k
                    ? k &&
                      (m && m(k),
                      (M.current = new Array(k.numPages)),
                      T.current.setDocument(k))
                    : P &&
                      ((0, warning_1$7.default)(!1, P.toString()), h && h(P)));
        }, [k]),
        (0, react_1$e.useEffect)(
            function () {
                T.current.setViewer(I.current),
                    T.current.setExternalLinkRel(s),
                    T.current.setExternalLinkTarget(a);
            },
            [s, a]
        );
    const L = (0, react_1$e.useMemo)(
            () => ({
                imageResourcesPath: c,
                linkService: T.current,
                onItemClick: p,
                pdf: k,
                registerPage: N,
                renderMode: y,
                rotate: _,
                unregisterPage: F,
            }),
            [c, p, k, y, _]
        ),
        B = (0, react_1$e.useMemo)(
            () =    );
        },
        [i, f, s, l, c, g, x]
    );
    const v = (0, react_1$4.useCallback)(() => {
        const { current: e } = f;
        e && ((e.width = 0), (e.height = 0));
    }, [f]);
    return (
        (0, react_1$4.useEffect)(() => v, [v]),
        (0, jsx_runtime_1$5.jsx)("canvas", {
            className: `${r}__canvas`,
            dir: "ltr",
            ref: (0, merge_refs_1$1.default)(h, f),
            style: { display: "block", userSelect: "none" },
            children: u
                ? (0, jsx_runtime_1$5.jsx)(StructTree_js_1.default, {})
                : null,
        })
    );
}
PageCanvas$1.default = PageCanvas;
var PageSVG$1 = {},
    __importDefault$5 =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(PageSVG$1, "__esModule", { value: !0 });
const jsx_runtime_1$4 = jsxRuntimeExports,
    react_1$3 = reactExports,
    make_cancellable_promise_1$3 = __importDefault$5(cjs$1),
    tiny_invariant_1$4 = __importDefault$5(tinyInvariant_cjs),
    warning_1$3 = __importDefault$5(warning_1$8),
    pdfjs_js_1$3 = __importDefault$5(pdfjs$1),
    usePageContext_js_1$3 = __importDefault$5(usePageContext$1),
    useResolver_js_1$3 = __importDefault$5(useResolver$1),
    utils_js_1$5 = utils;
function PageSVG() {
    const e = (0, usePageContext_js_1$3.default)();
    (0, tiny_invariant_1$4.default)(e, "Unable to find Page context.");
    const {
        _className: t,
        onRenderSuccess: n,
        onRenderError: r,
        page: i,
        rotate: s,
        scale: a,
    } = e;
    (0, tiny_invariant_1$4.default)(
        i,
        "Attempted to render page SVG, but no page was specified."
    );
    const [o, l] = (0, useResolver_js_1$3.default)(),
        { value: c, error: u } = o;
    const d = (0, react_1$3.useMemo)(
        () => i.getViewport({ scale: a, rotation: s }),
        [i, s, a]
    );
    (0, react_1$3.useEffect)(
        function () {
            l({ type: "RESET" });
        },
        [i, l, d]
    ),
        (0, react_1$3.useEffect)(
            function () {
                if (!i) return;
                const e = (0, make_cancellable_promise_1$3.default)(
                    i.getOperatorList()
                );
                return (
                    e.promise
                        .then((e) => {
                            new pdfjs_js_1$3.default.SVGGraphics(
                                i.commonObjs,
                                i.objs
                            )
                                .getSVG(e, d)
                                .then((e) => {
                                    if (!(e instanceof SVGElement))
                                        throw new Error(
                                            "getSVG returned unexpected result."
                                        );
                                    l({ type: "RESOLVE", value: e });
                                })
                                .catch((e) => {
                                    l({ type: "REJECT", error: e });
                                });
                        })
                        .catch((e) => {
                            l({ type: "REJECT", error: e });
                        }),
                    () => (0, utils_js_1$5.cancelRunningTask)(e)
                );
            },
            [i, l, d]
        ),
        (0, react_1$3.useEffect)(() => {
            void 0 !== c &&
                (!1 !== c
                    ? i && n && n((0, utils_js_1$5.makePageCallback)(i, a))
                    : u &&
                      ((0, utils_js_1$5.isCancelException)(u) ||
                          ((0, warning_1$3.default)(!1, u.toString()),
                          r && r(u))));
        }, [c]);
    const { width: p, height: h } = d;
    return (0, jsx_runtime_1$4.jsx)("div", {
        className: `${t}__svg`,
        ref: (e) =>
            (function (e) {
                if (!e || !c) return;
                e.firstElementChild || e.appendChild(c);
                const { width: t, height: n } = d;
                c.setAttribute("width", `${t}`),
                    c.setAttribute("height", `${n}`);
            })(e),
        style: {
            display: "block",
            backgroundColor: "white",
            overflow: "hidden",
            width: p,
            height: h,
            userSelect: "none",
        },
    });
}
PageSVG$1.default = PageSVG;
var TextLayer$1 = {},
    __importDefault$4 =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(TextLayer$1, "__esModule", { value: !0 });
const jsx_runtime_1$3 = jsxRuntimeExports,
    react_1$2 = reactExports,
    make_cancellable_promise_1$2 = __importDefault$4(cjs$1),
    clsx_1$3 = __importDefault$4(require$$1),
    tiny_invariant_1$3 = __importDefault$4(tinyInvariant_cjs),
    warning_1$2 = __importDefault$4(warning_1$8),
    pdfjs_js_1$2 = __importDefault$4(pdfjs$1),
    usePageContext_js_1$2 = __importDefault$4(usePageContext$1),
    useResolver_js_1$2 = __importDefault$4(useResolver$1),
    utils_js_1$4 = utils;
function isTextItem(e) {
    return "str" in e;
}
function TextLayer() {
    const e = (0, usePageContext_js_1$2.default)();
    (0, tiny_invariant_1$3.default)(e, "Unable to find Page context.");
    const {
        customTextRenderer: t,
        onGetTextError: n,
        onGetTextSuccess: r,
        onRenderTextLayerError: i,
        onRenderTextLayerSuccess: s,
        page: a,
        pageIndex: o,
        pageNumber: l,
        rotate: c,
        scale: u,
    } = e;
    (0, tiny_invariant_1$3.default)(
        a,
        "Attempted to load page text content, but no page was specified."
    );
    const [d, p] = (0, useResolver_js_1$2.default)(),
        { value: h, error: f } = d,
        m = (0, react_1$2.useRef)(null),
        g = (0, react_1$2.useRef)(void 0);
    (0, warning_1$2.default)(
        1 ===
            parseInt(
                window
                    .getComputedStyle(document.body)
                    .getPropertyValue("--react-pdf-text-layer"),
                10
            ),
        "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer"
    ),
        (0, react_1$2.useEffect)(
            function () {
                p({ type: "RESET" });
            },
            [a, p]
        ),
        (0, react_1$2.useEffect)(
            function () {
                if (!a) return;
                const e = (0, make_cancellable_promise_1$2.default)(
                        a.getTextContent()
                    ),
                    t = e;
                return (
                    e.promise
                        .then((e) => {
                            p({ type: "RESOLVE", value: e });
                        })
                        .catch((e) => {
                            p({ type: "REJECT", error: e });
                        }),
                    () => (0, utils_js_1$4.cancelRunningTask)(t)
                );
            },
            [a, p]
        ),
        (0, react_1$2.useEffect)(() => {
            void 0 !== h &&
                (!1 !== h
                    ? h && r && r(h)
                    : f &&
                      ((0, warning_1$2.default)(!1, f.toString()), n && n(f)));
        }, [h]);
    const x = (0, react_1$2.useCallback)(() => {
            s && s();
        }, [s]),
        v = (0, react_1$2.useCallback)(
            (e) => {
                (0, warning_1$2.default)(!1, e.toString()), i && i(e);
            },
            [i]
        );
    const b = (0, react_1$2.useMemo)(
        () => a.getViewport({ scale: u, rotation: c }),
        [a, c, u]
    );
    return (
        (0, react_1$2.useLayoutEffect)(
            function () {
                if (!a || !h) return;
                const { current: e } = m;
                if (!e) return;
                e.innerHTML = "";
                const n = a.streamTextContent({ includeMarkedContent: !0 }),
                    r = { container: e, textContentSource: n, viewport: b },
                    i = pdfjs_js_1$2.default.renderTextLayer(r),
                    s = i;
                return (
                    i.promise
                        .then(() => {
                            const n = document.createElement("div");
                            (n.className = "endOfContent"),
                                e.append(n),
                                (g.current = n);
                            const r = e.querySelectorAll(
                                '[role="presentation"]'
                            );
                            if (t) {
                                let e = 0;
                                h.items.forEach((n, i) => {
                                    if (!isTextItem(n)) return;
                                    const s = r[e];
                                    if (!s) return;
                                    const a = t(
                                        Object.assign(
                                            {
                                                pageIndex: o,
                                                pageNumber: l,
                                                itemIndex: i,
                                            },
                                            n
                                        )
                                    );
                                    (s.innerHTML = a),
                                        (e += n.str && n.hasEOL ? 2 : 1);
                                });
                            }
                            x();
                        })
                        .catch(v),
                    () => (0, utils_js_1$4.cancelRunningTask)(s)
                );
            },
            [t, v, x, a, o, l, h, b]
        ),
        (0, jsx_runtime_1$3.jsx)("div", {
            className: (0, clsx_1$3.default)(
                "react-pdf__Page__textContent",
                "textLayer"
            ),
            onMouseUp: function () {
                const e = g.current;
                e && e.classList.remove("active");
            },
            onMouseDown: function () {
                const e = g.current;
                e && e.classList.add("active");
            },
            ref: m,
        })
    );
}
TextLayer$1.default = TextLayer;
var AnnotationLayer$1 = {},
    __importDefault$3 =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(AnnotationLayer$1, "__esModule", { value: !0 });
const jsx_runtime_1$2 = jsxRuntimeExports,
    react_1$1 = reactExports,
    make_cancellable_promise_1$1 = __importDefault$3(cjs$1),
    clsx_1$2 = __importDefault$3(require$$1),
    tiny_invariant_1$2 = __importDefault$3(tinyInvariant_cjs),
    warning_1$1 = __importDefault$3(warning_1$8),
    pdfjs_js_1$1 = __importDefault$3(pdfjs$1),
    useDocumentContext_js_1$3 = __importDefault$3(useDocumentContext$1),
    usePageContext_js_1$1 = __importDefault$3(usePageContext$1),
    useResolver_js_1$1 = __importDefault$3(useResolver$1),
    utils_js_1$3 = utils;
function AnnotationLayer() {
    const e = (0, useDocumentContext_js_1$3.default)(),
        t = (0, usePageContext_js_1$1.default)();
    (0, tiny_invariant_1$2.default)(t, "Unable to find Page context.");
    const n = Object.assign(Object.assign({}, e), t),
        {
            imageResourcesPath: r,
            linkService: i,
            onGetAnnotationsError: s,
            onGetAnnotationsSuccess: a,
            onRenderAnnotationLayerError: o,
            onRenderAnnotationLayerSuccess: l,
            page: c,
            pdf: u,
            renderForms: d,
            rotate: p,
            scale: h = 1,
        } = n;
    (0, tiny_invariant_1$2.default)(
        u,
        "Attempted to load page annotations, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."
    ),
        (0, tiny_invariant_1$2.default)(
            c,
            "Attempted to load page annotations, but no page was specified."
        ),
        (0, tiny_invariant_1$2.default)(
            i,
            "Attempted to load page annotations, but no linkService was specified."
        );
    const [f, m] = (0, useResolver_js_1$1.default)(),
        { value: g, error: x } = f,
        v = (0, react_1$1.useRef)(null);
    (0, warning_1$1.default)(
        1 ===
            parseInt(
                window
                    .getComputedStyle(document.body)
                    .getPropertyValue("--react-pdf-annotation-layer"),
                10
            ),
        "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations"
    ),
        (0, react_1$1.useEffect)(
            function () {
                m({ type: "RESET" });
            },
            [m, c]
        ),
        (0, react_1$1.useEffect)(
            function () {
                if (!c) return;
                const e = (0, make_cancellable_promise_1$1.default)(
                        c.getAnnotations()
                    ),
                    t = e;
                return (
                    e.promise
                        .then((e) => {
                            m({ type: "RESOLVE", value: e });
                        })
                        .catch((e) => {
                            m({ type: "REJECT", error: e });
                        }),
                    () => {
                        (0, utils_js_1$3.cancelRunningTask)(t);
                    }
                );
            },
            [m, c, d]
        ),
        (0, react_1$1.useEffect)(() => {
            void 0 !== g &&
                (!1 !== g
                    ? g && a && a(g)
                    : x &&
                      ((0, warning_1$1.default)(!1, x.toString()), s && s(x)));
        }, [g]);
    const b = (0, react_1$1.useMemo)(
        () => c.getViewport({ scale: h, rotation: p }),
        [c, p, h]
    );
    return (
        (0, react_1$1.useEffect)(
            function () {
                if (!(u && c && i && g)) return;
                const { current: e } = v;
                if (!e) return;
                const t = b.clone({ dontFlip: !0 }),
                    n = {
                        accessibilityManager: null,
                        annotationCanvasMap: null,
                        div: e,
                        l10n: null,
                        page: c,
                        viewport: t,
                    },
                    s = {
                        annotations: g,
                        annotationStorage: u.annotationStorage,
                        div: e,
                        downloadManager: null,
                        imageResourcesPath: r,
                        linkService: i,
                        page: c,
                        renderForms: d,
                        viewport: t,
                    };
                e.innerHTML = "";
                try {
                    new pdfjs_js_1$1.default.AnnotationLayer(n).render(s),
                        l && l();
                } catch (a) {
                    !(function (e) {
                        (0, warning_1$1.default)(!1, `${e}`), o && o(e);
                    })(a);
                }
                return () => {};
            },
            [g, r, i, c, d, b]
        ),
        (0, jsx_runtime_1$2.jsx)("div", {
            className: (0, clsx_1$2.default)(
                "react-pdf__Page__annotations",
                "annotationLayer"
            ),
            ref: v,
        })
    );
}
AnnotationLayer$1.default = AnnotationLayer;
var __rest$1 =
        (commonjsGlobal && commonjsGlobal.__rest) ||
        function (e, t) {
            var n = {};
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) &&
                    t.indexOf(r) < 0 &&
                    (n[r] = e[r]);
            if (
                null != e &&
                "function" == typeof Object.getOwnPropertySymbols
            ) {
                var i = 0;
                for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)
                    t.indexOf(r[i]) < 0 &&
                        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
                        (n[r[i]] = e[r[i]]);
            }
            return n;
        },
    __importDefault$2 =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(Page$1, "__esModule", { value: !0 });
const jsx_runtime_1$1 = jsxRuntimeExports,
    react_1 = reactExports,
    make_cancellable_promise_1 = __importDefault$2(cjs$1),
    make_event_props_1 = __importDefault$2(cjs$2),
    clsx_1$1 = __importDefault$2(require$$1),
    merge_refs_1 = __importDefault$2(cjs),
    tiny_invariant_1$1 = __importDefault$2(tinyInvariant_cjs),
    warning_1 = __importDefault$2(warning_1$8),
    PageContext_js_1 = __importDefault$2(PageContext),
    Message_js_1 = __importDefault$2(Message$1),
    PageCanvas_js_1 = __importDefault$2(PageCanvas$1),
    PageSVG_js_1 = __importDefault$2(PageSVG$1),
    TextLayer_js_1 = __importDefault$2(TextLayer$1),
    AnnotationLayer_js_1 = __importDefault$2(AnnotationLayer$1),
    utils_js_1$2 = utils,
    useDocumentContext_js_1$2 = __importDefault$2(useDocumentContext$1),
    useResolver_js_1 = __importDefault$2(useResolver$1),
    defaultScale = 1;
function Page(e) {
    const t = (0, useDocumentContext_js_1$2.default)(),
        n = Object.assign(Object.assign({}, t), e),
        {
            _className: r = "react-pdf__Page",
            _enableRegisterUnregisterPage: i = !0,
            canvasBackground: s,
            canvasRef: a,
            children: o,
            className: l,
            customRenderer: c,
            customTextRenderer: u,
            devicePixelRatio: d,
            error: p = "Failed to load the page.",
            height: h,
            inputRef: f,
            loading: m = "Loading page…",
            noData: g = "No page specified.",
            onGetAnnotationsError: x,
            onGetAnnotationsSuccess: v,
            onGetStructTreeError: b,
            onGetStructTreeSuccess: y,
            onGetTextError: _,
            onGetTextSuccess: E,
            onLoadError: S,
            onLoadSuccess: w,
            onRenderAnnotationLayerError: A,
            onRenderAnnotationLayerSuccess: R,
            onRenderError: C,
            onRenderSuccess: j,
            onRenderTextLayerError: k,
            onRenderTextLayerSuccess: P,
            pageIndex: T,
            pageNumber: M,
            pdf: $,
            registerPage: O,
            renderAnnotationLayer: I = !0,
            renderForms: D = !1,
            renderMode: N = "canvas",
            renderTextLayer: F = !0,
            rotate: L,
            scale: B = defaultScale,
            unregisterPage: U,
            width: z,
        } = n,
        W = __rest$1(n, [
            "_className",
            "_enableRegisterUnregisterPage",
            "canvasBackground",
            "canvasRef",
            "children",
            "className",
            "customRenderer",
            "customTextRenderer",
            "devicePixelRatio",
            "error",
            "height",
            "inputRef",
            "loading",
            "noData",
            "onGetAnnotationsError",
            "onGetAnnotationsSuccess",
            "onGetStructTreeError",
            "onGetStructTreeSuccess",
            "onGetTextError",
            "onGetTextSuccess",
            "onLoadError",
            "onLoadSuccess",
            "onRenderAnnotationLayerError",
            "onRenderAnnotationLayerSuccess",
            "onRenderError",
            "onRenderSuccess",
            "onRenderTextLayerError",
            "onRenderTextLayerSuccess",
            "pageIndex",
            "pageNumber",
            "pdf",
            "registerPage",
            "renderAnnotationLayer",
            "renderForms",
            "renderMode",
            "renderTextLayer",
            "rotate",
            "scale",
            "unregisterPage",
            "width",
        ]),
        [G, V] = (0, useResolver_js_1.default)(),
        { value: H, error: q } = G,
        K = (0, react_1.useRef)(null);
    (0, tiny_invariant_1$1.default)(
        $,
        "Attempted to load a page, but no document was specified. Wrap <Page /> in a <Document /> or pass explicit `pdf` prop."
    );
    const Y = (0, utils_js_1$2.isProvided)(M) ? M - 1 : null != T ? T : null,
        X = null != M ? M : (0, utils_js_1$2.isProvided)(T) ? T + 1 : null,
        Q = null != L ? L : H ? H.rotate : null,
        J = (0, react_1.useMemo)(() => {
            if (!H) return null;
            let e = 1;
            const t = null != B ? B : defaultScale;
            if (z || h) {
                const t = H.getViewport({ scale: 1, rotation: Q });
                z ? (e = z / t.width) : h && (e = h / t.height);
            }
            return t * e;
        }, [h, H, Q, B, z]);
    (0, react_1.useEffect)(
        function () {
            return () => {
                (0, utils_js_1$2.isProvided)(Y) && i && U && U(Y);
            };
        },
        [i, $, Y, U]
    ),
        (0, react_1.useEffect)(
            function () {
                V({ type: "RESET" });
            },
            [V, $, Y]
        ),
        (0, react_1.useEffect)(
            function () {
                if (!$ || !X) return;
                const e = (0, make_cancellable_promise_1.default)($.getPage(X)),
                    t = e;
                return (
                    e.promise
                        .then((e) => {
                            V({ type: "RESOLVE", value: e });
                        })
                        .catch((e) => {
                            V({ type: "REJECT", error: e });
                        }),
                    () => (0, utils_js_1$2.cancelRunningTask)(t)
                );
            },
            [V, $, Y, X, O]
        ),
        (0, react_1.useEffect)(() => {
            void 0 !== H &&
                (!1 !== H
                    ? (function () {
                          if (w) {
                              if (!H || !J) return;
                              w((0, utils_js_1$2.makePageCallback)(H, J));
                          }
                          if (i && O) {
                              if (
                                  !(0, utils_js_1$2.isProvided)(Y) ||
                                  !K.current
                              )
                                  return;
                              O(Y, K.current);
                          }
                      })()
                    : q &&
                      ((0, warning_1.default)(!1, q.toString()), S && S(q)));
        }, [H, J]);
    const Z = (0, react_1.useMemo)(
            () =>
                H &&
                (0, utils_js_1$2.isProvided)(Y) &&
                X &&
                (0, utils_js_1$2.isProvided)(Q) &&
                (0, utils_js_1$2.isProvided)(J)
                    ? {
                          _className: r,
                          canvasBackground: s,
                          customTextRenderer: u,
                          devicePixelRatio: d,
                          onGetAnnotationsError: x,
                          onGetAnnotationsSuccess: v,
                          onGetStructTreeError: b,
                          onGetStructTreeSuccess: y,
                          onGetTextError: _,
                          onGetTextSuccess: E,
                          onRenderAnnotationLayerError: A,
                          onRenderAnnotationLayerSuccess: R,
                          onRenderError: C,
                          onRenderSuccess: j,
                          onRenderTextLayerError: k,
                          onRenderTextLayerSuccess: P,
                          page: H,
                          pageIndex: Y,
                          pageNumber: X,
                          renderForms: D,
                          renderTextLayer: F,
                          rotate: Q,
                          scale: J,
                      }
                    : null,
            [
                r,
                s,
                u,
                d,
                x,
                v,
                b,
                y,
                _,
                E,
                A,
                R,
                C,
                j,
                k,
                P,
                H,
                Y,
                X,
                D,
                F,
                Q,
                J,
            ]
        ),
        ee = (0, react_1.useMemo)(
            () =>
                (0, make_event_props_1.default)(W, () =>
                    H
                        ? J
                            ? (0, utils_js_1$2.makePageCallback)(H, J)
                            : void 0
                        : H
                ),
            [W, H, J]
        ),
        te = `${Y}@${J}/${Q}`,
        ne = `${Y}/${Q}`;
    function re() {
        switch (N) {
            case "custom":
                return (
                    (0, tiny_invariant_1$1.default)(
                        c,
                        'renderMode was set to "custom", but no customRenderer was passed.'
                    ),
                    (0, jsx_runtime_1$1.jsx)(c, {}, `${te}_custom`)
                );
            case "none":
                return null;
            case "svg":
                return (0, jsx_runtime_1$1.jsx)(
                    PageSVG_js_1.default,
                    {},
                    `${ne}_svg`
                );
            default:
                return (0, jsx_runtime_1$1.jsx)(
                    PageCanvas_js_1.default,
                    { canvasRef: a },
                    `${te}_canvas`
                );
        }
    }
    return (0, jsx_runtime_1$1.jsx)(
        "div",
        Object.assign(
            {
                className: (0, clsx_1$1.default)(r, l),
                "data-page-number": X,
                ref: (0, merge_refs_1.default)(f, K),
                style: {
                    "--scale-factor": `${J}`,
                    backgroundColor: s || "white",
                    position: "relative",
                    minWidth: "min-content",
                    minHeight: "min-content",
                },
            },
            ee,
            {
                children: X
                    ? null === $ || null == H
                        ? (0, jsx_runtime_1$1.jsx)(Message_js_1.default, {
                              type: "loading",
                              children: "function" == typeof m ? m() : m,
                          })
                        : !1 === $ || !1 === H
                        ? (0, jsx_runtime_1$1.jsx)(Message_js_1.default, {
                              type: "error",
                              children: "function" == typeof p ? p() : p,
                          })
                        : (0, jsx_runtime_1$1.jsxs)(
                              PageContext_js_1.default.Provider,
                              {
                                  value: Z,
                                  children: [
                                      re(),
                                      F
                                          ? (0, jsx_runtime_1$1.jsx)(
                                                TextLayer_js_1.default,
                                                {},
                                                `${te}_text`
                                            )
                                          : null,
                                      I
                                          ? (0, jsx_runtime_1$1.jsx)(
                                                AnnotationLayer_js_1.default,
                                                {},
                                                `${te}_annotations`
                                            )
                                          : null,
                                      o,
                                  ],
                              }
                          )
                    : (0, jsx_runtime_1$1.jsx)(Message_js_1.default, {
                          type: "no-data",
                          children: "function" == typeof g ? g() : g,
                      }),
            }
        )
    );
}
Page$1.default = Page;
var Thumbnail$1 = {},
    __rest =
        (commonjsGlobal && commonjsGlobal.__rest) ||
        function (e, t) {
            var n = {};
            for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) &&
                    t.indexOf(r) < 0 &&
                    (n[r] = e[r]);
            if (
                null != e &&
                "function" == typeof Object.getOwnPropertySymbols
            ) {
                var i = 0;
                for (r = Object.getOwnPropertySymbols(e); i < r.length; i++)
                    t.indexOf(r[i]) < 0 &&
                        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
                        (n[r[i]] = e[r[i]]);
            }
            return n;
        },
    __importDefault$1 =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (e) {
            return e && e.__esModule ? e : { default: e };
        };
Object.defineProperty(Thumbnail$1, "__esModule", { value: !0 });
const jsx_runtime_1 = jsxRuntimeExports,
    clsx_1 = __importDefault$1(require$$1),
    tiny_invariant_1 = __importDefault$1(tinyInvariant_cjs),
    Page_js_1$1 = __importDefault$1(Page$1),
    utils_js_1$1 = utils,
    useDocumentContext_js_1$1 = __importDefault$1(useDocumentContext$1);
function Thumbnail(e) {
    const t = (0, useDocumentContext_js_1$1.default)(),
        n = Object.assign(Object.assign({}, t), e),
        {
            className: r,
            linkService: i,
            onItemClick: s,
            pageIndex: a,
            pageNumber: o,
            pdf: l,
        } = n;
    (0, tiny_invariant_1.default)(
        l,
        "Attempted to load a thumbnail, but no document was specified. Wrap <Thumbnail /> in a <Document /> or pass explicit `pdf` prop."
    );
    const c = (0, utils_js_1$1.isProvided)(o) ? o - 1 : null != a ? a : null,
        u = null != o ? o : (0, utils_js_1$1.isProvided)(a) ? a + 1 : null;
    const d = __rest(e, ["className", "onItemClick"]);
    return (0, jsx_runtime_1.jsx)("a", {
        className: (0, clsx_1.default)("react-pdf__Thumbnail", r),
        href: u ? "#" : void 0,
        onClick: function (e) {
            e.preventDefault(),
                (0, utils_js_1$1.isProvided)(c) &&
                    u &&
                    ((0, tiny_invariant_1.default)(
                        s || i,
                        "Either onItemClick callback or linkService must be defined in order to navigate to an outline item."
                    ),
                    s
                        ? s({ pageIndex: c, pageNumber: u })
                        : i && i.goToPage(u));
        },
        children: (0, jsx_runtime_1.jsx)(
            Page_js_1$1.default,
            Object.assign({}, d, {
                _className: "react-pdf__Thumbnail__page",
                _enableRegisterUnregisterPage: !1,
                renderAnnotationLayer: !1,
                renderTextLayer: !1,
            })
        ),
    });
}
Thumbnail$1.default = Thumbnail;
var __importDefault =
    (commonjsGlobal && commonjsGlobal.__importDefault) ||
    function (e) {
        return e && e.__esModule ? e : { default: e };
    };
Object.defineProperty(cjs$3, "__esModule", { value: !0 }),
    (cjs$3.PasswordResponses =
        cjs$3.usePageContext =
        cjs$3.useOutlineContext =
        cjs$3.useDocumentContext =
        cjs$3.Thumbnail =
        cjs$3.Page =
        cjs$3.Outline =
        cjs$3.Document =
        cjs$3.pdfjs =
            void 0);
const pdfjs_js_1 = __importDefault(pdfjs$1);
cjs$3.pdfjs = pdfjs_js_1.default;
const Document_js_1 = __importDefault(Document$1);
cjs$3.Document = Document_js_1.default;
const Outline_js_1 = __importDefault(Outline$1);
cjs$3.Outline = Outline_js_1.default;
const Page_js_1 = __importDefault(Page$1);
cjs$3.Page = Page_js_1.default;
const Thumbnail_js_1 = __importDefault(Thumbnail$1);
cjs$3.Thumbnail = Thumbnail_js_1.default;
const useDocumentContext_js_1 = __importDefault(useDocumentContext$1);
cjs$3.useDocumentContext = useDocumentContext_js_1.default;
const useOutlineContext_js_1 = __importDefault(useOutlineContext$1);
cjs$3.useOutlineContext = useOutlineContext_js_1.default;
const usePageContext_js_1 = __importDefault(usePageContext$1);
cjs$3.usePageContext = usePageContext_js_1.default;
const PasswordResponses_js_1 = __importDefault(PasswordResponses$1);
cjs$3.PasswordResponses = PasswordResponses_js_1.default;
const utils_js_1 = utils;
(0, utils_js_1.displayWorkerWarning)(),
    (pdfjs_js_1.default.GlobalWorkerOptions.workerSrc = "pdf.worker.js");
var __awaiter =
    (commonjsGlobal && commonjsGlobal.__awaiter) ||
    function (e, t, n, r) {
        return new (n || (n = Promise))(function (i, s) {
            function a(e) {
                try {
                    l(r.next(e));
                } catch (e2) {
                    s(e2);
                }
            }
            function o(e) {
                try {
                    l(r.throw(e));
                } catch (e2) {
                    s(e2);
                }
            }
            function l(e) {
                var t;
                e.done
                    ? i(e.value)
                    : ((t = e.value),
                      t instanceof n
                          ? t
                          : new n(function (e) {
                                e(t);
                            })).then(a, o);
            }
            l((r = r.apply(e, t || [])).next());
        });
    };
Object.defineProperty(dist$1, "__esModule", { value: !0 });
const react_pdf_1 = cjs$3;
react_pdf_1.pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${react_pdf_1.pdfjs.version}/pdf.worker.js`;
const pdfToText = (e) =>
    __awaiter(void 0, void 0, void 0, function* () {
        const t = URL.createObjectURL(e),
            n = react_pdf_1.pdfjs.getDocument(t);
        let r = "",
            i = !1;
        try {
            const e = yield n.promise,
                t = e.numPages;
            for (let n = 1; n <= t; n++) {
                const t = yield e.getPage(n),
                    i = yield t.getTextContent();
                r += i.items.map((e) => ("str" in e ? e.str : "")).join(" ");
            }
        } catch (s) {
            (i = !0), console.error("Error extracting text from PDF:", s);
        }
        if ((URL.revokeObjectURL(t), n.destroy(), !i)) return r;
    });
var _default = (dist$1.default = pdfToText);
const Input = ({
        label: e,
        name: t,
        value: n,
        onChange: r,
        type: i = "text",
    }) =>
        jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
                jsxRuntimeExports.jsx("label", {
                    className: "block text-gray-700 text-sm font-bold mb-2",
                    htmlFor: "name",
                    children: e,
                }),
                jsxRuntimeExports.jsx("input", {
                    type: i,
                    name: t,
                    value: n,
                    onChange: r,
                    className:
                        "shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline",
                    required: !0,
                }),
            ],
        }),
    DepositConfirmationForm = ({
        handleSubmit: e,
        handleFileChange: t,
        extractText: n,
        amountFromForm: r,
        handleAmountChange: i,
        isLoading: s,
        isError: a,
        errorMsg: o,
    }) =>
        jsxRuntimeExports.jsxs("f